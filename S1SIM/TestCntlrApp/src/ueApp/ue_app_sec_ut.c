/* Header include files (.h)                                  */
#include "envopt.h"        /* Environment options             */
#include "envdep.h"        /* Environment dependent           */
#include "envind.h"        /* Environment independent         */
#include "gen.h"           /* General                         */
#include "ssi.h"           /* System services */
#include "ss_queue.h"      /* System services interface       */
#include "ss_mem.h"        /* System services interface       */
#include "cm5.h"           /* Common timer library            */
#include "cm_llist.h"      /* Common linked list library      */
#include "cm_hash.h"       /* Common hash library             */
#include "cm_tkns.h"       /* Common tokens                   */
#include "cm_mblk.h"       /* Common memory allocation        */
#include "cm_inet.h"       /* Common socket library           */
#include "cm_pasn.h"       /* Common ASN.1 library            */
#include "ue_app_sec.h"
#include "ue_emm.h"

/* header/extern include files (.x)                           */
#include "gen.x"           /* General layer                   */
#include "ssi.x"           /* System services interface       */
#include "ss_queue.x"      /* System services interface       */
#include "ss_task.x"       /* System services interface       */
#include "ss_msg.x"        /* System services interface       */
#include "ss_mem.x"        /* System services interface       */
#include "cm5.x"           /* Common timer module             */
#include "cm_lib.x"        /* Common library function         */
#include "cm_llist.x"      /* Common link list library        */
#include "cm_hash.x"       /* Common hash list library        */
#include "ue_app_sec.x"
#include "ue_alg_intf.x"

#define TEST_PDCP_SNOW_3G 0

#define TEST_CASE_1 1 /*Snow 3G Encryption*/
#define TEST_CASE_2 0 /*Snow 3G Integrity*/
#define TEST_CASE_3 0 /*Hmac-Sha-256 Key Gen*/
#define TEST_CASE_4 0 /*Hmac-Sha-256 Key Gen*/

#if TEST_PDCP_SNOW_3G
#include "uea.h"
#else
#include "ext_common.h"
#include "snow3g_f8f9.h"
#include "hmacsha256.h"
#endif


int main(Void)
{
   U16 len         = 0;
#if TEST_CASE_1
   U32 count_1     = 0x72A4F20F;
   U32  bearer_1   = 0x0C;
   U32  dir_1      = 0x01;
   U8  key_1[]     = {
      0x2B,0xD6,0x45,0x9F, 0x82,0xC5,0xB3,0x00, 
      0x95,0x2C,0x49,0x10, 0x48,0x81,0xFF,0x48
   };
   U32 length_1    = 798 ;
   U8 msg_1[]      = {
      0x7E,0xC6,0x12,0x72, 0x74,0x3B,0xF1,0x61, 
      0x47,0x26,0x44,0x6A, 0x6C,0x38,0xCE,0xD1,
      0x66,0xF6,0xCA,0x76, 0xEB,0x54,0x30,0x04, 
      0x42,0x86,0x34,0x6C, 0xEF,0x13,0x0F,0x92,
      0x92,0x2B,0x03,0x45, 0x0D,0x3A,0x99,0x75, 
      0xE5,0xBD,0x2E,0xA0, 0xEB,0x55,0xAD,0x8E,
      0x1B,0x19,0x9E,0x3E, 0xC4,0x31,0x60,0x20, 
      0xE9,0xA1,0xB2,0x85, 0xE7,0x62,0x79,0x53,
      0x59,0xB7,0xBD,0xFD, 0x39,0xBE,0xF4,0xB2, 
      0x48,0x45,0x83,0xD5, 0xAF,0xE0,0x82,0xAE,
      0xE6,0x38,0xBF,0x5F, 0xD5,0xA6,0x06,0x19, 
      0x39,0x01,0xA0,0x8F, 0x4A,0xB4,0x1A,0xAB,
      0x9B,0x13,0x48,0x80
   };
#ifdef LTE_UE_NAS_SEC
   U8 msg_expted[] = {
      0x8C,0xEB,0xA6,0x29 ,0x43,0xDC,0xED,0x3A,
      0x09,0x90,0xB0,0x6E ,0xA1,0xB0,0xA2,0xC4,
      0xFB,0x3C,0xED,0xC7 ,0x1B,0x36,0x9F,0x42,
      0xBA,0x64,0xC1,0xEB ,0x66,0x65,0xE7,0x2A,
      0xA1,0xC9,0xBB,0x0D ,0xEA,0xA2,0x0F,0xE8,
      0x60,0x58,0xB8,0xBA ,0xEE,0x2C,0x2E,0x7F,
      0x0B,0xEC,0xCE,0x48 ,0xB5,0x29,0x32,0xA5,
      0x3C,0x9D,0x5F,0x93 ,0x1A,0x3A,0x7C,0x53,
      0x22,0x59,0xAF,0x43 ,0x25,0xE2,0xA6,0x5E,
      0x30,0x84,0xAD,0x5F ,0x6A,0x51,0x3B,0x7B,
      0xDD,0xC1,0xB6,0x5F ,0x0A,0xA0,0xD9,0x7A,
      0x05,0x3D,0xB5,0x5A ,0x88,0xC4,0xC4,0xF9,
      0x60,0x5E,0x41,0x40
   };
#endif
   UE_APP_SEC_TRC1(main)
      len = length_1/8+ (length_1%8?1:0);

   UE_APP_SEC_PRNT_INFO(("Test Case 1: Snow-3G Encryption Verification"))
      UE_APP_SEC_PRNT_HEX("Input Buffer", msg_1, len);
#if TEST_PDCP_SNOW_3G
   cmSnowF8(key_1, count_1, bearer_1, dir_1, msg_1, length_1);
#else
   f8Snow3g(key_1, count_1, bearer_1, dir_1, msg_1, length_1);
#endif
   UE_APP_SEC_PRNT_HEX("Expected Buffer", msg_expted, len);
   UE_APP_SEC_PRNT_HEX("Output Buffer", msg_1, len);
#endif
   /******************************************************/

#if TEST_CASE_2

#if TEST_PDCP_SNOW_3G
   U8 *mac          = 0;
#else
   U32 mac          = 0;
   U8  calcMac[4]      = {0};
#endif
   U8  exptedMac[] = {
      0x2B,0xCE,0x18,0x20
   };
   U32  count_1     = 0x38A6F056;
   U32  bearer_1    = 0x05D2EC49;
   U32  dir_1       = 0x0;
   U8   key_1[]     = {
      0x2B,0xD6,0x45,0x9F,0x82,0xC5,0xB3,0x00,
      0x95,0x2C,0x49,0x10,0x48,0x81,0xFF,0x48
   };
   U32  length_1    = 189 ;
   U8   msg_1[]     = {
      0x6B,0x22,0x77,0x37, 0x29,0x6F,0x39,0x3C, 0x80,0x79,0x35,0x3E, 0xDC,0x87,0xE2,0xE8, 
      0x05,0xD2,0xEC,0x49, 0xA4,0xF2,0xD8,0xE0 
   };
   UE_APP_SEC_TRC1(main)
      len = length_1/8+ (length_1%8?1:0);
   UE_APP_SEC_PRNT_INFO(("Test Case 2: Snow-3G Integrity Verification"))
      UE_APP_SEC_PRNT_HEX("Input Buffer", msg_1, len);
   UE_APP_SEC_PRNT_HEX("Expected MAC", exptedMac, 4);

#if TEST_PDCP_SNOW_3G
   mac = cmSnowF9(key_1, count_1, bearer_1, dir_1, msg_1, length_1);
   UE_APP_SEC_PRNT_HEX("Calc MAC", mac, 4);
#else
   mac = f9Snow3g(key_1, count_1, bearer_1, dir_1, msg_1, length_1);
   calcMac[0] = mac>>24 & 0xFF;
   calcMac[1] = mac>>16 & 0xFF;
   calcMac[2] = mac>>8 & 0xFF;
   calcMac[3] = mac & 0xFF;
   UE_APP_SEC_PRNT_HEX("Calc MAC", calcMac, 4);
#endif

#endif

#if TEST_CASE_3
   U8 key[] = { 
      0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
      0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
      0xAA, 0xAA, 0xAA, 0xAA
   };
   U8 keyLen = 20;
   U8 data[] = {
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD,
      0xDD, 0xDD
   };
   U8 exptdOutputLen = 32;
   U8 exptdOutput[] = { 
      0x77, 0x3e, 0xa9, 0x1e, 0x36, 0x80, 0x0e, 0x46,
      0x85, 0x4d, 0xb8, 0xeb, 0xd0, 0x91, 0x81, 0xa7,
      0x29, 0x59, 0x09, 0x8b, 0x3e, 0xf8, 0xc1, 0x22,
      0xd9, 0x63, 0x55, 0x14, 0xce, 0xd5, 0x65, 0xfe
   };
   U8 dataLen   = 50;
   U8 hash[512] = {'\0'};
   U8 hashLen   = 32;
   hmacsha256Param sp1;

   UE_APP_SEC_TRC1(main)

      UE_APP_SEC_PRNT_INFO(("Test Case 3: Hmac-Sha-256 Key Generation Verification"))

      UE_APP_SEC_PRNT_HEX("Key", key, keyLen);
   UE_APP_SEC_PRNT_HEX("Data", data, dataLen);
   UE_APP_SEC_PRNT_HEX("Expected output", exptdOutput, exptdOutputLen);

   /*Setup - Give key- In bits*/
   hmacsha256Setup (&sp1, (const byte*) key, (size_t) keyLen*8);
   /*Input data- In bytes*/
   hmacsha256Update(&sp1, (const byte*) data, (size_t) dataLen);
   /*Get MAC*/
   hmacsha256Digest(&sp1, (byte*) hash);

   UE_APP_SEC_PRNT_HEX("Output", hash, hashLen);
   UNUSED(len);

#endif

#if TEST_CASE_4
   U8 key[] = { 
      0x4a, 0x65, 0x66, 0x65
   };
   U8 keyLen = 4;
   U8 data[] = {
      0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 
      0x79, 0x61, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 
      0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68, 
      0x69, 0x6e, 0x67, 0x3f
   };
   U8 dataLen = 28;
   U8 exptdOutput[] = {
      0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e,
      0x6a, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xc7,
      0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83,
      0x9d, 0xec, 0x58, 0xb9, 0x64, 0xec, 0x38, 0x43
   };
   U8 exptdOutputLen = 32;
   U8 hash[512] = {'\0'};
   U8 hashLen = 32;
   hmacsha256Param sp1;

   UE_APP_SEC_TRC1(main)
      UE_APP_SEC_PRNT_INFO(("Test Case 4: Hmac-Sha-256 Key Generation Verification"))

      UE_APP_SEC_PRNT_HEX("Key", key, keyLen);
   UE_APP_SEC_PRNT_HEX("Data", data, dataLen);
   UE_APP_SEC_PRNT_HEX("Expected output", exptdOutput, exptdOutputLen);
   /*Setup - Give key- In bits*/
   hmacsha256Setup (&sp1, (const byte*) key, (size_t) keyLen*8);
   /*Input data- In bytes*/
   hmacsha256Update(&sp1, (const byte*) data, (size_t) dataLen);
   /*Get MAC*/
   hmacsha256Digest(&sp1, (byte*) hash);

   UE_APP_SEC_PRNT_HEX("Output", hash, hashLen);

   UNUSED(len);

#endif

   UNUSED(len);
   RETVALUE(0);
}
