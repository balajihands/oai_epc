


/************************************************************************
 
     Name:     LTE-MAC layer
  
     Type:     C source file
  
     Desc:     C source code for Entry point fucntions
  
     File:     rg_dhm.c
  
     Sid:      rgac_tfuutl.c@@/main/3 - Sat Jul 30 02:21:10 2011
  
     Prg:      ps
  
**********************************************************************/

/** @file rg_dhm.c
@brief APIs related to Downlink HARQ.
*/



/* Include files */

#include "rg_env.h"
#include "rg.h"
#include "rgac_acc.x"

typedef U32 RgAcTbSzTbl[RG_NUM_ITBS][RG_MAX_NUM_RB];
#ifdef LTEMAC_MIMO
typedef U32 RgAcTbSzTbl2Lyr[RG_MAX_LYR_PERCW][RG_NUM_ITBS][RG_MAX_NUM_RB];
#endif
typedef struct rgAcUlIMcsTbl
{
   U8    qm;
   U8    iTbs;
} RgAcUlIMcsTbl[29];

PRIVATE S8  accumTpcArr[4] = {
   -1, 0, 1, 3
};

PRIVATE S8  abstTpcArr[4] = {
   -4, -1, 1, 4
};

PRIVATE RgAcTbSzTbl tbsTbl = {
   {16,    32,    56,    88,    120,   152,   176,   208,   224,   256,   288,   328,   344,   376,   392,   424,   456,   488,   504,   536,   568,   600,   616,   648,   680,   712,   744,   776,   776,   808,   840,   872,   904,   936,   968,   1000,  1032,  1032,  1064,  1096,  1128,  1160,  1192,  1224,  1256,  1256,  1288,  1320,  1352,  1384,  1416,  1416,  1480,  1480,  1544,  1544,  1608,  1608,  1608,  1672,  1672,  1736,  1736,  1800,  1800,  1800,  1864,  1864,  1928,  1928,  1992,  1992,  2024,  2088,  2088,  2088,  2152,  2152,  2216,  2216,  2280,  2280,  2280,  2344,  2344,  2408,  2408,  2472,  2472,  2536,  2536,  2536,  2600,  2600,  2664,  2664,  2728,  2728,  2728,  2792,  2792,  2856,  2856,  2856,  2984,  2984,  2984,  2984,  2984,  3112},
   {24,    56,    88,    144,   176,   208,   224,   256,   328,   344,   376,   424,   456,   488,   520,   568,   600,   632,   680,   712,   744,   776,   808,   872,   904,   936,   968,   1000,  1032,  1064,  1128,  1160,  1192,  1224,  1256,  1288,  1352,  1384,  1416,  1416,  1480,  1544,  1544,  1608,  1608,  1672,  1736,  1736,  1800,  1800,  1864,  1864,  1928,  1992,  1992,  2024,  2088,  2088,  2152,  2152,  2216,  2280,  2280,  2344,  2344,  2408,  2472,  2472,  2536,  2536,  2600,  2600,  2664,  2728,  2728,  2792,  2792,  2856,  2856,  2856,  2984,  2984,  2984,  3112,  3112,  3112,  3240,  3240,  3240,  3240,  3368,  3368,  3368,  3496,  3496,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3752,  3752,  3880,  3880,  3880,  4008,  4008,  4008},
   {32,    72,    144,   176,   208,   256,   296,   328,   376,   424,   472,   520,   568,   616,   648,   696,   744,   776,   840,   872,   936,   968,   1000,  1064,  1096,  1160,  1192,  1256,  1288,  1320,  1384,  1416,  1480,  1544,  1544,  1608,  1672,  1672,  1736,  1800,  1800,  1864,  1928,  1992,  2024,  2088,  2088,  2152,  2216,  2216,  2280,  2344,  2344,  2408,  2472,  2536,  2536,  2600,  2664,  2664,  2728,  2792,  2856,  2856,  2856,  2984,  2984,  3112,  3112,  3112,  3240,  3240,  3240,  3368,  3368,  3368,  3496,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3880,  3880,  3880,  4008,  4008,  4008,  4136,  4136,  4136,  4264,  4264,  4264,  4392,  4392,  4392,  4584,  4584,  4584,  4584,  4584,  4776,  4776,  4776,  4776,  4968,  4968},
   {40,    104,   176,   208,   256,   328,   392,   440,   504,   568,   616,   680,   744,   808,   872,   904,   968,   1032,  1096,  1160,  1224,  1256,  1320,  1384,  1416,  1480,  1544,  1608,  1672,  1736,  1800,  1864,  1928,  1992,  2024,  2088,  2152,  2216,  2280,  2344,  2408,  2472,  2536,  2536,  2600,  2664,  2728,  2792,  2856,  2856,  2984,  2984,  3112,  3112,  3240,  3240,  3368,  3368,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3880,  3880,  4008,  4008,  4136,  4136,  4264,  4264,  4392,  4392,  4392,  4584,  4584,  4584,  4776,  4776,  4776,  4776,  4968,  4968,  4968,  5160,  5160,  5160,  5352,  5352,  5352,  5352,  5544,  5544,  5544,  5736,  5736,  5736,  5736,  5992,  5992,  5992,  5992,  6200,  6200,  6200,  6200,  6456,  6456},
   {56,    120,   208,   256,   328,   408,   488,   552,   632,   696,   776,   840,   904,   1000,  1064,  1128,  1192,  1288,  1352,  1416,  1480,  1544,  1608,  1736,  1800,  1864,  1928,  1992,  2088,  2152,  2216,  2280,  2344,  2408,  2472,  2600,  2664,  2728,  2792,  2856,  2984,  2984,  3112,  3112,  3240,  3240,  3368,  3496,  3496,  3624,  3624,  3752,  3752,  3880,  4008,  4008,  4136,  4136,  4264,  4264,  4392,  4392,  4584,  4584,  4584,  4776,  4776,  4968,  4968,  4968,  5160,  5160,  5160,  5352,  5352,  5544,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7480,  7480,  7736,  7736,  7736,  7992},
   {72,    144,   224,   328,   424,   504,   600,   680,   776,   872,   968,   1032,  1128,  1224,  1320,  1384,  1480,  1544,  1672,  1736,  1864,  1928,  2024,  2088,  2216,  2280,  2344,  2472,  2536,  2664,  2728,  2792,  2856,  2984,  3112,  3112,  3240,  3368,  3496,  3496,  3624,  3752,  3752,  3880,  4008,  4008,  4136,  4264,  4392,  4392,  4584,  4584,  4776,  4776,  4776,  4968,  4968,  5160,  5160,  5352,  5352,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  7992,  8248,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  8760,  9144,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9528},
   {88,    176,   256,   392,   504,   600,   712,   808,   936,   1032,  1128,  1224,  1352,  1480,  1544,  1672,  1736,  1864,  1992,  2088,  2216,  2280,  2408,  2472,  2600,  2728,  2792,  2984,  2984,  3112,  3240,  3368,  3496,  3496,  3624,  3752,  3880,  4008,  4136,  4136,  4264,  4392,  4584,  4584,  4776,  4776,  4968,  4968,  5160,  5160,  5352,  5352,  5544,  5736,  5736,  5992,  5992,  5992,  6200,  6200,  6456,  6456,  6456,  6712,  6712,  6968,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  8248,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10296, 10680, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448},
   {104,   224,   328,   472,   584,   712,   840,   968,   1096,  1224,  1320,  1480,  1608,  1672,  1800,  1928,  2088,  2216,  2344,  2472,  2536,  2664,  2792,  2984,  3112,  3240,  3368,  3368,  3496,  3624,  3752,  3880,  4008,  4136,  4264,  4392,  4584,  4584,  4776,  4968,  4968,  5160,  5352,  5352,  5544,  5736,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7992,  7992,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11448, 11832, 11832, 11832, 12216, 12216, 12216, 12576, 12576, 12576, 12960, 12960, 12960, 12960, 13536, 13536},
   {120,   256,   392,   536,   680,   808,   968,   1096,  1256,  1384,  1544,  1672,  1800,  1928,  2088,  2216,  2344,  2536,  2664,  2792,  2984,  3112,  3240,  3368,  3496,  3624,  3752,  3880,  4008,  4264,  4392,  4584,  4584,  4776,  4968,  4968,  5160,  5352,  5544,  5544,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7992,  7992,  8248,  8504,  8504,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11832, 11832, 12216, 12216, 12216, 12576, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 13536, 14112, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15264},
   {136,   296,   456,   616,   776,   936,   1096,  1256,  1416,  1544,  1736,  1864,  2024,  2216,  2344,  2536,  2664,  2856,  2984,  3112,  3368,  3496,  3624,  3752,  4008,  4136,  4264,  4392,  4584,  4776,  4968,  5160,  5160,  5352,  5544,  5736,  5736,  5992,  6200,  6200,  6456,  6712,  6712,  6968,  6968,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8248,  8504,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11832, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 13536, 14112, 14112, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16416, 16992, 16992, 16992, 16992, 17568},
   {144,   328,   504,   680,   872,   1032,  1224,  1384,  1544,  1736,  1928,  2088,  2280,  2472,  2664,  2792,  2984,  3112,  3368,  3496,  3752,  3880,  4008,  4264,  4392,  4584,  4776,  4968,  5160,  5352,  5544,  5736,  5736,  5992,  6200,  6200,  6456,  6712,  6712,  6968,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8504,  8504,  8760,  9144,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10296, 10680, 10680, 11064, 11064, 11448, 11448, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 18336, 18336, 19080, 19080, 19080, 19080},
   {176,   376,   584,   776,   1000,  1192,  1384,  1608,  1800,  2024,  2216,  2408,  2600,  2792,  2984,  3240,  3496,  3624,  3880,  4008,  4264,  4392,  4584,  4776,  4968,  5352,  5544,  5736,  5992,  5992,  6200,  6456,  6712,  6968,  6968,  7224,  7480,  7736,  7736,  7992,  8248,  8504,  8760,  8760,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11064, 11448, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 18336, 19080, 19080, 19080, 19080, 19848, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 21384, 22152, 22152, 22152},
   {208,   440,   680,   904,   1128,  1352,  1608,  1800,  2024,  2280,  2472,  2728,  2984,  3240,  3368,  3624,  3880,  4136,  4392,  4584,  4776,  4968,  5352,  5544,  5736,  5992,  6200,  6456,  6712,  6712,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  8760,  9144,  9528,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11064, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 23688, 23688, 24496, 24496, 24496, 24496, 25456},
   {224,   488,   744,   1000,  1256,  1544,  1800,  2024,  2280,  2536,  2856,  3112,  3368,  3624,  3880,  4136,  4392,  4584,  4968,  5160,  5352,  5736,  5992,  6200,  6456,  6712,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  9144,  9144,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11448, 11448, 11832, 12216, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 26416, 26416, 26416, 26416, 27376, 27376, 27376, 27376, 28336, 28336},
   {256,   552,   840,   1128,  1416,  1736,  1992,  2280,  2600,  2856,  3112,  3496,  3752,  4008,  4264,  4584,  4968,  5160,  5544,  5736,  5992,  6200,  6456,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  9144,  9528,  9912,  9912,  10296, 10680, 11064, 11064, 11448, 11832, 12216, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704},
   {280,   600,   904,   1224,  1544,  1800,  2152,  2472,  2728,  3112,  3368,  3624,  4008,  4264,  4584,  4968,  5160,  5544,  5736,  6200,  6456,  6712,  6968,  7224,  7736,  7992,  8248,  8504,  8760,  9144,  9528,  9912,  10296, 10296, 10680, 11064, 11448, 11832, 11832, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008},
   {328,   632,   968,   1288,  1608,  1928,  2280,  2600,  2984,  3240,  3624,  3880,  4264,  4584,  4968,  5160,  5544,  5992,  6200,  6456,  6712,  7224,  7480,  7736,  7992,  8504,  8760,  9144,  9528,  9912,  9912,  10296, 10680, 11064, 11448, 11832, 12216, 12216, 12576, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 34008, 35160, 35160, 35160, 35160},
   {336,   696,   1064,  1416,  1800,  2152,  2536,  2856,  3240,  3624,  4008,  4392,  4776,  5160,  5352,  5736,  6200,  6456,  6712,  7224,  7480,  7992,  8248,  8760,  9144,  9528,  9912,  10296, 10296, 10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 35160, 36696, 36696, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 39232, 39232},
   {376,   776,   1160,  1544,  1992,  2344,  2792,  3112,  3624,  4008,  4392,  4776,  5160,  5544,  5992,  6200,  6712,  7224,  7480,  7992,  8248,  8760,  9144,  9528,  9912,  10296, 10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 14112, 14112, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816},
   {408,   840,   1288,  1736,  2152,  2600,  2984,  3496,  3880,  4264,  4776,  5160,  5544,  5992,  6456,  6968,  7224,  7736,  8248,  8504,  9144,  9528,  9912,  10296, 10680, 11064, 11448, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 15264, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 18336, 19080, 19080, 19848, 20616, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888},
   {440,   904,   1384,  1864,  2344,  2792,  3240,  3752,  4136,  4584,  5160,  5544,  5992,  6456,  6968,  7480,  7992,  8248,  8760,  9144,  9912,  10296, 10680, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 14688, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 18336, 19080, 19848, 19848, 20616, 20616, 21384, 22152, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 48936, 51024, 51024, 51024},
   {488,   1000,  1480,  1992,  2472,  2984,  3496,  4008,  4584,  4968,  5544,  5992,  6456,  6968,  7480,  7992,  8504,  9144,  9528,  9912,  10680, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 15840, 16416, 16992, 17568, 18336, 18336, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 52752, 55056, 55056, 55056},
   {520,   1064,  1608,  2152,  2664,  3240,  3752,  4264,  4776,  5352,  5992,  6456,  6968,  7480,  7992,  8504,  9144,  9528,  10296, 10680, 11448, 11832, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 19080, 19080, 19848, 20616, 21384, 21384, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256},
   {552,   1128,  1736,  2280,  2856,  3496,  4008,  4584,  5160,  5736,  6200,  6968,  7480,  7992,  8504,  9144,  9912,  10296, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22152, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776},
   {584,   1192,  1800,  2408,  2984,  3624,  4264,  4968,  5544,  5992,  6712,  7224,  7992,  8504,  9144,  9912,  10296, 11064, 11448, 12216, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22920, 22920, 23688, 24496, 25456, 25456, 26416, 26416, 27376, 28336, 28336, 29296, 29296, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 66592},
   {616,   1256,  1864,  2536,  3112,  3752,  4392,  5160,  5736,  6200,  6968,  7480,  8248,  8760,  9528,  10296, 10680, 11448, 12216, 12576, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 20616, 20616, 21384, 22152, 22920, 23688, 24496, 24496, 25456, 26416, 26416, 27376, 28336, 28336, 29296, 29296, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 66592, 68808, 68808, 68808, 71112},
   {712,   1480,  2216,  2984,  3752,  4392,  5160,  5992,  6712,  7480,  8248,  8760,  9528,  10296, 11064, 11832, 12576, 13536, 14112, 14688, 15264, 16416, 16992, 17568, 18336, 19080, 19848, 20616, 21384, 22152, 22920, 23688, 24496, 25456, 25456, 26416, 27376, 28336, 29296, 29296, 30576, 30576, 31704, 32856, 32856, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376}
};
#ifdef LTEMAC_MIMO
PRIVATE RgAcTbSzTbl2Lyr tbsTbl2Lyr = {
 {
   {16,    32,    56,    88,    120,   152,   176,   208,   224,   256,   288,   328,   344,   376,   392,   424,   456,   488,   504,   536,   568,   600,   616,   648,   680,   712,   744,   776,   776,   808,   840,   872,   904,   936,   968,   1000,  1032,  1032,  1064,  1096,  1128,  1160,  1192,  1224,  1256,  1256,  1288,  1320,  1352,  1384,  1416,  1416,  1480,  1480,  1544,  1544,  1608,  1608,  1608,  1672,  1672,  1736,  1736,  1800,  1800,  1800,  1864,  1864,  1928,  1928,  1992,  1992,  2024,  2088,  2088,  2088,  2152,  2152,  2216,  2216,  2280,  2280,  2280,  2344,  2344,  2408,  2408,  2472,  2472,  2536,  2536,  2536,  2600,  2600,  2664,  2664,  2728,  2728,  2728,  2792,  2792,  2856,  2856,  2856,  2984,  2984,  2984,  2984,  2984,  3112},
   {24,    56,    88,    144,   176,   208,   224,   256,   328,   344,   376,   424,   456,   488,   520,   568,   600,   632,   680,   712,   744,   776,   808,   872,   904,   936,   968,   1000,  1032,  1064,  1128,  1160,  1192,  1224,  1256,  1288,  1352,  1384,  1416,  1416,  1480,  1544,  1544,  1608,  1608,  1672,  1736,  1736,  1800,  1800,  1864,  1864,  1928,  1992,  1992,  2024,  2088,  2088,  2152,  2152,  2216,  2280,  2280,  2344,  2344,  2408,  2472,  2472,  2536,  2536,  2600,  2600,  2664,  2728,  2728,  2792,  2792,  2856,  2856,  2856,  2984,  2984,  2984,  3112,  3112,  3112,  3240,  3240,  3240,  3240,  3368,  3368,  3368,  3496,  3496,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3752,  3752,  3880,  3880,  3880,  4008,  4008,  4008},
   {32,    72,    144,   176,   208,   256,   296,   328,   376,   424,   472,   520,   568,   616,   648,   696,   744,   776,   840,   872,   936,   968,   1000,  1064,  1096,  1160,  1192,  1256,  1288,  1320,  1384,  1416,  1480,  1544,  1544,  1608,  1672,  1672,  1736,  1800,  1800,  1864,  1928,  1992,  2024,  2088,  2088,  2152,  2216,  2216,  2280,  2344,  2344,  2408,  2472,  2536,  2536,  2600,  2664,  2664,  2728,  2792,  2856,  2856,  2856,  2984,  2984,  3112,  3112,  3112,  3240,  3240,  3240,  3368,  3368,  3368,  3496,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3880,  3880,  3880,  4008,  4008,  4008,  4136,  4136,  4136,  4264,  4264,  4264,  4392,  4392,  4392,  4584,  4584,  4584,  4584,  4584,  4776,  4776,  4776,  4776,  4968,  4968},
   {40,    104,   176,   208,   256,   328,   392,   440,   504,   568,   616,   680,   744,   808,   872,   904,   968,   1032,  1096,  1160,  1224,  1256,  1320,  1384,  1416,  1480,  1544,  1608,  1672,  1736,  1800,  1864,  1928,  1992,  2024,  2088,  2152,  2216,  2280,  2344,  2408,  2472,  2536,  2536,  2600,  2664,  2728,  2792,  2856,  2856,  2984,  2984,  3112,  3112,  3240,  3240,  3368,  3368,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3880,  3880,  4008,  4008,  4136,  4136,  4264,  4264,  4392,  4392,  4392,  4584,  4584,  4584,  4776,  4776,  4776,  4776,  4968,  4968,  4968,  5160,  5160,  5160,  5352,  5352,  5352,  5352,  5544,  5544,  5544,  5736,  5736,  5736,  5736,  5992,  5992,  5992,  5992,  6200,  6200,  6200,  6200,  6456,  6456},
   {56,    120,   208,   256,   328,   408,   488,   552,   632,   696,   776,   840,   904,   1000,  1064,  1128,  1192,  1288,  1352,  1416,  1480,  1544,  1608,  1736,  1800,  1864,  1928,  1992,  2088,  2152,  2216,  2280,  2344,  2408,  2472,  2600,  2664,  2728,  2792,  2856,  2984,  2984,  3112,  3112,  3240,  3240,  3368,  3496,  3496,  3624,  3624,  3752,  3752,  3880,  4008,  4008,  4136,  4136,  4264,  4264,  4392,  4392,  4584,  4584,  4584,  4776,  4776,  4968,  4968,  4968,  5160,  5160,  5160,  5352,  5352,  5544,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7480,  7480,  7736,  7736,  7736,  7992},
   {72,    144,   224,   328,   424,   504,   600,   680,   776,   872,   968,   1032,  1128,  1224,  1320,  1384,  1480,  1544,  1672,  1736,  1864,  1928,  2024,  2088,  2216,  2280,  2344,  2472,  2536,  2664,  2728,  2792,  2856,  2984,  3112,  3112,  3240,  3368,  3496,  3496,  3624,  3752,  3752,  3880,  4008,  4008,  4136,  4264,  4392,  4392,  4584,  4584,  4776,  4776,  4776,  4968,  4968,  5160,  5160,  5352,  5352,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  7992,  8248,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  8760,  9144,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9528},
   {88,    176,   256,   392,   504,   600,   712,   808,   936,   1032,  1128,  1224,  1352,  1480,  1544,  1672,  1736,  1864,  1992,  2088,  2216,  2280,  2408,  2472,  2600,  2728,  2792,  2984,  2984,  3112,  3240,  3368,  3496,  3496,  3624,  3752,  3880,  4008,  4136,  4136,  4264,  4392,  4584,  4584,  4776,  4776,  4968,  4968,  5160,  5160,  5352,  5352,  5544,  5736,  5736,  5992,  5992,  5992,  6200,  6200,  6456,  6456,  6456,  6712,  6712,  6968,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  8248,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10296, 10680, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448},
   {104,   224,   328,   472,   584,   712,   840,   968,   1096,  1224,  1320,  1480,  1608,  1672,  1800,  1928,  2088,  2216,  2344,  2472,  2536,  2664,  2792,  2984,  3112,  3240,  3368,  3368,  3496,  3624,  3752,  3880,  4008,  4136,  4264,  4392,  4584,  4584,  4776,  4968,  4968,  5160,  5352,  5352,  5544,  5736,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7992,  7992,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11448, 11832, 11832, 11832, 12216, 12216, 12216, 12576, 12576, 12576, 12960, 12960, 12960, 12960, 13536, 13536},
   {120,   256,   392,   536,   680,   808,   968,   1096,  1256,  1384,  1544,  1672,  1800,  1928,  2088,  2216,  2344,  2536,  2664,  2792,  2984,  3112,  3240,  3368,  3496,  3624,  3752,  3880,  4008,  4264,  4392,  4584,  4584,  4776,  4968,  4968,  5160,  5352,  5544,  5544,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7736,  7992,  7992,  8248,  8504,  8504,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11832, 11832, 12216, 12216, 12216, 12576, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 13536, 14112, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15264},
   {136,   296,   456,   616,   776,   936,   1096,  1256,  1416,  1544,  1736,  1864,  2024,  2216,  2344,  2536,  2664,  2856,  2984,  3112,  3368,  3496,  3624,  3752,  4008,  4136,  4264,  4392,  4584,  4776,  4968,  5160,  5160,  5352,  5544,  5736,  5736,  5992,  6200,  6200,  6456,  6712,  6712,  6968,  6968,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8248,  8504,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11832, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 13536, 14112, 14112, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16416, 16992, 16992, 16992, 16992, 17568},
   {144,   328,   504,   680,   872,   1032,  1224,  1384,  1544,  1736,  1928,  2088,  2280,  2472,  2664,  2792,  2984,  3112,  3368,  3496,  3752,  3880,  4008,  4264,  4392,  4584,  4776,  4968,  5160,  5352,  5544,  5736,  5736,  5992,  6200,  6200,  6456,  6712,  6712,  6968,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8504,  8504,  8760,  9144,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10296, 10680, 10680, 11064, 11064, 11448, 11448, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 18336, 18336, 19080, 19080, 19080, 19080},
   {176,   376,   584,   776,   1000,  1192,  1384,  1608,  1800,  2024,  2216,  2408,  2600,  2792,  2984,  3240,  3496,  3624,  3880,  4008,  4264,  4392,  4584,  4776,  4968,  5352,  5544,  5736,  5992,  5992,  6200,  6456,  6712,  6968,  6968,  7224,  7480,  7736,  7736,  7992,  8248,  8504,  8760,  8760,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11064, 11448, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 18336, 19080, 19080, 19080, 19080, 19848, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 21384, 22152, 22152, 22152},
   {208,   440,   680,   904,   1128,  1352,  1608,  1800,  2024,  2280,  2472,  2728,  2984,  3240,  3368,  3624,  3880,  4136,  4392,  4584,  4776,  4968,  5352,  5544,  5736,  5992,  6200,  6456,  6712,  6712,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  8760,  9144,  9528,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11064, 11448, 11832, 11832, 12216, 12216, 12576, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 23688, 23688, 24496, 24496, 24496, 24496, 25456},
   {224,   488,   744,   1000,  1256,  1544,  1800,  2024,  2280,  2536,  2856,  3112,  3368,  3624,  3880,  4136,  4392,  4584,  4968,  5160,  5352,  5736,  5992,  6200,  6456,  6712,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  9144,  9144,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11448, 11448, 11832, 12216, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 26416, 26416, 26416, 26416, 27376, 27376, 27376, 27376, 28336, 28336},
   {256,   552,   840,   1128,  1416,  1736,  1992,  2280,  2600,  2856,  3112,  3496,  3752,  4008,  4264,  4584,  4968,  5160,  5544,  5736,  5992,  6200,  6456,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  9144,  9528,  9912,  9912,  10296, 10680, 11064, 11064, 11448, 11832, 12216, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704},
   {280,   600,   904,   1224,  1544,  1800,  2152,  2472,  2728,  3112,  3368,  3624,  4008,  4264,  4584,  4968,  5160,  5544,  5736,  6200,  6456,  6712,  6968,  7224,  7736,  7992,  8248,  8504,  8760,  9144,  9528,  9912,  10296, 10296, 10680, 11064, 11448, 11832, 11832, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008},
   {328,   632,   968,   1288,  1608,  1928,  2280,  2600,  2984,  3240,  3624,  3880,  4264,  4584,  4968,  5160,  5544,  5992,  6200,  6456,  6712,  7224,  7480,  7736,  7992,  8504,  8760,  9144,  9528,  9912,  9912,  10296, 10680, 11064, 11448, 11832, 12216, 12216, 12576, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 21384, 21384, 22152, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 34008, 35160, 35160, 35160, 35160},
   {336,   696,   1064,  1416,  1800,  2152,  2536,  2856,  3240,  3624,  4008,  4392,  4776,  5160,  5352,  5736,  6200,  6456,  6712,  7224,  7480,  7992,  8248,  8760,  9144,  9528,  9912,  10296, 10296, 10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 26416, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 35160, 36696, 36696, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 39232, 39232},
   {376,   776,   1160,  1544,  1992,  2344,  2792,  3112,  3624,  4008,  4392,  4776,  5160,  5544,  5992,  6200,  6712,  7224,  7480,  7992,  8248,  8760,  9144,  9528,  9912,  10296, 10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 14112, 14112, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816},
   {408,   840,   1288,  1736,  2152,  2600,  2984,  3496,  3880,  4264,  4776,  5160,  5544,  5992,  6456,  6968,  7224,  7736,  8248,  8504,  9144,  9528,  9912,  10296, 10680, 11064, 11448, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 15264, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 18336, 19080, 19080, 19848, 20616, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888},
   {440,   904,   1384,  1864,  2344,  2792,  3240,  3752,  4136,  4584,  5160,  5544,  5992,  6456,  6968,  7480,  7992,  8248,  8760,  9144,  9912,  10296, 10680, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 14688, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 18336, 19080, 19848, 19848, 20616, 20616, 21384, 22152, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 48936, 51024, 51024, 51024},
   {488,   1000,  1480,  1992,  2472,  2984,  3496,  4008,  4584,  4968,  5544,  5992,  6456,  6968,  7480,  7992,  8504,  9144,  9528,  9912,  10680, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 15840, 16416, 16992, 17568, 18336, 18336, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 52752, 55056, 55056, 55056},
   {520,   1064,  1608,  2152,  2664,  3240,  3752,  4264,  4776,  5352,  5992,  6456,  6968,  7480,  7992,  8504,  9144,  9528,  10296, 10680, 11448, 11832, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 16992, 17568, 18336, 19080, 19080, 19848, 20616, 21384, 21384, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256},
   {552,   1128,  1736,  2280,  2856,  3496,  4008,  4584,  5160,  5736,  6200,  6968,  7480,  7992,  8504,  9144,  9912,  10296, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22152, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776},
   {584,   1192,  1800,  2408,  2984,  3624,  4264,  4968,  5544,  5992,  6712,  7224,  7992,  8504,  9144,  9912,  10296, 11064, 11448, 12216, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22920, 22920, 23688, 24496, 25456, 25456, 26416, 26416, 27376, 28336, 28336, 29296, 29296, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 66592},
   {616,   1256,  1864,  2536,  3112,  3752,  4392,  5160,  5736,  6200,  6968,  7480,  8248,  8760,  9528,  10296, 10680, 11448, 12216, 12576, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 20616, 20616, 21384, 22152, 22920, 23688, 24496, 24496, 25456, 26416, 26416, 27376, 28336, 28336, 29296, 29296, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 66592, 68808, 68808, 68808, 71112},
   {712,   1480,  2216,  2984,  3752,  4392,  5160,  5992,  6712,  7480,  8248,  8760,  9528,  10296, 11064, 11832, 12576, 13536, 14112, 14688, 15264, 16416, 16992, 17568, 18336, 19080, 19848, 20616, 21384, 22152, 22920, 23688, 24496, 25456, 25456, 26416, 27376, 28336, 29296, 29296, 30576, 30576, 31704, 32856, 32856, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376, 75376}
 },
 {
   {32,    88,    152,   208,   256,   328,   376,   424,   488,   536,   600,   648,   712,   776,   808,   872,   936,   1000,  1032,  1096,  1160,  1224,  1256,  1320,  1384,  1416,  1480,  1544,  1608,  1672,  1736,  1800,  1800,  1864,  1928,  1992,  2088,  2088,  2152,  2216,  2280,  2344,  2408,  2472,  2536,  2536,  2600,  2664,  2728,  2792,  2856,  2856,  2984,  2984,  3112,  3112,  3240,  3240,  3240,  3368,  3368,  3496,  3496,  3624,  3624,  3624,  3752,  3752,  3880,  3880,  4008,  4008,  4008,  4136,  4136,  4136,  4264,  4264,  4392,  4392,  4584,  4584,  4584,  4776,  4776,  4776,  4776,  4968,  4968,  5160,  5160,  5160,  5160,  5160,  5352,  5352,  5544,  5544,  5544,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  5992,  5992,  6200},
   {56,    144,   208,   256,   344,   424,   488,   568,   632,   712,   776,   872,   936,   1000,  1064,  1160,  1224,  1288,  1384,  1416,  1544,  1608,  1672,  1736,  1800,  1864,  1992,  2024,  2088,  2152,  2280,  2344,  2408,  2472,  2536,  2600,  2728,  2792,  2856,  2856,  2984,  3112,  3112,  3240,  3240,  3368,  3496,  3496,  3624,  3624,  3752,  3752,  3880,  4008,  4008,  4008,  4136,  4136,  4264,  4264,  4392,  4584,  4584,  4776,  4776,  4776,  4968,  4968,  5160,  5160,  5160,  5160,  5352,  5544,  5544,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  7992},
   {72,    176,   256,   328,   424,   520,   616,   696,   776,   872,   968,   1064,  1160,  1256,  1320,  1416,  1544,  1608,  1672,  1800,  1864,  1992,  2088,  2152,  2216,  2344,  2408,  2536,  2600,  2664,  2792,  2856,  2984,  3112,  3112,  3240,  3368,  3368,  3496,  3624,  3624,  3752,  3880,  4008,  4008,  4136,  4264,  4264,  4392,  4584,  4584,  4584,  4776,  4776,  4968,  5160,  5160,  5160,  5352,  5352,  5544,  5544,  5736,  5736,  5736,  5992,  5992,  6200,  6200,  6200,  6456,  6456,  6456,  6712,  6712,  6712,  6968,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7736,  7736,  7736,  7992,  7992,  7992,  8248,  8248,  8248,  8504,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9912,  9912},
   {104,   208,   328,   440,   568,   680,   808,   904,   1032,  1160,  1256,  1384,  1480,  1608,  1736,  1864,  1992,  2088,  2216,  2344,  2472,  2536,  2664,  2792,  2856,  2984,  3112,  3240,  3368,  3496,  3624,  3752,  3880,  4008,  4136,  4264,  4392,  4392,  4584,  4776,  4776,  4968,  4968,  5160,  5352,  5352,  5544,  5544,  5736,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6712,  6968,  6968,  7224,  7224,  7224,  7480,  7480,  7736,  7736,  7992,  7992,  8248,  8248,  8504,  8504,  8760,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11448, 11832, 11832, 11832, 11832, 12576, 12576, 12576, 12576, 12960, 12960},
   {120,   256,   408,   552,   696,   840,   1000,  1128,  1288,  1416,  1544,  1736,  1864,  1992,  2152,  2280,  2408,  2600,  2728,  2856,  2984,  3112,  3240,  3496,  3624,  3752,  3880,  4008,  4136,  4264,  4392,  4584,  4776,  4968,  4968,  5160,  5352,  5544,  5544,  5736,  5992,  5992,  6200,  6200,  6456,  6456,  6712,  6968,  6968,  7224,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8248,  8504,  8504,  8760,  8760,  9144,  9144,  9144,  9528,  9528,  9912,  9912,  9912,  10296, 10296, 10296, 10680, 10680, 11064, 11064, 11064, 11448, 11448, 11448, 11832, 11832, 11832, 11832, 12576, 12576, 12576, 12960, 12960, 12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15840},
   {144,   328,   504,   680,   872,   1032,  1224,  1384,  1544,  1736,  1928,  2088,  2280,  2472,  2664,  2792,  2984,  3112,  3368,  3496,  3752,  3880,  4008,  4264,  4392,  4584,  4776,  4968,  5160,  5352,  5544,  5736,  5736,  5992,  6200,  6200,  6456,  6712,  6968,  6968,  7224,  7480,  7480,  7736,  7992,  7992,  8248,  8504,  8760,  8760,  9144,  9144,  9528,  9528,  9528,  9912,  9912,  10296, 10296, 10680, 10680, 11064, 11064, 11448, 11448, 11448, 11832, 11832,  11832,  12576,  12576,  12576,  12960, 12960, 13536, 13536, 13536, 14112, 14112, 14112, 14688, 14688, 14688, 14688, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 15840, 16416, 16416, 16416, 16992,  16992,  17568,  17568,  17568,  17568,  18336,  18336,  18336,  18336,  19080,  19080,  19080,  19080,  19080},
   {176,   392,   600,   808,   1032,  1224,  1480,  1672,  1864,  2088,  2280,  2472,  2728,  2984,  3112,  3368,  3496,  3752,  4008,  4136,  4392,  4584,  4776,  4968,  5160,  5352,  5736,  5992,  5992,  6200,  6456,  6712,  6968,  6968,  7224,  7480,  7736,  7992,  8248,  8248,  8504,  8760,  9144,  9144,  9528,  9528,  9912,  9912,  10296, 10296, 10680, 10680, 11064, 11448, 11448, 11832, 11832, 11832, 12576, 12576, 12960, 12960, 12960, 13536, 13536, 14112, 14112, 14112,  14688,  14688,  14688,  14688,  15264, 15264, 15264, 15840, 15840, 16416, 16416, 16416, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 18336, 19080, 19080, 19080, 19080, 19848, 19848, 19848,  20616, 20616, 20616, 20616, 21384, 21384, 21384, 21384, 24264, 24264, 24264, 22920, 22920, 22920},
   {224,   472,   712,   968,   1224,  1480,  1672,  1928,  2216,  2472,  2664,  2984,  3240,  3368,  3624,  3880,  4136,  4392,  4584,  4968,  5160,  5352,  5736,  5992,  6200,  6456,  6712,  6712,  6968,  7224,  7480,  7736,  7992,  8248,  8504,  8760,  9144,  9144,  9528,  9912,  9912,  10296, 10680, 10680, 11064, 11448, 11448, 11832, 11832, 12216, 12576, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 14688, 14688, 15264, 15264, 15840, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 21384, 24264, 24264, 24264, 22920, 22920, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 25456, 25456, 25456, 27376, 27376},
   {256,   536,   808,   1096,  1384,  1672,  1928,  2216,  2536,  2792,  3112,  3368,  3624,  3880,  4264,  4584,  4776,  4968,  5352,  5544,  5992,  6200,  6456,  6712,  6968,  7224,  7480,  7736,  7992,  8504,  8760,  9144,  9144,  9528,  9912,  9912,  10296, 10680, 11064, 11064, 11448, 11832, 12216, 12216, 12576, 12960, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15264, 15264, 15840, 15840, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19080, 19848, 19848, 19848, 20616, 20616, 21384, 21384, 21384, 24264, 24264, 24264, 22920, 22920, 22920, 23688, 23688, 24496, 24496, 24496, 25456, 25456, 25456, 25456, 25456, 25456, 27376, 27376, 27376, 27376, 28336, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 30576},
   {296,   616,   936,   1256,  1544,  1864,  2216,  2536,  2856,  3112,  3496,  3752,  4136,  4392,  4776,  5160,  5352,  5736,  5992,  6200,  6712,  6968,  7224,  7480,  7992,  8248,  8504,  8760,  9144,  9528,  9912,  10296, 10296, 10680, 11064, 11448, 11832, 11832, 12216, 12576, 12960, 13536, 13536, 14112, 14112, 14688, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 16992, 17568, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 20616, 21384, 21384, 24264, 24264, 24264, 22920, 22920, 23688, 23688, 23688, 24496, 24496, 25456, 25456, 25456, 25456, 25456, 27376, 27376, 27376, 27376, 28336, 28336, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 32856, 34008, 34008, 34008, 34008, 35160},
   {328,   680,   1032,  1384,  1736,  2088,  2472,  2792,  3112,  3496,  3880,  4264,  4584,  4968,  5352,  5736,  5992,  6200,  6712,  6968,  7480,  7736,  7992,  8504,  8760,  9144,  9528,  9912,  10296, 10680, 11064, 11448, 11448, 11832, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15264, 15840, 16416, 16416, 16992, 16992, 17568, 18336, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 20616, 21384, 21384, 24264, 24264, 22920, 22920, 22920, 23688, 23688, 24496, 24496, 25456, 25456, 25456, 25456, 25456, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 36696, 36696, 37888, 37888, 37888, 37888},
   {376,   776,   1192,  1608,  2024,  2408,  2792,  3240,  3624,  4008,  4392,  4776,  5352,  5736,  5992,  6456,  6968,  7224,  7736,  7992,  8504,  8760,  9144,  9528,  9912,  10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 13536, 14112, 14688, 14688, 15264, 15840, 16416, 16416, 16992, 17568, 17568, 18336, 18336, 19080, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22152, 22920, 22920, 23688, 23688, 24496, 24496, 25456, 25456, 25456, 25456, 27376, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 29296, 30576, 30576, 31704, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 36696, 37888, 37888, 37888, 37888, 39232, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816, 43816},
   {440,   904,   1352,  1800,  2280,  2728,  3240,  3624,  4136,  4584,  4968,  5544,  5992,  6456,  6712,  7224,  7736,  8248,  8760,  9144,  9528,  9912,  10680, 11064, 11448, 11832, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15264, 15840, 16416, 16992, 17568, 17568, 18336, 19080, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22152, 22920, 23688, 23688, 24496, 24496, 25456, 25456, 25456, 25456, 27376, 27376, 28336, 28336, 28336, 29296, 29296, 30576, 30576, 30576, 31704, 31704, 32856, 32856, 32856, 34008, 34008, 35160, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 46888, 48936, 48936, 48936, 48936, 51024},
   {488,   1000,  1544,  2024,  2536,  3112,  3624,  4136,  4584,  5160,  5736,  6200,  6712,  7224,  7736,  8248,  8760,  9144,  9912,  10296, 10680, 11448, 11832, 12216, 12960, 13536, 14112, 14688, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 18336, 19080, 19848, 19848, 20616, 21384, 21384, 22152, 22920, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 26416, 27376, 27376, 28336, 29296, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 52752, 55056, 55056, 55056, 55056, 57336, 57336},
   {552,   1128,  1736,  2280,  2856,  3496,  4008,  4584,  5160,  5736,  6200,  6968,  7480,  7992,  8504,  9144,  9912,  10296, 11064, 11448, 12216, 12576, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22152, 22920, 23688, 24496, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 57336, 57336, 59256, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776},
   {600,   1224,  1800,  2472,  3112,  3624,  4264,  4968,  5544,  6200,  6712,  7224,  7992,  8504,  9144,  9912,  10296, 11064, 11832, 12216, 12960, 13536, 14112, 14688, 15264, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 20616, 20616, 21384, 22152, 22920, 23688, 23688, 24496, 25456, 25456, 26416, 27376, 27376, 28336, 29296, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 46888, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808},
   {632,   1288,  1928,  2600,  3240,  3880,  4584,  5160,  5992,  6456,  7224,  7736,  8504,  9144,  9912,  10296, 11064, 11832, 12216, 12960, 13536, 14112, 14688, 15840, 16416, 16992, 17568, 18336, 19080, 19848, 19848, 20616, 21384, 22152, 22920, 23688, 24496, 24496, 25456, 26416, 26416, 27376, 28336, 28336, 29296, 30576, 30576, 31704, 31704, 32856, 32856, 34008, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 39232, 39232, 40576, 40576, 42368, 42368, 43816, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 68808, 71112, 71112, 71112, 71112},
   {696,   1416,  2152,  2856,  3624,  4392,  5160,  5736,  6456,  7224,  7992,  8760,  9528,  10296, 10680, 11448, 12216, 12960, 13536, 14688, 15264, 15840, 16416, 17568, 18336, 19080, 19848, 20616, 20616, 21384, 22152, 22920, 23688, 24496, 25456, 26416, 26416, 27376, 28336, 29296, 29296, 30576, 30576, 31704, 32856, 32856, 34008, 35160, 35160, 36696, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 40576, 42368, 42368, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 52752, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 71112, 73712, 73712, 73712, 73712, 76208, 76208, 76208, 78704, 78704, 78704, 78704},
   {776,   1544,  2344,  3112,  4008,  4776,  5544,  6200,  7224,  7992,  8760,  9528,  10296, 11064, 11832, 12576, 13536, 14112, 15264, 15840, 16416, 17568, 18336, 19080, 19848, 20616, 21384, 22152, 22920, 23688, 24496, 25456, 26416, 27376, 27376, 28336, 29296, 30576, 30576, 31704, 32856, 32856, 34008, 35160, 35160, 36696, 37888, 37888, 39232, 39232, 40576, 40576, 42368, 42368, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 48936, 51024, 51024, 52752, 52752, 55056, 55056, 55056, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 76208, 76208, 78704, 78704, 78704, 81176, 81176, 81176, 81176, 84760, 84760, 84760, 84760, 87936, 87936},
   {840,   1736,  2600,  3496,  4264,  5160,  5992,  6968,  7736,  8504,  9528,  10296, 11064, 12216, 12960, 13536, 14688, 15264, 16416, 16992, 18336, 19080, 19848, 20616, 21384, 22152, 22920, 24496, 25456, 25456, 26416, 27376, 28336, 29296, 30576, 30576, 31704, 32856, 34008, 34008, 35160, 36696, 36696, 37888, 39232, 39232, 40576, 40576, 42368, 43816, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 51024, 51024, 51024, 52752, 52752, 55056, 55056, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 61664, 63776, 63776, 66592, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 76208, 78704, 78704, 78704, 81176, 81176, 81176, 81176, 84760, 84760, 84760, 87936, 87936, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 93800},
   {904,   1864,  2792,  3752,  4584,  5544,  6456,  7480,  8248,  9144,  10296, 11064, 12216, 12960, 14112, 14688, 15840, 16992, 17568, 18336, 19848, 20616, 21384, 22152, 22920, 24496, 25456, 26416, 27376, 28336, 29296, 29296, 30576, 31704, 32856, 34008, 34008, 35160, 36696, 36696, 37888, 39232, 40576, 40576, 42368, 42368, 43816, 45352, 45352, 46888, 46888, 48936, 48936, 51024, 51024, 52752, 52752, 55056, 55056, 57336, 57336, 59256, 59256, 59256, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 78704, 78704, 78704, 81176, 81176, 81176, 84760, 84760, 84760, 84760, 87936, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 93800, 97896, 97896, 97896, 97896, 97896, 101840, 101840, 101840},
   {1000,  1992,  2984,  4008,  4968,  5992,  6968,  7992,  9144,  9912,  11064, 12216, 12960, 14112, 15264, 15840, 16992, 18336, 19080, 19848, 21384, 22152, 22920, 24496, 25456, 26416, 27376, 28336, 29296, 30576, 31704, 31704, 32856, 34008, 35160, 36696, 36696, 37888, 39232, 40576, 40576, 42368, 43816, 43816, 45352, 46888, 46888, 48936, 48936, 51024, 51024, 52752, 52752, 55056, 55056, 57336, 57336, 59256, 59256, 61664, 61664, 63776, 63776, 63776, 66592, 66592, 68808, 68808, 71112, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 78704, 78704, 78704, 81176, 81176, 81176, 84760, 84760, 84760, 87936, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 93800, 97896, 97896, 97896, 97896, 101840, 101840, 101840, 101840, 105528, 105528, 105528, 105528, 110136, 110136, 110136},
   {1064,  2152,  3240,  4264,  5352,  6456,  7480,  8504,  9528,  10680, 11832, 12960, 14112, 15264, 16416, 16992, 18336, 19080, 20616, 21384, 22920, 23688, 24496, 25456, 27376, 28336, 29296, 30576, 31704, 32856, 34008, 34008, 35160, 36696, 37888, 39232, 40576, 40576, 42368, 43816, 43816, 45352, 46888, 46888, 48936, 48936, 51024, 51024, 52752, 55056, 55056, 57336, 57336, 59256, 59256, 61664, 61664, 63776, 63776, 66592, 66592, 68808, 68808, 68808, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 78704, 78704, 81176, 81176, 81176, 84760, 84760, 84760, 87936, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 97896, 97896, 97896, 97896, 101840, 101840, 101840, 101840, 105528, 105528, 105528, 110136, 110136, 110136, 110136, 115040, 115040, 115040, 115040, 119816, 119816, 119816},
   {1128,  2280,  3496,  4584,  5736,  6968,  7992,  9144,  10296, 11448, 12576, 13536, 14688, 15840, 16992, 18336, 19848, 20616, 22152, 22920, 24496, 25456, 26416, 27376, 28336, 29296, 30576, 31704, 32856, 34008, 35160, 36696, 37888, 39232, 40576, 40576, 42368, 43816, 45352, 45352, 46888, 48936, 48936, 51024, 51024, 52752, 55056, 55056, 57336, 57336, 59256, 59256, 61664, 61664, 63776, 63776, 66592, 66592, 68808, 68808, 71112, 71112, 73712, 73712, 76208, 76208, 76208, 78704, 78704, 81176, 81176, 81176, 84760, 84760, 87936, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 97896, 97896, 97896, 101840,101840,101840,101840,105528, 105528, 105528, 110136, 110136, 110136, 110136, 115040, 115040, 115040, 115040, 119816, 119816, 119816, 119816, 124464, 124464, 124464, 124464, 128496},
   {1192,  2408,  3624,  4968,  5992,  7224,  8504,  9912,  11064, 12216, 13536, 14688, 15840, 16992, 18336, 19848, 20616, 22152, 22920, 24496, 25456, 26416, 28336, 29296, 30576, 31704, 32856, 34008, 35160, 36696, 37888, 39232, 40576, 42368, 42368, 43816, 45352, 46888, 46888, 48936, 51024, 51024, 52752, 52752, 55056, 57336, 57336, 59256, 59256, 61664, 61664, 63776, 63776, 66592, 66592, 68808, 71112, 71112, 73712, 73712, 73712, 76208, 76208, 78704, 78704, 81176, 81176, 84760, 84760, 84760, 87936, 87936, 90816, 90816, 90816, 93800, 93800, 93800, 97896, 97896, 97896, 101840, 101840, 101840, 105528, 105528, 105528, 105528, 110136, 110136, 110136, 115040, 115040, 115040, 115040, 119816, 119816, 119816, 124464, 124464, 124464, 124464, 128496, 128496, 128496, 128496, 133208, 133208, 133208, 133208},
   {1256,  2536,  3752,  5160,  6200,  7480,  8760,  10296, 11448, 12576, 14112, 15264, 16416, 17568, 19080, 20616, 21384, 22920, 24496, 25456, 26416, 28336, 29296, 30576, 31704, 32856, 34008, 35160, 36696, 37888, 39232, 40576, 42368, 43816, 43816, 45352, 46888, 48936, 48936, 51024, 52752, 52752, 55056, 55056, 57336, 59256, 59256, 61664, 61664, 63776, 63776, 66592, 66592, 68808, 71112, 71112, 73712, 73712, 76208, 76208, 78704, 78704, 81176, 81176, 81176, 84760, 84760, 87936, 87936, 87936, 90816, 90816, 93800, 93800, 93800, 97896, 97896, 97896, 101840, 101840, 101840, 105528, 105528, 105528, 110136, 110136, 110136, 110136, 115040,115040, 115040, 119816, 119816, 119816, 124464, 124464, 124464, 124464, 128496, 128496, 128496, 128496, 133208, 133208, 133208, 133208, 137792, 137792, 137792, 142248},
   {1480,  2984,  4392,  5992,  7480,  8760,  10296, 11832, 13536, 14688, 16416, 17568, 19080, 20616, 22152, 23688, 25456, 26416, 28336, 29296, 30576, 32856, 34008, 35160, 36696, 37888, 40576, 40576, 42368, 43816, 45352, 46888, 48936, 51024, 52752, 52752, 55056, 55056, 57336, 59256, 59256, 61664, 63776, 63776, 66592, 68808, 68808, 71112, 73712, 75376, 75376, 75376, 75376, 75376, 75376, 81176, 84760, 84760, 87936, 87936, 90816, 90816, 93800, 93800, 97896, 97896, 97896, 101840, 101840, 105528, 105528, 105528, 110136, 110136, 110136, 110136, 115040, 115040, 115040, 119816, 119816, 119816, 124464, 124464, 124464, 128496, 128496, 128496, 133208, 133208, 133208, 137792, 137792, 137792, 142248, 142248, 142248, 146856, 146856,149776, 149776, 149776, 149776, 149776, 149776, 149776, 149776, 149776, 149776, 149776}
 }
};
#endif

PRIVATE RgAcUlIMcsTbl dlModTbsInxTbl = {
   {2, 0}, 
   {2, 1}, 
   {2, 2}, 
   {2, 3}, 
   {2, 4}, 
   {2, 5},
   {2, 6}, 
   {2, 7}, 
   {2, 8}, 
   {2, 9}, 
   {4, 9},
   {4, 10}, 
   {4, 11}, 
   {4, 12}, 
   {4, 13}, 
   {4, 14},
   {4, 15}, 
   {6, 15}, 
   {4, 16}, 
   {4, 17}, 
   {4, 18},
   {6, 19}, 
   {6, 20}, 
   {6, 21}, 
   {6, 22}, 
   {6, 23},
   {6, 24}, 
   {6, 25}, 
   {6, 26}
};


PRIVATE RgAcUlIMcsTbl modTbsInxTbl = {
   {2, 0}, 
   {2, 1}, 
   {2, 2}, 
   {2, 3}, 
   {2, 4}, 
   {2, 5},
   {2, 6}, 
   {2, 7}, 
   {2, 8}, 
   {2, 9}, 
   {2, 10},
   {4, 10}, 
   {4, 11}, 
   {4, 12}, 
   {4, 13}, 
   {4, 14},
   {4, 15}, 
   {4, 16}, 
   {4, 17}, 
   {4, 18}, 
   {4, 19},
   {6, 19}, 
   {6, 20}, 
   {6, 21}, 
   {6, 22}, 
   {6, 23},
   {6, 24}, 
   {6, 25}, 
   {6, 26}
};

#ifdef LTE_TDD

#define RGAC_TDD_DL_SUBFRAME  1
#define RGAC_TDD_UL_SUBFRAME  2
#define RGAC_TDD_SPL_SUBFRAME 3

U8  rgAcTddUlDlSf[7][10] = {
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,   RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME, RGAC_TDD_DL_SUBFRAME,   RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME, RGAC_TDD_DL_SUBFRAME,   RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME},
   {RGAC_TDD_DL_SUBFRAME, RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME,  RGAC_TDD_SPL_SUBFRAME, RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_UL_SUBFRAME,  RGAC_TDD_DL_SUBFRAME}
};

#endif

#if (defined(LTEMAC_MIMO) && defined(RGR_CQI_REPT))
PRIVATE S8 rgAcCmnDlCqiDiffOfst[8] = {0, 1, 2, 3, -4, -3, -2, -1};
#endif
/* Private function declarations go here */

PRIVATE S16 rgAcUtlTfuGetToMacPst ARGS((
         CmXtaTCCb   *tcCb,
         CmXtaSpCb   *spCb,
         Pst         *pst));


PRIVATE S16 rgAcUtlCheckDci  ARGS((
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch,
 CmLteTimingInfo timingInfo));

PRIVATE S16 rgAcUtlTfuGetFromMacPst ARGS((
         CmXtaTCCb   *tcCb,
         CmXtaSpCb   *spCb,
         Pst         *pst
         ));

PRIVATE S16 rgAcUtlTfuGetFromSchPst ARGS((
         CmXtaTCCb   *tcCb,
         CmXtaSpCb   *spCb,
         Pst         *pst
         ));

PRIVATE S16 rgAcUtlValidateRecpReq ARGS((
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 RgAcTfuInfo *rgTfuInfo));

PRIVATE S16 rgAcUtlValidateCntrlReq  ARGS((
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 RgAcTfuInfo *rgTfuInfo));
PRIVATE S16 rgAcUtlMatchRapId ARGS((
         U8            rapId,
         U16           timingAdv,
         RgAcPhyRaCb   *acPhyRaCb));

PRIVATE S16 rgAcUtlAddCeToEvnt ARGS((
         CmXtaTCCb        *tcCb,
         CmXtaSpCb        *spCb, 
         RgAcEdEvent      *evnt,
         U16              *tbs,
         U8               type));

PRIVATE S16 rgAcUtlTfuValidateDatReq   ARGS((
         CmXtaTCCb     *tcCb,
         CmXtaSpCb     *spCb,
         RgAcTfuInfo *rgTfuInfo));

PRIVATE S16 rgAcUtlCheckDciPuschTpc ARGS((
         CmXtaTCCb     *tcCb,
         CmXtaSpCb     *spCb,
         TfuPdcchInfo  *pdcch));

PRIVATE S16 rgAcUtlCheckDciForGrpPwr  ARGS((
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch,
 Bool           isFmt3a));




#ifdef RG_PHASE_2
PRIVATE S16 rgAcUtlTfuValidateGrpPwrCntrlReq ARGS((
         CmXtaTCCb     *tcCb,
         CmXtaSpCb     *spCb,
         RgAcTfuInfo *rgTfuInfo));
#endif

PRIVATE S16 rgAcUtlAddHdrPduToEvnt ARGS((
         CmXtaTCCb        *tcCb,
         CmXtaSpCb        *spCb, 
         RgAcEdEvent      *evnt,
         U16              tbs,
         U8               type));
#ifndef TFU_UPGRADE
PRIVATE S16 rgAcUtlValidateUlGrant ARGS((
         TfuUeMsg3RecpReq *recpReq,
         U32         ulGrant));

#else
PRIVATE S16 rgAcUtlValidateUlGrant ARGS((
         CmXtaTCCb         *tcCb,
         CmXtaSpCb         *spCb,
         TfuUePuschRecpReq *recpReq,
         U32         ulGrant));
#endif
PRIVATE S16  rgAcUtlUseUlGrant ARGS((
         U16              *tbs,
         U8               use));

PRIVATE S16 rgAcUtlTfuValidateTiming ARGS((
         RgAcTfuInfo      *tfuInfo));

PRIVATE Void   rgAcUtlCalcRivInfo ARGS((
         U32     riv, 
         U8      bw, 
         U8      *rbStart, 
         U8      *numRb));

PRIVATE S16 rgAcUtlValidateRarGrant  ARGS((
         U32             rarPdu,
         CmXtaTCCb       *tcCb,
         CmXtaSpCb       *spCb));

PRIVATE Bool rgAcUtlMatchRnti ARGS((
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 U16      tmpRnti));

PRIVATE Bool rgAcUtlCheckNumRb ARGS((
         U8      numRb));

PRIVATE S16 rgAcUtlHandlePadding ARGS((
         CmXtaTCCb        *tcCb,
         CmXtaSpCb        *spCb,
         RgAcEdEvent      *evnt,
         U16              tbs)); 

PRIVATE S16 rgAcUtlInsertPadding  ARGS((
         RgAcEdEvent      *evnt, 
         U32              tbs,
         U8               lcId));
#ifdef LTEMAC_SPS

PRIVATE S16  rgAcUtlCheckDciFrmt1aRelPdcch ARGS((
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch
));
PRIVATE S16  rgAcUtlCheckTfuHarqProcId ARGS((
   CmXtaTCCb     *tcCb,
   CmXtaSpCb     *spCb,
   TfuDatReqPduInfo *pduInfo,
   CmLteTimingInfo *TimingInfo
  ));

#endif


PRIVATE S16 rgAcTfuUtlVldtUlRbOvrlap ARGS((
   U8   rbStart,
   U8   numRb
   ));


#ifdef LTEMAC_HDFDD
PRIVATE S16 rgAcUtlTfuUtlVldtHdfddPDCCH ARGS((
         CmXtaTCCb *tcCb,
         CmXtaSpCb *spCb,
         TfuCntrlReqInfo *cntrlReq));
PRIVATE S16 rgAcTfuUtlHdfddVldtBCH ARGS((
         CmXtaTCCb     *tcCb,
         CmXtaSpCb     *spCb,
         TfuDatReqInfo       *datReq
));
#endif

/* Global place holder, used for buffer creation */
PUBLIC U8 junkData[RG_ACC_MAX_PDU_SIZE];

/* Functions for TFU */

#ifdef ANSI
PUBLIC S16 rgAcUtlTfuGetToSchPst 
(
 CmXtaTCCb  *tcCb,
 CmXtaSpCb  *spCb,
 Pst        *pst
 )
#else
PUBLIC S16 rgAcUtlTfuGetToSchPst (tcCb, spCb, pst)
 CmXtaTCCb  *tcCb;
 CmXtaSpCb  *spCb;
 Pst        *pst;
#endif
{
   ProcId               srcProcId;
   ProcId               dstProcId;
   Inst                 instId=RGSCH_INST_START;

   TRC2(rgAcUtlTfuGetToSchPst)
   /* Get the procId values from the xml test step */
   CMXTA_ZERO(pst, sizeof(Pst));
   srcProcId = CMXTA_PROCID_MASTER;
   dstProcId = CMXTA_PROCID_MASTER;

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "srcProc", &srcProcId);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "dstProc", &dstProcId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "schInstId",  &(instId));
   cmXtaGetPst(pst, ENTTF, CMXTA_INST_ID, ENTRG, instId, srcProcId, dstProcId, FALSE);

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuGetToSchPst */


#ifdef ANSI
PRIVATE S16 rgAcUtlTfuGetToMacPst 
(
 CmXtaTCCb  *tcCb,
 CmXtaSpCb  *spCb,
 Pst        *pst
 )
#else
PRIVATE S16 rgAcUtlTfuGetToMacPst (tcCb, spCb, pst)
 CmXtaTCCb  *tcCb;
 CmXtaSpCb  *spCb;
 Pst        *pst;
#endif
{
   ProcId               srcProcId;
   ProcId               dstProcId;
   Inst                 instId = 0;

   TRC2(rgAcUtlTfuGetToMacPst)
   /* Get the procId values from the xml test step */
   CMXTA_ZERO(pst, sizeof(Pst));
   srcProcId = CMXTA_PROCID_MASTER;
   dstProcId = CMXTA_PROCID_MASTER;

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "srcProc", &srcProcId);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "dstProc", &dstProcId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "macInstId",  &(instId));

   cmXtaGetPst(pst, ENTTF, CMXTA_INST_ID, ENTRG, instId, srcProcId, dstProcId, FALSE);

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuGetToMacPst */

#ifdef ANSI
PRIVATE S16 rgAcUtlTfuGetFromSchPst 
(
 CmXtaTCCb  *tcCb,
 CmXtaSpCb  *spCb,
 Pst        *pst
 )
#else
PRIVATE S16 rgAcUtlTfuGetFromSchPst (tcCb, spCb, pst)
 CmXtaTCCb  *tcCb;
 CmXtaSpCb  *spCb;
 Pst        *pst;
#endif
{
   ProcId               srcProcId;
   ProcId               dstProcId;
   Inst                 instId = RGSCH_INST_START;

   TRC2(rgAcUtlTfuGetFromSchPst)
   /* Get the procId values from the xml test step */
   CMXTA_ZERO(pst, sizeof(Pst));
   srcProcId = CMXTA_PROCID_MASTER;
   dstProcId = CMXTA_PROCID_MASTER;

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "srcProc", &srcProcId);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "dstProc", &dstProcId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "schInstId",  &(instId));
   cmXtaGetPst(pst, ENTRG, instId, ENTTF, CMXTA_INST_ID, srcProcId, dstProcId, FALSE);

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuGetToMacPst */


#ifdef ANSI
PRIVATE S16 rgAcUtlTfuGetFromMacPst 
(
 CmXtaTCCb  *tcCb,
 CmXtaSpCb  *spCb,
 Pst        *pst
 )
#else
PRIVATE S16 rgAcUtlTfuGetFromMacPst (tcCb, spCb, pst)
 CmXtaTCCb  *tcCb;
 CmXtaSpCb  *spCb;
 Pst        *pst;
#endif
{
   ProcId               srcProcId;
   ProcId               dstProcId;
   Inst                 instId = 0;

   TRC2(rgAcUtlTfuGetFromMacPst)
   /* Get the procId values from the xml test step */
   CMXTA_ZERO(pst, sizeof(Pst));
   srcProcId = CMXTA_PROCID_MASTER;
   dstProcId = CMXTA_PROCID_MASTER;

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "srcProc", &srcProcId);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U16, "dstProc", &dstProcId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "macInstId",  &(instId));
   cmXtaGetPst(pst, ENTRG, instId, ENTTF, CMXTA_INST_ID, srcProcId, dstProcId, FALSE);

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuGetToMacPst */

/** @brief This function is validates any message received from MAC to PHY.
 * @param tcCb a pointer to the test case control block
 * @param spCb a pointer to the stack control point
 * @param event Event type e.g. RaRespReq etc. 
 * @return CMXTA_ERR_NONE on a match else CMXTA_ERR_INT on no match.
 */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateMsg
(
 CmXtaTCCb  *tcCb,
 CmXtaSpCb  *spCb,
 U8         event
 )
#else
PUBLIC S16  rgAcUtlTfuValidateMsg (tcCb, spCb, event)
 CmXtaTCCb  *tcCb;
 CmXtaSpCb  *spCb;
 U8         event;
#endif
{
   Pst                  pst;
   SpId                 spId;      /* service user SAP identifier */
   S16                  ret;
   CmXtaMsgQElm         *qMsg;
   RgAccMsgQElm         *rgMsg;
   RgAcTfuInfo          *rgTfuInfo;

   TRC2(rgAcUtlTfuValidateMsg);

   if (event == EVTTFUDATREQ)
   {
      spId = 0;
      rgAcUtlTfuGetFromMacPst (tcCb, spCb, &pst);
   }
   else
   {
      spId = 1;
      rgAcUtlTfuGetFromSchPst (tcCb, spCb, &pst);
   }

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "spId",  &(spId));
   if (ROK != cmXtaPeekMsg(&(tcCb->msgQ[0]), &qMsg))
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuValidateMsg(): cmXtaPeekMsg failed\n"));
      RETVALUE(CMXTA_ERR_FATAL);
   }
   rgMsg = (RgAccMsgQElm *)qMsg->data;

   pst.event = event;
   if((ret = cmXtaValidatePst(&(qMsg->pst), &pst)) != ROK)
   {
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   rgTfuInfo = &(rgMsg->u.tfuInfo);
   if (spId != rgTfuInfo->spId)
   {
      CMXTA_DBG_CALLIND((_cmxtap, "Info : spId mismatch: exp (%d) rcvd (%d) \n",
               spId, rgTfuInfo->spId), 3);
      RETVALUE(CMXTA_ERR_NOMATCH);
   }

   if ((event != EVTTFUDATREQ) && (rgAccCb.directives.noTimeValidation == FALSE))
   {
      if ((ret = rgAcUtlTfuValidateTiming (rgTfuInfo)) == CMXTA_ERR_NOMATCH)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg() Error : Timing SFN mismatch:\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   /* We have so far matched the Pst and the spId for message received now we
    * have the task of identifying the primitive and also the internals of the
    * PDU and the parameters for the primitive as well. 
    */
   switch (event)
   {
      case EVTTFUDATREQ:
         ret = rgAcUtlTfuValidateDatReq (tcCb,
               spCb, 
               rgTfuInfo);
         break;
      case EVTTFUCNTRLREQ:
         ret = rgAcUtlValidateCntrlReq (tcCb,
               spCb, 
               rgTfuInfo);
         break;
      case EVTTFURECPREQ:
         ret = rgAcUtlValidateRecpReq (tcCb,
               spCb, 
               rgTfuInfo);
         break;
      default:
         CMXTA_DBG_CALLIND((_cmxtap, "Info : Invalid Event rcvd (%d) \n",
                  event), 3);
         ret = CMXTA_ERR_INT;
         break;

   } /* end of switch */

   if (ret == CMXTA_ERR_NOMATCH)
      RETVALUE(ret);
   /* the following attribute will let us save the message into a queue for
    * later retrival, that may be used to validate/provide some input for the
    * messages that follow. In tandem with "use".
    * <tapa.expect>
    *    <tapa.tfu.pdcch.req ueId="1" saveTo="2"/>
    *   <tapa.expect>
    *
    *   <tapa.send>
    *      <tapa.tfu.datInd ueId="1" use="2"/>
    *   <tapa.send>
    */

   /*-- Remove the msg from the Queue --*/
   cmXtaPopMsg (&(tcCb->msgQ[0]), &qMsg);
   if (qMsg)
   {
      cmXtaFlushMsg (&(tcCb->msgQ[0]), qMsg);
   }
   RETVALUE(ret);

} /* rgAcUtlTfuValidateMsg */



 /** @brief This function tries to match the giving RAP IDs with the
  * stored values in the acPhyRaCb
  * @param  rapId
  * @param  acPhyRaCb
  * @return CMXTA_ERR_NONE/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlMatchRapId 
(
 U8            rapId,
 U16           timingAdv,
 RgAcPhyRaCb   *acPhyRaCb
)
#else
PRIVATE S16 rgAcUtlMatchRapId (rapId, timingAdv, acPhyRaCb)
 U8            rapId;
 U16           timingAdv;
 RgAcPhyRaCb   *acPhyRaCb;
#endif
{
   U8       i;

   TRC2(rgAcUtlMatchRapId)

   for (i = 0; i < acPhyRaCb->numRaReqInfo; i++)
   {
      if (acPhyRaCb->raReqInfoArr[i].rapId == rapId)
      {
         /* should have the same Timing advance as recieved */
         if (acPhyRaCb->raReqInfoArr[i].ta == timingAdv)
            RETVALUE(CMXTA_ERR_NONE);
         else
            RETVALUE(CMXTA_ERR_NOMATCH);
      }
   } /* end of for loop */ 

   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlMatchRapId */ 


/** @brief This function will populate the TfuRaReqIndInfo structure based on
 * the inputs given in the test case. 
 * @param[in] tcCb a pointer to the test case control block 
 * @param[in] spCb a pointer to the stack pointer control block
 * @param[out] pst a pointer to the Pst structure to be populated by this function
 * @param[out] suId SAP ID of service User
 * @param[out] raReqInd a pointer to the TfuRaReqIndInfo that is to be populated by
 * this function. 
 * @return CMXTA_ERR_NONE on success CMXTA_ERR_INT on failure.
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildRaReqIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuRaReqIndInfo  *raReqInd
 )
#else
PUBLIC S16 rgAcUtlTfuBuildRaReqIndMsg (tcCb, spCb, pst, suId, raReqInd)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuRaReqIndInfo  *raReqInd;
#endif
{
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;
   S16             ret;

   TRC2(rgAcUtlTfuBuildRaReqIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   raReqInd->cellId  = RG_ACC_CELL_ID;

   /* Default value should be one */

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.rareq.ind> command. Processing is as follows 
    * - Store the raReqInd structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   raReqInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   /* We shall allocate a MAX of 10 random access structs single shot */
   if ((ret = cmGetMem (&(raReqInd->memCp), (sizeof(TfuRachInfo) * 10), 
            (Ptr *)&raReqInd->rachInfoArr)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(): resource error\n"));
      RETVALUE(ret);
   }
   tcCb->data = (Void *)(raReqInd); 
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);

   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildRaReqIndMsg */

/** @brief This function is the handler for the lower-level command that is
 * embedded within the higher-level command of Random Access Request Indication.
 *
 * @details
 * This function shall fill up only one section of the TfuRaReqIndInfo data
 * structure i.e. corresponding to only on RA-RNTI
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Get the RA-RNTI
 *         - Get the section of the data structure corresponding to this
 *         RA-RNTI
 *         - Get varion parameters like RAP-ID, timingAdv etc. 
 *         - Increment the number of RA-RNTIs 
 *         - Return
 * @param[in]  tcCb pointer to CmXtaTCCb
 * @param[in]  spCb pointer to CmXtaSpCb
 * @param[in]  pst  pointer to Pst
 * @param[in]  suId pointer to the SuId i.e. SAP ID
 * @param[out] raReqInd  pointer to the TfuRaReqIndInfo. A section of this
 * structure would be populated by this function.
 * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_FATAL
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildRaReq
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuRaReqIndInfo  *raReqInd
 )
#else
PUBLIC S16 rgAcUtlTfuBuildRaReq(tcCb, spCb, raReqInd)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuRaReqIndInfo  *raReqInd;
#endif
{
   U8              i;
   U8              raRnti;
   U8              numRapId;
   U8              num;
   U8              raRapId[TFU_MAX_RAPID_IN_SUBFRAME] = {0};
   U16             ta[TFU_MAX_RAPID_IN_SUBFRAME] = {0};
   U8              tpc[TFU_MAX_RAPID_IN_SUBFRAME] = {0};
   Bool            cqiPres[TFU_MAX_RAPID_IN_SUBFRAME] = {0};
   U8              cqi[TFU_MAX_RAPID_IN_SUBFRAME] = {0};
   TfuRachInfo     *rachInfo;
   S16             ret = ROK;
   RgAcPhyRaCb     *acPhyRaCb;       /* context stored in the dummy Phy to validate a 
                                             random access response. */

   TRC2(rgAcUtlTfuBuildRaReq)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRaReq(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRaReq(), tcId(%d)\n", tcCb->tcId));
#endif

   raReqInd->cellId  = RG_ACC_CELL_ID;

   /* Now we need to construct the dummy RA request from the dummy physical
    * layer. The following values are to be created. 
    * 1. RA_RNTI this is a list now
    * 2. Timing Information SFN and Subframe
    * 3. Number of RA requests in this subframe per RA RNTI
    *    For each Preamble or RAPID we need the following
    *    1. rapId
    *    2. ta - Timing advance reported by PHY
    *    3. tpc - power
    *    4. CQI present
    *    5. CQI index if present
    * RA_RNTI should be calculated based on the current SFN based on the ticks
    * from the TTI timer being run in the DUMMMY phy. 
    * Rest of the values shall have a default value and if the user intends to
    * provide the value through XML he can have the option of doing that as
    * well. 
    */

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "raRnti",  &raRnti);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "numRapId",  &numRapId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(raReqInd->cellId));

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "rapIds", raRapId, &num);

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, CMXTA_SEP_COLON, 
         "timingAdvs", ta, &num);

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "tpcs", tpc, &num);

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, CMXTA_SEP_COLON, 
         "cqiPres", cqiPres, &num);

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "cqis", cqi, &num);

   /* We need to copy the current time into raReqInd */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, raReqInd->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, raReqInd->timingInfo);
   }
   raRnti = raReqInd->timingInfo.subframe+1;
   raReqInd->nmbOfRaRnti++;
   rachInfo = &(raReqInd->rachInfoArr[raReqInd->nmbOfRaRnti - 1]);
   /* Get the corresponding RgAcRachCb from the array that array. */
   acPhyRaCb   = &(rgAccCb.acRaCb[raRnti]);
   acPhyRaCb->raRnti          = raRnti;
   acPhyRaCb->numRaReqInfo    = numRapId;
   /* copy to rachInfo */
   rachInfo->raRnti           = raRnti;
   rachInfo->numRaReqInfo     = numRapId;

   /* We shall allocate a MAX of 10 random access structs single shot */
   if ((ret = cmGetMem (&(raReqInd->memCp), (sizeof(TfuRaReqInfo) * 10), 
            (Ptr *)&rachInfo->raReqInfoArr)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuBuildRaReqIndMsg(): resource error\n"));
      RETVALUE(ret);
   }

   for (i = 0; i < numRapId; i++)
   {
      rachInfo->raReqInfoArr[i].rapId   = raRapId[i];
      rachInfo->raReqInfoArr[i].ta      = ta[i];
      rachInfo->raReqInfoArr[i].tpc     = tpc[i];
      rachInfo->raReqInfoArr[i].cqiPres = cqiPres[i];
      rachInfo->raReqInfoArr[i].cqiIdx  = cqi[i];

      /* We also need to populate the information stored at dummy Phy to be used
       * for validation later on. 
       */
      acPhyRaCb->raReqInfoArr[i].rapId   = raRapId[i];
      acPhyRaCb->raReqInfoArr[i].ta      = ta[i];
      acPhyRaCb->raReqInfoArr[i].tpc     = tpc[i];
      acPhyRaCb->raReqInfoArr[i].cqiPres = cqiPres[i];
      acPhyRaCb->raReqInfoArr[i].cqiIdx  = cqi[i];
   } /* end of for RA RapIds*/
   /* increment the values of nmbOfRaCb and nmbOfRaRnti */
   rgAccCb.nmbOfRaCb++;
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildRaReq*/











 /** @brief This function uses the UL Grant given to the UE earlier and sends
  * the data of appropriate size to MAC.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - We need to ensure that the MAC header + MAC PDU = UL_GRANT
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlUseUlGrant 
(
 U16              *tbs,
 U8               use
 )
#else
PRIVATE S16 rgAcUtlUseUlGrant (tbs, use)
 U16              *tbs;
 U8               use;
#endif
{
   TfuUeRecpReqInfo    *recpReq;
#ifndef TFU_UPGRADE 
   U8                   numRb;
   U8                   mcs;
   U8                   iTbs;
#endif
   TRC2(rgAcUtlUseUlGrant)

   recpReq  = &(rgAccCb.savedMsgs[use].u.ueRecpReqInfo);
#ifndef TFU_UPGRADE
   numRb       = recpReq->t.puschRecpReq.numRb;
   mcs         = recpReq->t.puschRecpReq.mcs;
   iTbs        = modTbsInxTbl[mcs].iTbs;
 /*  *tbs        = tbsTbl[iTbs][numRb - 1];*/
  *tbs        = recpReq->t.puschRecpReq.size;
#else
   *tbs        = recpReq->t.puschRecpReq.ulSchInfo.size;
#endif/* TFU_UPGRADE*/
  
   *tbs = *tbs * 8; /* Converting to bits*/

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlUseUlGrant */ 

 /** @brief This function 
  * @param  tcCb pointer to the test case control block
  * @param  spCb pointer to the stack control block
  * @param  evnt event type
  * @param  type of control element
  * @return ROK/RFAILED
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlAddHdrPduToEvnt
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb, 
 RgAcEdEvent      *evnt,
 U16              tbs,
 U8               type
)
#else
PRIVATE S16 rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, tbs, type)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb; 
 RgAcEdEvent      *evnt;
 U16              tbs;
 U8               type;
#endif
{
   S16               ret;
   RgAcDatPdu        *datPdu;
   U8                sduSize;
   U8                padBytes;
   RgAcSubHeader     *subHdr;
   RgAcCEorSDU       *ce;

   TRC2(rgAcUtlAddHdrPduToEvnt)
   datPdu = &(evnt->u.datPdu);

   /* Now we can allocate the specific header */
   if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcSubHeader), 
            (Ptr *)&subHdr)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddHdrPduToEvnt(): resource error\n"));
      RETVALUE(ret);
   }

   /* Now we can allocate the specific header */
   if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcCEorSDU), 
            (Ptr *)&ce)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddHdrPduToEvnt(): resource error\n"));
      RETVALUE(ret);
   }

   /* At this point we have allocated a new sub header and a new CE, lets now
    * proceed to fill in the values.
    */
   switch (type)
   {
      case RG_ACC_CCCH_SDU:
         subHdr->type = RG_ACC_SHORT_SUBHDR;
         subHdr->lcId = RG_ACC_CCCH_SDU;   /* : ensure the value is 00000 */
         sduSize = 10;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "sduSize",  &sduSize);
         subHdr->u.shortSubHdr.length = sduSize;
         ce->isCE = FALSE;
         ce->u.rgAcCE.type = RG_ACC_CCCH_SDU;
         ce->u.pduSize = sduSize;
         break;
      case RG_ACC_PADDING_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->lcId = RG_ACC_PADDING_CE;   /* : ensure the value is 00000 */
         ce->isCE = FALSE;
         ce->u.rgAcCE.type = RG_ACC_PADDING_CE;
         padBytes = (tbs/8) - 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "padBytes",  &padBytes);
         ce->u.pduSize     = padBytes;
         break;
      default:
         if ((tbs/8) > 127)
         {
            subHdr->type = RG_ACC_LONG_SUBHDR;
            subHdr->lcId = type;   /* : ensure the value is 00000 */
            subHdr->u.longSubHdr.length = (tbs)/8;
            ce->isCE = FALSE;
            ce->u.pduSize = (tbs)/8;
         }
         else
         {
            subHdr->type = RG_ACC_SHORT_SUBHDR;
            subHdr->lcId = type;   /* : ensure the value is 00000 */
            subHdr->u.shortSubHdr.length = (tbs)/8;
            ce->isCE = FALSE;
            ce->u.pduSize = (tbs)/8;
         }
         break;
   }

   /* Finally lets add the subheader and CE to the linked list */
   cmLListAdd2Tail (&(datPdu->subHdrs), &(subHdr->lnk));
   subHdr->lnk.node = (PTR)subHdr;
   cmLListAdd2Tail (&(datPdu->ceOrSdus), &(ce->lnk));
   ce->lnk.node = (PTR)ce;
   RETVALUE(ret);
} /* end of rgAcUtlAddHdrPduToEvnt */ 


 /** @brief This function 
  * @param  tcCb pointer to the test case control block
  * @param  spCb pointer to the stack control block
  * @param  evnt event type
  * @param  type of control element
  * @return ROK/RFAILED
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlAddCeToEvnt
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb, 
 RgAcEdEvent      *evnt,
 U16              *tbs,
 U8               type
)
#else
PRIVATE S16 rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, tbs, type)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb; 
 RgAcEdEvent      *evnt;
 U16              *tbs;
 U8               type;
#endif
{
   S16               ret;
   RgAcDatPdu        *datPdu;
   RgAcSubHeader     *subHdr;
   RgAcCEorSDU       *ce;
   U8                phr;
   U8                ueId;
   U16               rnti;
   U8                lcgId;
   U8                bsr;
   U8                bsr0;
   U8                bsr1;
   U8                bsr2;
   U8                bsr3;
   U8                invldCrnti = FALSE;

   U8                extPhr0 = 0xFF;
   U8                pCMax0 = 0xFF;
   U8                extPhr1 = 0xFF;
   U8                pCMax1 = 0xFF;
   U8                extPhrByteCnt = 0;

   TRC2(rgAcUtlAddCeToEvnt)

   datPdu   = &(evnt->u.datPdu);
   phr      = 0;
   ueId     = 0;
   lcgId    = 0;
   bsr      = 0;
   bsr0     = 0;
   bsr1     = 0;
   bsr2     = 0;
   bsr3     = 0;

   /* Allocate a node to the sub header */
   if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcSubHeader), 
            (Ptr *)&subHdr)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddCeToEvnt(): resource error\n"));
      RETVALUE(ret);
   }

   /* Now we can allocate the CE OR SDU */
   if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcCEorSDU), 
            (Ptr *)&ce)) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddCeToEvnt(): resource error\n"));
      RETVALUE(ret);
   }

   /* At this point we have allocated a new sub header and a new CE, lets now
    * proceed to fill in the values.
    */
   switch (type)
   {
      case RG_ACC_EXT_PWR_HDR_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->u.lastSubHdr.isLast = FALSE;
         subHdr->lcId = RG_ACC_EXT_PWR_HDR_CE;   /* : ensure the value is 11001 */
         ce->isCE = TRUE;
         ce->u.rgAcCE.type = RG_ACC_EXT_PWR_HDR_CE;
         
         extPhrByteCnt = 1; /* CI */
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "extPhr0",  &extPhr0);
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "pCMax0",  &pCMax0);
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[0].phr = extPhr0;
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[0].pCMax = pCMax0;
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[0].pBackOff = 0;
         
         extPhrByteCnt++; /* PHR for PCELL */ 
         if (pCMax0 != 0xFF)
         {
            extPhrByteCnt++; /* PCMAX for PCELL */ 
         }
         
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "extPhr1",  &extPhr1);
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "pCMax1",  &pCMax1);
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[1].phr = extPhr1;
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[1].pCMax = pCMax1;
         ce->u.rgAcCE.u.rgAcExtPhr.phrInfo[1].pBackOff = 0;

         if (extPhr1 != 0xFF)
         {
            extPhrByteCnt++; /* PHR for SCELL */ 
            if (pCMax1 != 0xFF)
            {
               extPhrByteCnt++; /* PCMAX for SCELL */ 
            }
         } 

         if (*tbs != 0)
            *tbs -= (1 * 8) + (extPhrByteCnt * 8);
         break;

      case RG_ACC_PWR_HDR_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->u.lastSubHdr.isLast = FALSE;
         subHdr->lcId = RG_ACC_PWR_HDR_CE;   /* : ensure the value is 11010 */
         ce->isCE = TRUE;
         ce->u.rgAcCE.type = RG_ACC_PWR_HDR_CE;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "phr",  &phr);
         ce->u.rgAcCE.u.rgAcPwrHdr.pwrHdr = phr;
         if (*tbs != 0)
            *tbs -= (1 * 8) + (1 * 8);
         break;
      case RG_ACC_CRNTI_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->u.lastSubHdr.isLast = FALSE;
         subHdr->lcId = RG_ACC_CRNTI_CE;   /* : ensure the value is 11011 */
         ce->isCE = TRUE;
         ce->u.rgAcCE.type = RG_ACC_CRNTI_CE;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
         rnti = rgAccCb.acUeCb[ueId].crnti;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "crnti", &rnti);
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "invldCrnti", &invldCrnti);
         if (invldCrnti)
          {
             ce->u.rgAcCE.u.rgAcCrnti.crnti = RG_ACC_INVLD_CRNTI;
          }
         else
         {
            ce->u.rgAcCE.u.rgAcCrnti.crnti = rgAccCb.acUeCb[rnti].crnti;
         }
         if (*tbs != 0)
            *tbs -= (1 * 8) + (6 * 8);
         break;
      case RG_ACC_SBSR_CE:
      case RG_ACC_TBSR_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->u.lastSubHdr.isLast = FALSE;
         subHdr->lcId = type;   /* : ensure the value is 11100 */
         ce->isCE = TRUE;
         ce->u.rgAcCE.type = type;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "lcgId",  &lcgId);
         bsr = 0;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bsr",  &bsr);
         if (bsr == 0 && type == RG_ACC_TBSR_CE)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlAddCeToEvnt(): bsr=0 for truncated BSR\n"));
            RETVALUE(CMXTA_ERR_INT);
         }
         ce->u.rgAcCE.u.rgAcShortBSR.lcgId = lcgId;
         ce->u.rgAcCE.u.rgAcShortBSR.bufferSize = bsr;
         if (*tbs != 0)
            *tbs -= (1 * 8) + (1 * 8);
         break;
      case RG_ACC_LBSR_CE:
         subHdr->type = RG_ACC_LAST_SUBHDR;
         subHdr->u.lastSubHdr.isLast = FALSE;
         subHdr->lcId = RG_ACC_LBSR_CE;   /* : ensure the value is 11110 */
         ce->isCE = TRUE;
         ce->u.rgAcCE.type = RG_ACC_LBSR_CE;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bsr0",  &bsr0);
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bsr1",  &bsr1);
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bsr2",  &bsr2);
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bsr3",  &bsr3);
         ce->u.rgAcCE.u.rgAcLongBSR.bufferSize1 = bsr0;
         ce->u.rgAcCE.u.rgAcLongBSR.bufferSize2 = bsr1;
         ce->u.rgAcCE.u.rgAcLongBSR.bufferSize3 = bsr2;
         ce->u.rgAcCE.u.rgAcLongBSR.bufferSize4 = bsr3;
         if (*tbs != 0)
            *tbs -= (1 * 8) + (3 * 8);
         break;
      default:
         ret = RFAILED;
         break;
   }

   /* Finally lets add the subheader and CE to the linked list */
   cmLListAdd2Tail (&(datPdu->subHdrs), &(subHdr->lnk));
   subHdr->lnk.node = (PTR)subHdr;
   cmLListAdd2Tail (&(datPdu->ceOrSdus), &(ce->lnk));
   ce->lnk.node = (PTR)ce;

   RETVALUE(ret);
} /* end of rgAcUtlAddCeToEvnt */ 


/** @brief This function will populate the TfuTtiIndInfo structure based on
 * the inputs given in the test case. 
 * @param[in] tcCb a pointer to the test case control block 
 * @param[in] spCb a pointer to the stack pointer control block
 * @param[out] pst a pointer to the Pst structure to be populated by this function
 * @param[out] suId SAP ID of service User
 * @param[out] ttiInd a pointer to the TfuTtiIndInfo that is to be populated by
 * this function. 
 * @return CMXTA_ERR_NONE on success CMXTA_ERR_INT on failure.
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildMultiInstTtiIndMsg
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 Pst                 *pst,
 SuId                *suId,
 TfuTtiIndInfo       *ttiInd,
 U8                  instIdx
 )
#else
PUBLIC S16 rgAcUtlTfuBuildMultiInstTtiIndMsg (tcCb, spCb, pst, suId, ttiInd, instIdx)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 Pst                 *pst;
 SuId                *suId;
 TfuTtiIndInfo       *ttiInd;
 U8                  instIdx;
#endif
{
   int rb;

   TRC2(rgAcUtlTfuBuildMultiInstTtiIndMsg)

   for (rb = 0; rb < 110; rb++)
   {
      rgAccCb.ulRbMap[rb] = RGAC_RB_FREE;
   }

   *suId = 0;
   RGCPYTIMEINFO(rgAcTfCb.crntTime, ttiInd->cells[instIdx].timingInfo);

   ttiInd->cells[instIdx].cellId = RG_ACC_CELL_ID;

   ttiInd->cells[instIdx].isDummyTti = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
         "isDummyTti",  &ttiInd->cells[instIdx].isDummyTti);

   /* We need to copy the current time into raReqInd */
   RGCPYTIMEINFO(rgAcTfCb.crntTime, ttiInd->cells[instIdx].timingInfo);
   if (ttiInd->cells[instIdx].timingInfo.subframe > RG_NUM_SUB_FRAMES)
      ttiInd->cells[instIdx].timingInfo.subframe = 0;
   /* We are done with filling up of the structure */
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildMultiInstTtiIndMsg*/




/** @brief This function will populate the TfuTtiIndInfo structure based on
 * the inputs given in the test case. 
 * @param[in] tcCb a pointer to the test case control block 
 * @param[in] spCb a pointer to the stack pointer control block
 * @param[out] pst a pointer to the Pst structure to be populated by this function
 * @param[out] suId SAP ID of service User
 * @param[out] ttiInd a pointer to the TfuTtiIndInfo that is to be populated by
 * this function. 
 * @return CMXTA_ERR_NONE on success CMXTA_ERR_INT on failure.
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildTtiIndMsg
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 Pst                 *pst,
 SuId                *suId,
 TfuTtiIndInfo       *ttiInd
 )
#else
PUBLIC S16 rgAcUtlTfuBuildTtiIndMsg (tcCb, spCb, pst, suId, ttiInd)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 Pst                 *pst;
 SuId                *suId;
 TfuTtiIndInfo       *ttiInd;
#endif
{
   int rb;

   TRC2(rgAcUtlTfuBuildTtiIndMsg)

   for (rb = 0; rb < 110; rb++)
   {
      rgAccCb.ulRbMap[rb] = RGAC_RB_FREE;
   }
   rgAcUtlTfuGetToMacPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "macSuId",  suId);
   RGCPYTIMEINFO(rgAcTfCb.crntTime, ttiInd->cells[0].timingInfo);

   ttiInd->cells[0].cellId = RG_ACC_CELL_ID;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(ttiInd->cells[0].cellId));

   ttiInd->cells[0].isDummyTti = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
         "isDummyTti",  &ttiInd->cells[0].isDummyTti);

   /* We need to copy the current time into raReqInd */
   RGCPYTIMEINFO(rgAcTfCb.crntTime, ttiInd->cells[0].timingInfo);
   if (ttiInd->cells[0].timingInfo.subframe > RG_NUM_SUB_FRAMES)
      ttiInd->cells[0].timingInfo.subframe = 0;
   /* We are done with filling up of the structure */
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildTtiIndMsg */


 /** @brief This function is the high level handler for the DatReq primitive
  * present on the TFU interface.
  *
  * @details
  * This function would have lower-level xml commands embedded within it. This
  * handler shall call each of the lower-level commands one by one. A complete
  * match shall be regarded as success.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Loop through all the lower-level commands, invoking their
  *         corresponding handlers. 
  *         - The handlers could be either 
  *         -# Zero or One tapa.tfu.bch.dat.req
  *         -# Zero or More tapa.tfu.pdsch.dat.req
  *
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  rgTfuInfo pointer to RgAcTfuInfo
  * @return 
  * -# CMXTA_ERR_NONE
  * -# CMXTA_ERR_INT
  * -# CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlTfuValidateDatReq
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 RgAcTfuInfo *rgTfuInfo
 )
#else
PRIVATE S16 rgAcUtlTfuValidateDatReq (tcCb, spCb, rgTfuInfo)
   CmXtaTCCb     *tcCb;
   CmXtaSpCb     *spCb;
   RgAcTfuInfo *rgTfuInfo;
#endif
{
   S16               ret;
   TfuDatReqInfo     *datReq;
   Void              *nxtStep;
   CmXtaXmlCb        *xmlCb;

   TRC2(rgAcUtlTfuValidateDatReq);

   datReq = (rgTfuInfo->u.datReqInfo);

   /* Logic is as follows 
    * Loop through all the low-level commands validating each one of them.
    */
   tcCb->data = (Void *)(datReq); 
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDatReq(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside expect tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDatReq(): invalid cmd in <tapa.expect>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call to the handler finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   } /* end of while */

   /* If we have gotten here then a perfect match is guranteed. */
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuValidateDatReq */ 



 /** @brief This function compares two buffers
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuCompareBuf
(
 Buffer        *buf1,
 Buffer        *buf2
)
#else
PUBLIC S16 rgAcUtlTfuCompareBuf (buf1, buf2)
 Buffer        *buf1;
 Buffer        *buf2;
#endif
{
   MsgLen            origLen;
   MsgLen            rcvdLen;
   U8                origData=0;
   U8                rcvdData=0;
   MsgLen            i;

   TRC2(rgAcUtlTfuCompareBuf);

   SFndLenMsg(buf1, &origLen);
   SFndLenMsg(buf2, &rcvdLen);
   if (origLen != rcvdLen)
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuCompareBuf(): Length Mismatch exp (%d) rcvd (%d)\n",
               (int)origLen, (int)rcvdLen));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   for (i = 0; i < origLen; i++)
   {
      SExamMsg((Data*)&origData, buf1, i);
      SExamMsg((Data*)&rcvdData, buf2, i);
      if (origData != rcvdData)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuCompareBuf(): Data Mismatch \n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of */ 


 /** @brief This function validates the control request received at the TFU
  * interface.
  *
  * @details
  * Control request data to be sent on the following channels 
  * -# PCFICH
  * -# PDCCH (uplink DCI and downlink DCI)
  * -# PHICH
  *
  *     Function: 
  *
  *         Processing steps:
  *         - This is the high level validate function, it shall delate the
  *         validation to lower level functions for 
  *         -# PCFICH
  *         -# PDCCH
  *         -# PHICH
  *         Each of this shall validate each of these values for a single RNTI
  *         i.e. if there are PDCCHs for four UEs the lower-level handlers for
  *         PDCCH shall be called 4 times.
  *
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  rgTfuInfo pointer to RgAcTfuInfo i.e. contains the data to be
  * validated.
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlValidateCntrlReq 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 RgAcTfuInfo *rgTfuInfo
 )
#else
PRIVATE S16 rgAcUtlValidateCntrlReq (tcCb, spCb, rgTfuInfo)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 RgAcTfuInfo *rgTfuInfo;
#endif
{
   S16               ret;
   TfuCntrlReqInfo   *cntrlReq;
   Void              *nxtStep;
   CmXtaXmlCb        *xmlCb;
   U8                expCntrlReq;

   TRC2(rgAcUtlValidateCntrlReq);

   cntrlReq = (rgTfuInfo->u.cntrlReqInfo);

   /* Logic is as follows 
    * CFI is simple enough i.e. just calling the corresponding handler should
    * get it done. 
    * PDCCH is a linked list - each handler would need to loop through all of
    * these to find the best match. This ensures that that test case writer
    * doesn't need to bother about the order in which MAC sends the PDCCHs. 
    * Optionally we could optimize this approach, such that we can delete the
    * PDCCH from the list once there is a perfect match. This would reduce the
    * number of iterations the next handler would need. 
    * Same applies to PHICHs as well.
    */
   tcCb->data = (Void *)(cntrlReq); 
   expCntrlReq = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "expCntrlReq", &expCntrlReq);
   if ((expCntrlReq != 0) && (expCntrlReq != (cntrlReq->ulPdcchLst.count + 
            cntrlReq->dlPdcchLst.count +
            cntrlReq->phichLst.count)))
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateCntrlReq(): Unexpected number of Cntrl Cmds\n"));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateCntrlReq(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside expect tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateCntrlReq(): invalid cmd in <tapa.expect>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   } /* end of while */

   /* If we have gotten here then a perfect match is guranteed. */
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlValidateCntrlReq */ 

 /** @brief This function validates the reception request received at the TFU
  * interface.
  *
  * @details
  * Reception request is sent for either of the following
  * -# PUUCH
  * -# MSG3 
  * -# PUSCH
  *
  *     Function: 
  *         Processing steps:
  *         - This is the high level validate function, it shall delate the
  *         validation to lower level functions for 
  *         -# PUUCH
  *         -# MSG3
  *         -# PUSCH
  *
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  rgTfuInfo pointer to RgAcTfuInfo i.e. contains the data to be
  * validated.
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlValidateRecpReq 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 RgAcTfuInfo *rgTfuInfo
 )
#else
PRIVATE S16 rgAcUtlValidateRecpReq (tcCb, spCb, rgTfuInfo)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 RgAcTfuInfo *rgTfuInfo;
#endif
{
   S16              ret;
   TfuRecpReqInfo   *recpReq;
   Void             *nxtStep;
   CmXtaXmlCb       *xmlCb;
   U8                expRecpReq;
#ifdef TFU_UPGRADE
   RgAcTfuUeRecpReqInfo  recpReqInfo;
   CmLList               *node;
   TfuUeRecpReqInfo      *ueRecpReq;
   CmLList               *tmp;
   /* ccpu00116923 - Testing SRS Present for Cell Specific SRS */
   U8                    vldtSrsPres;
   U8                    srsPres;
#endif /*TFU_UPGRADE*/

   TRC2(rgAcUtlValidateRecpReq);

   recpReq = (rgTfuInfo->u.recpReqInfo);

   expRecpReq = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "expRecpReq", &expRecpReq);
   if ((expRecpReq != 0) && (expRecpReq != (recpReq->ueRecpReqLst.count)))
   {
      CMXTA_DBG_ERR((_cmxtap, 
               "rgAcUtlValidateRecpReq(): Expected (%d) number of Reception Requests but received (%d)!\n",
               (int)expRecpReq, (int)recpReq->ueRecpReqLst.count));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }

#ifdef TFU_UPGRADE
   /* ccpu00116923 - Testing SRS Present for Cell Specific SRS */
   vldtSrsPres = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "vldtSrsPres", &vldtSrsPres);
   srsPres = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "srsPres", &srsPres);
   if ((vldtSrsPres != 0) && (srsPres != (recpReq->srsPres)))
   {
      CMXTA_DBG_ERR((_cmxtap, 
               "rgAcUtlValidateRecpReq(): SRS Present exp (%d) recvd (%d)!\n",
               (int)srsPres, (int)recpReq->srsPres));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   /*We need to populate the list ueRecpReqNdLst using the list in recpReq */
   recpReqInfo.recpReq = recpReq; 
   cmLListInit(&recpReqInfo.ueRecpReqNdLst);

   node = recpReq->ueRecpReqLst.first;
   while (node)
   {
      RgAcTfuUeRecpReqNode *ptr;

      ueRecpReq = (TfuUeRecpReqInfo *)node->node;

      if ((ret = rgAcUtlAllocMem((Data **)&ptr, sizeof(RgAcTfuUeRecpReqNode))) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlValidateRecpReq(): resource error\n"));
         RETVALUE(ret);
      }

      ptr->recpTypeBitMsk = RG_ACC_TFU_ZERO_MSK;
      if(TFU_RECP_REQ_PUCCH == ueRecpReq->type)
      {
         switch(ueRecpReq->t.pucchRecpReq.uciInfo)
         {
            case TFU_PUCCH_HARQ:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            break;

            case TFU_PUCCH_CQI:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            break;

            case TFU_PUCCH_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SRS;
            break;

            case TFU_PUCCH_SR:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            break;

            case TFU_PUCCH_SR_CQI:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            break;

            case TFU_PUCCH_SR_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SRS;
            break;

            case TFU_PUCCH_HARQ_SR:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            break;

            case TFU_PUCCH_HARQ_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SRS;
            break;

            case TFU_PUCCH_HARQ_CQI:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            break;

            case TFU_PUCCH_HARQ_SR_CQI:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            break;

            /* ccpu00116923 - New Reception Request types for CQI
             * and SRS with SR */
            case TFU_PUCCH_HARQ_SR_CQI_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SRS;
            break;
           
            case TFU_PUCCH_SR_CQI_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_CQI;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SR;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUCCH_SRS;
            break;

            default:
            break;
         }
      }
      else if(TFU_RECP_REQ_PUSCH == ueRecpReq->type)
      {
         switch(ueRecpReq->t.puschRecpReq.rcpInfo)
         {
            case TFU_PUSCH_DATA:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            break;

            case TFU_PUSCH_DATA_HARQ:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_HARQ;
            break;

            case TFU_PUSCH_DATA_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_SRS;
            break;

            case TFU_PUSCH_DATA_HARQ_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_SRS;
            break;

            case TFU_PUSCH_DATA_CQI_HARQ_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_CQI;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_SRS;
            break;

            case TFU_PUSCH_DATA_CQI:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_CQI;
            break;

            case TFU_PUSCH_DATA_CQI_HARQ:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_HARQ;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_CQI;
            break;

            case TFU_PUSCH_DATA_CQI_SRS:
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_DATA;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_SRS;
            ptr->recpTypeBitMsk |= RG_ACC_TFU_PUSCH_CQI;
            default:
            break;
         }
      }

      ptr->node = ueRecpReq;
      ptr->lnk.node = (PTR)ptr;
      cmLListAdd2Tail (&(recpReqInfo.ueRecpReqNdLst), &(ptr->lnk));

      node = node->next;
   } /* end of while */
   tcCb->data = (Void *)&(recpReqInfo); 
#else
   tcCb->data = (Void *)(recpReq); 
#endif /*TFU_UPGRADE*/

   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateRecpReq(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside expect tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateRecpReq(): invalid cmd in <tapa.expect>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   } /* end of while */
#ifdef TFU_UPGRADE
   if(0 != cmLListLen(&(recpReqInfo.ueRecpReqNdLst))) 
   {
      node = recpReqInfo.ueRecpReqNdLst.first;
      while(node)
      {
         tmp = node;
         node = node->next;
         cmLListDelFrm(&(recpReqInfo.ueRecpReqNdLst), tmp);
         rgAcUtlFreeMem ((Data *)tmp->node, sizeof(RgAcTfuUeRecpReqNode));
      }
   }
   if(0 != cmLListLen(&(recpReq->ueRecpReqLst))) 
   {
      node = recpReq->ueRecpReqLst.first;
      while(node)
      {
         tmp = node;
         node = node->next;
         cmLListDelFrm(&(recpReq->ueRecpReqLst), tmp);
      }
   }
#endif

   /* If we have gotten here then a perfect match is sure. */
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlValidateRecpReq */ 



 /** @brief This function checks if grant is to the power of 2/3 or 5.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE Bool rgAcUtlCheckNumRb
(
 U8      numRb
 )
#else
PRIVATE Bool rgAcUtlCheckNumRb (numRb)
 U8      numRb;
#endif
{
   while ((numRb % 2) == 0)
      numRb /= 2;
   while ((numRb % 3) == 0)
      numRb /= 3;
   while ((numRb % 5) == 0)
      numRb /= 5;
   if (numRb == 1)
      RETVALUE(TRUE);
   RETVALUE(FALSE);
} /* end of */ 




 /** @brief This function is used to validate if it is "time" for us to send
  * the primitive to MAC or not. What really we wish to do over here is that
  * we shall store the timing information of earlier messages received at the
  * PHY, and we shall generate responses/requests relative to that time, the
  * test case writer shall have to provide us with two inputs. 
  * 1. The message relative to which we have to send the current primitive -
  * this shall be a "useTime" index. 
  * 2. The offset of time "offset" 
  * e.g. 
  * <tapa.expect>
  *   <tapa.tfu.datreq saveTime="1"/>
  * </tapa.expect>
  *
  * <tapa.send>
  *   <tapa.tfu.harqfeedback useTime="1" offset="4"/>
  * </tapa.send>
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps: 
  *         - All this does is compare the current time with the expected
  *         time. 
  *            - If not the same we shall return CMXTA_ERR_PENDING hence
  *            forcing the test engine to loop around. 
  *            - If same we shall return CMXTA_ERR_NONE 
  *
  * @return CMXTA_ERR_PENDING / CMXTA_ERR_NONE
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlCheckTime 
(
 CmXtaTCCb      *tcCb,
 CmXtaSpCb      *spCb
 )
#else
PUBLIC S16 rgAcUtlCheckTime (tcCb, spCb)
 CmXtaTCCb      *tcCb;
 CmXtaSpCb      *spCb;
#endif
{
   U8    useTime;
   U8    offset;
   CmLteTimingInfo   futTime;
   CmLteTimingInfo   crntTime;

   TRC2(rgAcUtlCheckTime)

   useTime      = 0;
   offset   = 0;

   /* First step is to get the value of the "useTime" and "offset" from the XML */
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "useTime", &useTime);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "offset", &offset);
   if (useTime == 0)
      RETVALUE(CMXTA_ERR_NONE);
   /* A bit of a tricky stuff here, the offset is in terms of subframes only
    * what we really need to validate if the current time and the future time
    * specified by the test case writer are the same. 
    */
   /* Fill in the future time as follows - 
    * Add offset to the useTime
    * Fill in the crntTime as rgAcTfCb.crntTime.
    * Then compare.
    */
   RGADDTOCRNTTIME(rgAccCb.timeList[useTime], futTime, offset);
   RGCPYTIMEINFO(rgAcTfCb.crntTime, crntTime);

   /* if crnt System frame is less than the future System Frame the step has
    * to be delayed a bit
    */
   if (crntTime.sfn < futTime.sfn) 
      RETVALUE(CMXTA_ERR_PENDING);
   else 
   {
      /* crntSfn equals futSfn */
      if (crntTime.subframe < futTime.subframe)
         RETVALUE(CMXTA_ERR_PENDING);
      RETVALUE(CMXTA_ERR_NONE);
   }
} /* end of rgAcUtlCheckTime */ 

 /** @brief This function is used to get the current TC, used by all call back
  * functions 
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param 
  * @return tcCb pointer to CmXtaTCCb
  */
#ifdef ANSI
PUBLIC CmXtaTCCb * rgAcUtlFindTcCb 
(
 Void
 )
#else
PUBLIC CmXtaTCCb * rgAcUtlFindTcCb ()
#endif
{

   TRC2(rgAcUtlFindTcCb);
#ifdef CMXTA_EXTENSION
   if (cmXtaCb.curTCCb != NULLP)
      RETVALUE(cmXtaCb.curTCCb);
#else
   if ((cmXtaCb.curTCCb != NULLP)   &&
         (cmXtaCb.curTCCb->state != CMXTA_END_SHUTDOWN))
      RETVALUE(cmXtaCb.curTCCb);
#endif
   RETVALUE(NULLP);
} /* end of rgAcUtlFindTcCb */ 

 /** @brief This function is used to free up the Queue element saved earlier
  * to validate the received values.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  qElm pointer to CmXtaMsgQElm
  * @return ROK/RFAILED
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuFreeFunc 
(
 CmXtaMsgQElm  *qElm
 )
#else
PUBLIC S16 rgAcUtlTfuFreeFunc (qElm)
 CmXtaMsgQElm  *qElm;
#endif
{

   RgAccMsgQElm   *rgQElm;
   CmLList        *node;

   TRC2(rgAcUtlTfuFreeFunc)

   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuFreeFunc(): \n"));
   rgQElm = (RgAccMsgQElm *)qElm->data;
   if (rgQElm != NULLP)
   {
      if (EVTTFURECPREQ == rgQElm->u.tfuInfo.type) 
      {
         (Void)cmFreeMem((Ptr)rgQElm->u.tfuInfo.u.recpReqInfo);
         rgQElm->u.tfuInfo.u.recpReqInfo = NULLP;
      }
      if (EVTTFUCNTRLREQ == rgQElm->u.tfuInfo.type) 
      {
         (Void)cmFreeMem((Ptr)rgQElm->u.tfuInfo.u.cntrlReqInfo);
         rgQElm->u.tfuInfo.u.cntrlReqInfo = NULLP;
      }
      if (EVTTFUDATREQ == rgQElm->u.tfuInfo.type) 
      {
         node = rgQElm->u.tfuInfo.u.datReqInfo->pdus.first;
         while (node)
         {
            TfuDatReqPduInfo  *pdu = (TfuDatReqPduInfo*)node->node;
            SPutMsg(pdu->mBuf[0]);
            node = node->next;
         }
         if (rgQElm->u.tfuInfo.u.datReqInfo->bchDat.val)
         {
            SPutMsg(rgQElm->u.tfuInfo.u.datReqInfo->bchDat.val);
         }
         (Void)cmFreeMem((Ptr)rgQElm->u.tfuInfo.u.datReqInfo);
         rgQElm->u.tfuInfo.u.datReqInfo = NULLP;
      }

      CMXTA_FREE(rgQElm, sizeof (RgAccMsgQElm));
      qElm->data = NULLP;
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuFreeFunc */ 

#ifdef TFU_UPGRADE
 /** @brief This function validates the UL Grant given in the RA response and
  * the one received in Message 3, ideally all the fields must be the same.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  raRespUlGrant UL Grant in RA response
  * @param  msg3UlGrant UL Grant in Message 3 reception request
  * @return CMXTA_ERR_NONE/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlValidateUlGrant 
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuUePuschRecpReq *recpReq,
 U32                  lastUlGrant
 )
#else
PRIVATE S16 rgAcUtlValidateUlGrant (recpReq, lastUlGrant)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuUePuschRecpReq *recpReq;
 U32                  lastUlGrant;
#endif
{
   U32   mask;
   U16   byte;
   U32   assign;
   U8    rbStart; 
   U8    numRb;
   TfuModScheme modSchm;
   S16          ret;

   TRC2(rgAcUtlValidateUlGrant)

   mask = 523776;
   assign = lastUlGrant & mask;
   assign = assign >> 9;

   rgAcUtlCalcRivInfo (assign, rgAccCb.ulTotalBw, &rbStart, &numRb);
   if ((recpReq->ulSchInfo.numRb != numRb) || (recpReq->ulSchInfo.rbStart != rbStart))
      RETVALUE(CMXTA_ERR_NOMATCH);


   ret = cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rbStart",  &rbStart);
   if (ret == CMXTA_ERR_NONE)
   {
      if (recpReq->ulSchInfo.rbStart != rbStart)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateUlGrant(): rbStart mistmatch exp(%u) rcvd (%u)\n", 
                   rbStart, recpReq->ulSchInfo.rbStart));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }

   ret = cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "numRb",  &numRb);
   if (ret == CMXTA_ERR_NONE)
   {
      if (recpReq->ulSchInfo.numRb != numRb)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateUlGrant(): numRb mistmatch exp(%u) rcvd (%u)\n", 
                   numRb, recpReq->ulSchInfo.numRb));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }

   mask = 480;
   byte = lastUlGrant & mask;
   byte = byte >> 5;
   modSchm = (TfuModScheme)modTbsInxTbl[byte].qm;

   if ((recpReq->ulSchInfo.modType != modSchm))
      RETVALUE(CMXTA_ERR_NOMATCH);

   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlValidateUlGrant */ 
#else
 /** @brief This function validates the UL Grant given in the RA response and
  * the one received in Message 3, ideally all the fields must be the same.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  raRespUlGrant UL Grant in RA response
  * @param  msg3UlGrant UL Grant in Message 3 reception request
  * @return CMXTA_ERR_NONE/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlValidateUlGrant 
(
 TfuUeMsg3RecpReq    *recpReq,
 U32                  lastUlGrant
 )
#else
PRIVATE S16 rgAcUtlValidateUlGrant (recpReq, lastUlGrant)
 TfuUeMsg3RecpReq    *recpReq;
 U32                  lastUlGrant;
#endif
{
   U32   mask;
   U16   byte;
   U32   assign;
   U8    rbStart; 
   U8    numRb;

   TRC2(rgAcUtlValidateUlGrant)

   mask = 523776;
   assign = lastUlGrant & mask;
   assign = assign >> 9;

   rgAcUtlCalcRivInfo (assign, rgAccCb.ulTotalBw, &rbStart, &numRb);
   if ((recpReq->numRb != numRb) || (recpReq->rbStart != rbStart))
      RETVALUE(CMXTA_ERR_NOMATCH);

   mask = 480;
   byte = lastUlGrant & mask;
   byte = byte >> 5;
   if ((recpReq->mcs < 29) && (byte != recpReq->mcs))
      RETVALUE(CMXTA_ERR_NOMATCH);

   if (1)
   {
      TfuModScheme modSchm = (TfuModScheme)modTbsInxTbl[recpReq->mcs].qm; 
      U8 iTbs   = modTbsInxTbl[recpReq->mcs].iTbs;
      U16 tbs    = tbsTbl[iTbs][recpReq->numRb - 1]>>3;
      if ((recpReq->mcs < 29) && ((modSchm != recpReq->modType) || 
          (tbs != recpReq->size)))
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : \
                  mismatch tbs exp (%d) rcvd (%d):: \
                  mismatch qm exp(%d) rcvd(%d)\n",
                  tbs, recpReq->size,
                  modSchm, recpReq->modType));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlValidateUlGrant */ 
#endif

 /** @brief This function Allocates event memory using the memCp present in the
  * structures.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  ptr to be allocated
  * @param  size of the allocation
  * @return 
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlAllocEvnt 
(
 Data      **ptr,
 Size      size
)
#else
PUBLIC S16 rgAcUtlAllocEvnt (ptr, size)
 Data      **ptr;
 Size      size;
#endif
{
   Mem               evntMem;
   S16               ret;

   TRC2(rgAcUtlAllocEvnt);

   evntMem.region = DFLT_REGION;
   evntMem.pool   = DFLT_POOL;
   ret            = ROK;

   ret = cmAllocEvnt (size, 5000, &evntMem, (Ptr*)ptr);
   RETVALUE(ret);
} /* end of rgAcUtlAllocEvnt */ 


 /** @brief This function Allocates memory for all the rgac functions
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  ptr to be allocated
  * @param  size of the allocation
  * @return 
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlAllocMem 
(
 Data      **ptr,
 Size      size
)
#else
PUBLIC S16 rgAcUtlAllocMem (ptr, size)
 Data      **ptr;
 Size      size;
#endif
{
   SGetSBuf(DFLT_REGION, DFLT_POOL, ptr, size);
   RETVALUE(ROK);
} /* end of */ 

 /** @brief This function frees up event memory in the rgac files
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlFreeEvnt
(
 Data         *ptr
)
#else
PUBLIC S16 rgAcUtlFreeEvnt (ptr)
 Data         *ptr;
#endif
{
   (Void)cmFreeMem((Ptr)ptr);
   RETVALUE(ROK);
} /* end of */ 


 /** @brief This function frees up any memory in the rgac files
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PUBLIC S16 rgAcUtlFreeMem
(
 Data         *ptr,
 Size         size
)
#else
PUBLIC S16 rgAcUtlFreeMem (ptr, size)
 Data         *ptr;
 Size         size;
#endif
{

   SPutSBuf (DFLT_REGION, DFLT_POOL, ptr, size);
   RETVALUE(ROK);
} /* end of */ 

 /** @brief This function validates the timing information coming from MAC to
  * PHY. Ideally it should be the same as current time + TFU_DELTA
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlTfuValidateTiming
(
 RgAcTfuInfo      *tfuInfo
 )
#else
PRIVATE S16 rgAcUtlTfuValidateTiming (tfuInfo)
 RgAcTfuInfo      *tfuInfo;
#endif
{
   CmLteTimingInfo futTime;

   TRC2(rgAcUtlTfuValidateTiming);

/* 
 * Introduced timing deltas in FDD for DL control, DL data, 
 * Reception Request.
 */
#ifdef LTE_TDD
   RGADDTOCRNTTIME(rgAcTfCb.crntTime, futTime, TFU_DELTA);
#else
   switch (tfuInfo->type)
   {
      case EVTTFUDATREQ:
         RGADDTOCRNTTIME(rgAcTfCb.crntTime, futTime, TFU_DLDATA_DLDELTA);
         break;

      case EVTTFUCNTRLREQ:
         RGADDTOCRNTTIME(rgAcTfCb.crntTime, futTime, TFU_DLCNTRL_DLDELTA);
         break;

      case EVTTFURECPREQ:
         RGADDTOCRNTTIME(rgAcTfCb.crntTime, futTime, TFU_RECPREQ_DLDELTA);
         break;

      default:
         CMXTA_DBG_CALLIND((_cmxtap, "Info : Invalid Event rcvd (%d) \n",
                  tfuInfo->type), 3);
         RETVALUE(CMXTA_ERR_INT);
   }
#endif

   if (futTime.sfn != tfuInfo->timingInfo.sfn)
   {
      CMXTA_DBG_CALLIND((_cmxtap, "Info : Timing SFN mismatch rcvd (%d) exp (%d) \n",
                  tfuInfo->timingInfo.sfn, futTime.sfn), 3);
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   else if (futTime.subframe != tfuInfo->timingInfo.subframe)
   {
      CMXTA_DBG_CALLIND((_cmxtap, "Info : Timing subframe mismatch rcvd (%d) exp (%d) \n",
                  tfuInfo->timingInfo.subframe, futTime.subframe), 3);
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   else
      RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuValidateTiming */ 

 /** @brief This function calculates the rbStart and nmbRb from the given RIV
  * value.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE Void   rgAcUtlCalcRivInfo 
(
 U32     riv, 
 U8      bw, 
 U8      *rbStart, 
 U8      *numRb
 )
#else
PRIVATE Void   rgAcUtlCalcRivInfo(riv, bw, rbStart, numRb)
 U32     riv; 
 U8      bw; 
 U8      *rbStart; 
 U8      *numRb;
#endif
{
   U8 numRbMinus1;
   U8 rbSt;

   TRC2(rgAcUtlCalcRivInfo);

   numRbMinus1 = riv / bw;
   rbSt        = riv % bw;

   if (rbSt + numRbMinus1 >= bw)
   {
      numRbMinus1 = bw - numRbMinus1;
      rbSt = bw - rbSt - 1;
   }
   *rbStart = rbSt;
   *numRb = numRbMinus1 + 1;
   RETVOID;
}

 /** @brief This function validates the RAR Grant that goes out in the RAR
  * response. We check if it is a minimum of 80 bits. 
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlValidateRarGrant 
(
 U32           rarPdu,
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb
)
#else
PRIVATE S16 rgAcUtlValidateRarGrant  (rarPdu, tcCb, spCb)
 U32           rarPdu;
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
#endif
{

   U8                rbStart;
   U8                numRb;
   U32               mask;
   U16                mcs;
   U32               assign;
   U16               tbs;
   U8                iTbs;
   Bool              chkCqiReq;
   U8                cqiReq;

   TRC2(rgAcUtlValidateRarGrant);
   
   mask = 523776;
   assign = rarPdu & mask;
   assign = assign >> 9;

   mask = 480;
   mcs = rarPdu & mask;
   mcs = mcs >> 5;
   /* Changed value to 15 from 28 as msg3 mcs
    * is 4 bits as can be inferred from  36.213,section 6.2 */
   if (mcs > 15)
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateRarGrant() Error : Invalid MCS (%d) :\n",
               mcs));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   rgAcUtlCalcRivInfo (assign, rgAccCb.ulTotalBw, &rbStart, &numRb);
   iTbs        = modTbsInxTbl[mcs].iTbs;
   tbs        = tbsTbl[iTbs][numRb - 1];
   /* Check for RANDOM Access allocation a minimum of 56 bits must be allocated.
    * */
   if (tbs < 56)
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateRarGrant() Error : Grant given is less than 80 (%d) :\n",
               tbs));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }

   chkCqiReq = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkCqiReq", &chkCqiReq);

   if(chkCqiReq)
   {
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "cqiReq", &cqiReq);
      
      /* 1 bit in rar grant is used for cqi, please refer 
       * spec 36.321 section 6.2 */
      if(cqiReq != ((U8)(rarPdu & 1)))
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlValidateRarGrant() Error : Cqi mismatch in RAR grant exp(%d) rcvd(%d) :\n",
            cqiReq, (U8)(rarPdu & 1)));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }   
   RETVALUE(CMXTA_ERR_NONE);

} /* end of */ 

 /** @brief This function checks if the RNTI given by MAC is unique or not.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE Bool rgAcUtlMatchRnti
(
CmXtaTCCb *tcCb,
CmXtaSpCb *spCb,
U16      tmpRnti
)
#else
PRIVATE Bool rgAcUtlMatchRnti (tcCb, spCb, tmpRnti)
CmXtaTCCb *tcCb;
CmXtaSpCb *spCb;
U16       tmpRnti;
#endif
{
   U8    i;
   U8    poUeId=255;

   TRC2(rgAcUtlMatchRnti);

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "poUeId",  &poUeId);
   if ((poUeId != 255) )
   {
      if ((tmpRnti != poUeId)) {
         RETVALUE(TRUE);
      }
      else {
         RETVALUE(FALSE);
      }
   }
   /* The tempRnti given by MAC should be unique */
   for (i = 0; i < rgAccCb.nmbOfUes; i++)
   {
      if (rgAccCb.acUeCb[i].crnti == tmpRnti)
      {
         RETVALUE(TRUE);
      }
   }
   RETVALUE(FALSE);
} /* end of */ 

 /** @brief This function 
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlHandlePadding
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 RgAcEdEvent      *evnt,
 U16              tbs
 )
#else
PRIVATE S16 rgAcUtlHandlePadding (tcCb, spCb, evnt, tbs)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 RgAcEdEvent      *evnt;
 U16              tbs;
#endif
{
   U16               locTbs;
   S16               ret;

   TRC2(rgAcUtlHandlePadding);
   
   locTbs = (tbs/8);
   if ((locTbs == 1) || (locTbs == 2))
   {
      if ((ret = rgAcUtlInsertPadding (evnt, locTbs, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlHandlePadding(): Unable to add PADDING Header \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }
   else
   {
      /* We shall add padding to the end */

      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, tbs, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlHandlePadding(): Unable to add CCCH SDU \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   RETVALUE(ret);
} /* end of */ 

 /** @brief This function 
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE S16 rgAcUtlInsertPadding 
(
 RgAcEdEvent      *evnt, 
 U32              tbs,
 U8               lcId
 )
#else
PRIVATE S16 rgAcUtlInsertPadding (evnt, tbs, lcId)
 RgAcEdEvent      *evnt; 
 U32              tbs;
 U8               lcId;
#endif
{
   S16               ret;
   RgAcDatPdu        *datPdu;
   RgAcSubHeader     *subHdr;
   RgAcCEorSDU       *ce;
   U8                i;

   TRC2(rgAcUtlInsertPadding);

   datPdu = &(evnt->u.datPdu);

   /* Now we can allocate the specific header */
   for ( i = 0; i < tbs; i++)
   {
      if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcSubHeader), 
                  (Ptr *)&(subHdr))) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddHdrPduToEvnt(): resource error\n"));
         RETVALUE(ret);
      }
      subHdr->lcId = lcId;
      subHdr->type = RG_ACC_LAST_SUBHDR;
      subHdr->lnk.node = (PTR)subHdr;
      datPdu->subHdrs.crnt = datPdu->subHdrs.first;
      cmLListInsCrnt (&(datPdu->subHdrs), &(subHdr->lnk));
   }

   /* Now we can allocate the specific header */
   for ( i = 0; i < tbs; i++)
   {
      if ((ret = cmGetMem (&(evnt->memCp), sizeof(RgAcCEorSDU), 
                  (Ptr *)&(ce))) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlAddHdrPduToEvnt(): resource error\n"));
         RETVALUE(ret);
      }
      ce->isCE = FALSE;
      ce->lnk.node = (PTR)ce;
      datPdu->ceOrSdus.crnt = datPdu->ceOrSdus.first;
      cmLListInsCrnt (&(datPdu->ceOrSdus), &(ce->lnk));
   }
   RETVALUE(ROK);
} /* end of */ 

 /** @brief This function validates the PHICH information for a single UE.
  *
  * @details
  * Though it receives the whole control structure that contains a list of
  * PHICHs and PDCCHs, this handler would go through the list to find a best
  * match and report back the result. 
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of PHICHs. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  cntrlReq pointer to TfuCntrlReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidatePhich
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuCntrlReqInfo     *cntrlReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidatePhich (tcCb, spCb, cntrlReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuCntrlReqInfo     *cntrlReq;
#endif
{
   S16            ret;
   Bool           isAck;
   Bool           vldtRbStart;
   U8             ueId;
   RgAcUeCb       *ueCb;
   U8             rbStart;
   U8             nDmrs;
   U8             subframe;
   CmLList        *node;
   TfuPhichInfo   *phich;
#ifdef LTEMAC_SPS
   Bool           validateSpsDmrs=FALSE;
#endif

   TRC2(rgAcUtlTfuValidatePhich);
   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   isAck = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAck", &isAck);
   vldtRbStart = TRUE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtRbStart", &vldtRbStart);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);

   subframe = cntrlReq->ulTiming.subframe;
   /* we need to store rbstart from recpRequest such that subframe is
    * correctly calculated and is stored in the corresponding index. 
    */
   rbStart  = ueCb->rbStart[subframe];
   nDmrs    = ueCb->nDmrs[subframe];
#ifdef LTEMAC_SPS
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validateSpsDmrs", &validateSpsDmrs);
#endif
   /* Traverse the linked list looking for the best match for this */
   node = cntrlReq->phichLst.first;
   while (node)
   {
      phich = (TfuPhichInfo *)node->node;
#ifdef LTEMAC_SPS
      if(validateSpsDmrs)
      {
      if(phich->nDmrs != 0)
      {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePhich(): nDmrs mistmatch \n"));      }
      }
#endif
      if (vldtRbStart == TRUE)
      {
         if (
#ifndef LTE_TDD
            (phich->rbStart == rbStart) &&
#endif
               (phich->isAck == isAck))
         {
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      else
      {
         if (phich->isAck == isAck)
         {
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      node = node->next;
      } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePhich(): HARQ feedback mismatch \n"));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidatePhich */ 

 /** @brief This function validates the PDCCH information for a single UE.
  *
  * @details
  * Though it receives the whole control structure that contains a list of
  * PHICHs and PDCCHs, this handler would go through the list to find a best
  * match and report back the result. 
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of PDCCHs. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  cntrlReq pointer to TfuCntrlReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidatePdcch
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuCntrlReqInfo     *cntrlReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidatePdcch (tcCb, spCb, cntrlReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuCntrlReqInfo     *cntrlReq;
#endif
{
   S16            ret;
   Bool           isUlGrant;
   CmLList        *node;
   TfuPdcchInfo   *pdcch;
   U8             saveTo;
   CmLListCp      *lst;
   U8             cfi;
   Bool           isUlPdcchLst = FALSE; 

   TRC2(rgAcUtlTfuValidatePdcch);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   isUlGrant = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isUlGrant",  &isUlGrant);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isUlPdcchLst",  &isUlPdcchLst);
   
   /* Traverse the linked list UL or DL depending on the flag */
   ret = cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "cfi",  &cfi);
   if (ret == CMXTA_ERR_NONE)
   {
      /* Compare CFI */
      if (cntrlReq->cfi != cfi)
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlTfuValidatePdcch(): CFI validation failed exp (%u) recvd (%u)\n", cfi, cntrlReq->cfi));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   
   if ((isUlGrant == TRUE) || (isUlPdcchLst == TRUE))
      lst = &cntrlReq->ulPdcchLst;
   else 
      lst = &cntrlReq->dlPdcchLst;
   node = lst->first;
   while (node)
   {
      pdcch = (TfuPdcchInfo *)node->node;
      /* The timing information must be ul or dl */
      if ((ret = rgAcUtlCheckDci (tcCb, spCb, pdcch, 
                  (isUlGrant? cntrlReq->ulTiming: cntrlReq->dlTiming))) == CMXTA_ERR_NONE)
      {
#ifdef LTEMAC_HDFDD
         if ((ret = rgAcUtlTfuUtlVldtHdfddPDCCH (tcCb, spCb, 
                        cntrlReq)) != CMXTA_ERR_NONE)
         {
             CMXTA_DBG_ERR((_cmxtap,
                    "rgAcUtlTfuValidatePdcch(): HDFDD validation failed\n"));
             RETVALUE(CMXTA_ERR_NOMATCH);
         }
#endif
         /* copy this pdcch i.e. the successfully matched pdcch into the global
          * control block.
          */
         rgAccCb.savedMsgs[saveTo].u.pdcchInfo = *pdcch;
         /* Found the correct node - can return success */
         /* OPTIMIZE delete the node once we have a match. */
         cmLListDelFrm(lst, node);
         RETVALUE(CMXTA_ERR_NONE);
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdcch(): DCI Format validation failed\n"));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidatePdcch */ 

/*
-----------------------------------------------|------------|---------|-----------------------|-------------------------|-
     DCI 0/1A      (FDD)                       |     5MHz	|    10MHz|	        15MHz	      |           20MHz         |
-----------------------------------------------|------------|---------|------------|----------|------------|------------|-
			                                   |            |         |   < Rel 10 | >= Rel 10|	< Rel 10   | >= Rel 10  |
-----------------------------------------------|------------|---------|------------|----------|------------|------------|-
SCell added + UE Specific Search Space (PCell) |     25	    |    27	  |      27	   |    28 	  |       28   |         29 |
-----------------------------------------------|------------|---------|------------|----------|------------|------------|-
Common Search Space (PCell)	                   |     25	    |    27	  |            27	      |            28           |
-----------------------------------------------|------------|---------|---------------------- |-------------------------|-
UE Specific Search Space (PCell)	           |     25	    |    27	  |            27	      |            28           |
-----------------------------------------------|------------|---------|-----------------------|-------------------------|-
SCell without UL associated CC	               |     25	    |    27	  |            27	      |            28           |
-----------------------------------------------|------------|---------|-----------------------|-------------------------|-
*/

/*
-----------------------------------------------|------------|---------|----------|-----------------------|----------|
     DCI 0/1A      (TDD)                       |     5MHz	|    10MHz|    10MHz |	        15MHz	     |   20MHz  |
-----------------------------------------------|------------|---------|----------|------------|----------|----------|
			                                   |            |< Rel 10 | >= Rel 10|   < Rel 10 | >= Rel 10|	        |
-----------------------------------------------|------------|---------|----------|------------|----------|----------|
SCell added + UE Specific Search Space (PCell) |     27	    |    28	  |    29	 |      29	  |    30 	 |    30    |
-----------------------------------------------|------------|---------|----------|------------|----------|----------|
Common Search Space (PCell)	                   |     27	    |         28      	 |            29	     |    30    |
-----------------------------------------------|------------|--------------------|---------------------- |----------|
UE Specific Search Space (PCell)	           |     27	    |         28       	 |            29	     |    30    |
-----------------------------------------------|------------|--------------------|-----------------------|----------|
SCell without UL associated CC	               |     27	    |         28       	 |            29	     |    30    |
-----------------------------------------------|------------|--------------------|-----------------------|----------|
*/

#ifndef TFU_TDD
/* The above table is reduced to following (Only two variables, bandwidth and release) */
U8 rgAcDci01aSizeTbl[2][4] = {{25,27,27,28},  /* REL <  10 */
                           {25,27,28,29}}; /* REL >= 10 & SCELL ADDED & UE Specific Search Space */

U8 rgAcDci1SizeTbl[4] = {27,31,33,39};

U8 rgAcDci2SizeTbl[2][4] = {{39,43,45,51},  /* TX Antena Port 2 */
                           {42,46,48,54}};  /* TX Antena Port 4 */

U8 rgAcDci2aSizeTbl[2][4] = {{36,41,42,48},  /* TX Antena Port 2 */
                           {38,42,45,50}};  /* TX Antena Port 4 */

U8 rgAcDci3SizeTbl[4] = {13,14,14,14};
U8 rgAcDci3aSizeTbl[4] = {25,27,27,28};
#else
/* The above table is reduced to following (Only two variables, bandwidth and release) */
U8 rgAcDci01aSizeTbl[2][4] = {{27,29,30,31},  /* REL <  10 */
                           {27,29,30,31}}; /* REL >= 10 */

U8 rgAcDci1SizeTbl[4] = {30,34,36,42};

U8 rgAcDci2SizeTbl[2][4] = {{42,46,48,54},  /* TX Antena Port 2 */
                           {45,49,51,57}};  /* TX Antena Port 4 */

U8 rgAcDci2aSizeTbl[2][4] = {{39,43,45,51},  /* TX Antena Port 2 */
                           {41,45,47,53}};  /* TX Antena Port 4 */
U8 rgAcDci3SizeTbl[4] = {14,14,15,15};
U8 rgAcDci3aSizeTbl[4] = {27,28,29,30};
#endif

/** @brief This function checks a single PDCCH against the values passed in the
 * XML attributes
 *
 * @details
 * Is called from rgAcUtlTfuValidatePdcch
 *
 *     Function: 
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param pdcch pointer to TfuPdcchInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcUtlCheckDci 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch,
 CmLteTimingInfo timingInfo
)
#else
PRIVATE S16 rgAcUtlCheckDci (tcCb, spCb, pdcch, timingInfo)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuPdcchInfo  *pdcch;
 CmLteTimingInfo timingInfo;
#endif
{
   S16               ret;
   TfuPdcchInfo   *prevPdcchReq;
   TfuDciFormat0Info *format0;
   TfuDciFormat1aInfo *format1a;
   Bool              isUlGrant;
   Bool              vldtGrant;
   Bool              vldtTx;
   Bool              vldtRetx;
   Bool              vldtTpc;
   U8                vldtNprb;
   Bool              isFormat3;
   Bool              isFormat3a;
   Bool              vldtHqId;
   U8                chkTransId;
   Bool              vldtRbAlign;
   Bool              vldtAprdCqi;
   Bool              toggleNdi;
   U8                tpcCmd;
   U8                rcvdTpcCmd = 0;
   Bool              validateTpc = FALSE;
   Bool              vldtPO = FALSE;
   Bool              vldtMbr = FALSE;
   U32               ulMbr = 0;
   U8                ueId = 9;
   RgAcUeCb          *ueCb;
   U8                iTbs;
   U8                use = 0;
   U32               tbs;
   U32               rcvdTransId;
   U8                rbStart, numRb, rcvdRbStart, rcvdNumRb;
   U8                hqPId = 0;
   U8                prevHqPId = 0;
   U8                ndi = 0;
   U8                prevNdi = 0;
#ifdef LTEMAC_MIMO
   U8                ndi1 = 0;
   U8                ndi2 = 0;
   U8                prevNdi1 = 0;
   U8                prevNdi2 = 0;
   U8                chkPmi = 0;
   Bool              isChkPmi = FALSE;
   Bool              pmiCfm   = FALSE; /* It is used incase of TM6 */
   Bool              vldCWSwapFlag;
   Bool              vldDciFrmt = FALSE;
   Bool              cwSwapFlag = FALSE;
   Bool              tb1Pres= FALSE;
   Bool              tb2Pres= FALSE;
   Bool              prevTB1Pres= FALSE;
   Bool              prevTB2Pres= FALSE;
   Bool              isFormat1b;
   Bool              isFormat2;
   Bool              isFormat2a;  
   Bool              isFormat1a;
   Bool              isFormat1d;
   Bool              isFormat1;  
   Bool              isTb1Pres;
   Bool              isTb2Pres;
   U8                imcsTb[TFU_MAX_TB];
   U8                rvTb[TFU_MAX_TB]; 
   Bool              isTxAntSel;
   U8                txAntenna;
#endif
   Bool              vldRvIdx    = FALSE;
   Bool              vldImcs     = FALSE;
   Bool              vldaggrLvl  = FALSE;
   U8                rvIdx = 0;
   U8                iMcs = 0;
   U8                aggrLvl = 0;
   U8                raRnti;
   /* timing info sent to RLC by means of StaInd */
   CmLteTimingInfo   rlcTimingInfo;
   Bool              vldtDai = FALSE;
#ifdef LTEMAC_SPS
   Bool  chkFrmt1aRelPdcch    = FALSE;
   Bool  isSPSRetx            = FALSE;
   TfuPdcchInfo *PrevSPSPdcch = NULL;
   Bool  DLSPSInit            = FALSE;
   Bool  DLSPSReInit          = FALSE;
   Bool  ULSPSInit          = FALSE;
   Bool  ULSPSRel          = FALSE;
#endif
   U8    i;
   U8    num;
   U8    resAllocMap[4];  
   Bool  vldtResAllocMap;
#ifdef LTE_ADV
   Bool rel = FALSE, doNotCheckDciSize = FALSE;
   U8 bwIdx = 0, portIdx = 0, dciSize = 0;
#endif

   TRC2(rgAcUtlCheckDci)
      ret = CMXTA_ERR_NONE;

   isUlGrant = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isUlGrant", &isUlGrant);

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtPO", &vldtPO);
   vldtTpc = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtTpc", &vldtTpc);
   vldtNprb = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "vldtNprb", &vldtNprb);
   isFormat3 = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat3", &isFormat3);
   isFormat3a = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat3a", &isFormat3a);
   vldtGrant = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtGrant", &vldtGrant);

   vldtRbAlign = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtRbAlign", &vldtRbAlign);
   vldtTx = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtTx", &vldtTx);
   vldtRetx = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtRetx", &vldtRetx);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validateTpc", &validateTpc);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtDai", &vldtDai);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtMbr", &vldtMbr);
   toggleNdi = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "toggleNdi", &toggleNdi);
   vldtHqId = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtHqId", &vldtHqId);

   vldtAprdCqi = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtAprdCqi", &vldtAprdCqi);

   chkTransId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "chkTransId",  &chkTransId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   /* Set to invalid value */
   raRnti = RGACCSCH_MIN_MAC_RNTI;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "raRnti",  &raRnti);
   ueCb = &(rgAccCb.acUeCb[ueId]);
#ifdef LTEMAC_MIMO
   /* SET CWSwapFlag variable as TRUE in XML when you expect transSwap variable as TRUE in DCI 2/2A */
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldDciFrmt", &vldDciFrmt);
   vldCWSwapFlag = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldCWSwapFlag",
         &vldCWSwapFlag);  
   isFormat1b = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat1b",
         &isFormat1b);
   isFormat2 = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat2",
         &isFormat2);
   isFormat2a = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat2a", 
         &isFormat2a);
   isFormat1a = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat1a",
         &isFormat1a);
   isFormat1d = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat1d",
         &isFormat1d);
   isFormat1 = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFormat1", 
         &isFormat1);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isChkPmi", &isChkPmi);      
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "pmiCfm", &pmiCfm);      
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "chkPmi", &chkPmi);      
#endif
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldRvIdx", &vldRvIdx);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldImcs", &vldImcs);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldaggrLvl", &vldaggrLvl);

   if (pdcch->rnti <= RG_ACC_MAX_RARNTI)
   {
      raRnti = pdcch->rnti;
   }
   else if (ueId != 9)
   {
      if ((ueCb->crnti != pdcch->rnti) 
#ifdef LTEMAC_SPS
            && (ueCb->SPScrnti != pdcch->rnti)
#endif
            ) 
      {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): RNTI Mismatch exp (%d) rcvd (%d)\n", 
                     ueCb->crnti, pdcch->rnti));
            RETVALUE(CMXTA_ERR_NOMATCH);
      }
#ifdef LTE_ADV
      if ((ueCb->accessStratumRls < RGR_REL_10) || (rgAccCb.dlTotalBw < rgAccCb.ulTotalBw))
      {
         rel = FALSE;
      }
      else
      {
         rel = TRUE;
#ifndef TFU_TDD
         if ((pdcch->dci.dciFormat == TFU_DCI_FORMAT_1A) || (pdcch->dci.dciFormat == TFU_DCI_FORMAT_0))
         {
            doNotCheckDciSize = TRUE; /* Validate manually by passing dciSize as we can't validate 
                                         SCell added + UE Specific Search Space (PCell) from PDCCH 
                                         received. Thus have to pass dciSize manually from XML */
         }
#endif
      }
#endif
   }
   else
   {
      doNotCheckDciSize = TRUE;
   }
#ifdef LTE_ADV
   {
      if (rgAccCb.dlTotalBw == 25)
      {
         bwIdx = 0;
   }
      else if (rgAccCb.dlTotalBw == 50)
      {
         bwIdx = 1;
      }
      else if (rgAccCb.dlTotalBw == 75)
      {
         bwIdx = 2;
      }
      else if (rgAccCb.dlTotalBw == 100)
      {
         bwIdx = 3;
      }
      else
      {
         /* Donot Check the size */
         doNotCheckDciSize = TRUE;
      }
      if (rgAccCb.numTxAntPorts == 2)
      {
         portIdx = 0;
      }
      else if (rgAccCb.numTxAntPorts == 4)
      {
         portIdx = 1;
      }
      else if (rgAccCb.numTxAntPorts == 1)
      {
         /* Do Nothing */
      }
      else
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid numTxAntPorts configured (%u)\n", rgAccCb.numTxAntPorts));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (rgAccCb.dlTotalBw != rgAccCb.ulTotalBw)
      {
         /* Donot Check the size */
         doNotCheckDciSize = TRUE;
      }
   }
#endif


   switch (pdcch->dci.dciFormat)
   {
      case TFU_DCI_FORMAT_1A:
         {
            hqPId = pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val;
            ndi = pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.ndi;
            rcvdTpcCmd = pdcch->dci.u.format1aInfo.t.pdschInfo.tpcCmd;
            if (vldRvIdx)
            {
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvIdx",  &rvIdx);
               if (rvIdx != pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.rv)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rvIdx Mismatch exp (%d) rcvd (%d)\n", 
                        rvIdx, pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.rv));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (vldImcs)
            {
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "iMcs",  &iMcs);
               if (iMcs != pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.mcs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): MCS Mismatch exp (%d) rcvd (%d)\n", 
                        iMcs, pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.mcs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (vldaggrLvl)
            {
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "aggrLvl",  &aggrLvl);
               if (aggrLvl != pdcch->aggrLvl)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): aggrLvl Mismatch exp (%d) rcvd (%d)\n", 
                        aggrLvl, pdcch->aggrLvl));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
#ifdef LTE_ADV
            dciSize = rgAcDci01aSizeTbl[rel][bwIdx];
#endif
            break;
         }
      case TFU_DCI_FORMAT_1:
         {
            hqPId = pdcch->dci.u.format1Info.allocInfo.harqProcId;
            ndi = pdcch->dci.u.format1Info.allocInfo.ndi;
            rcvdTpcCmd = pdcch->dci.u.format1Info.tpcCmd;
            if (vldRvIdx)
            {
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvIdx",  &rvIdx);
               if (rvIdx != pdcch->dci.u.format1Info.allocInfo.rv)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rvIdx Mismatch exp (%d) rcvd (%d)\n", 
                        rvIdx, pdcch->dci.u.format1Info.allocInfo.rv));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (vldImcs)
            {
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "iMcs",  &iMcs);
               if (iMcs !=  pdcch->dci.u.format1Info.allocInfo.mcs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): MCS Mismatch exp (%d) rcvd (%d)\n", 
                        iMcs,  pdcch->dci.u.format1Info.allocInfo.mcs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            vldtResAllocMap = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtResAllocMap",
                  &vldtResAllocMap);
            if(vldtResAllocMap)
            {
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
                     "resAllocMap", resAllocMap, &num);

               if(pdcch->dci.u.format1Info.allocInfo.isAllocType0)
               {   
                  for(i = 0; i < num; i++)
                  {
                     if(pdcch->dci.u.format1Info.allocInfo.resAllocMap[i] !=
                           resAllocMap[i])
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): resAllocMap validation Failed)\n"));
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }   
                  }
               }   
            }    
#ifdef LTE_ADV
            dciSize = rgAcDci1SizeTbl[bwIdx];
#endif  
            break;
         }
#ifdef LTEMAC_MIMO 
      case TFU_DCI_FORMAT_1B:
         {
            hqPId = pdcch->dci.u.format1bInfo.allocInfo.harqProcId;
            ndi = pdcch->dci.u.format1bInfo.allocInfo.ndi;
            break;
         }
      case TFU_DCI_FORMAT_2:
         {
            U32 resMap = 0;
            hqPId = pdcch->dci.u.format2Info.allocInfo.harqProcId;
            /* A TB is disabled if mcs = 0 and rvidx = 1*/
            if ((pdcch->dci.u.format2Info.allocInfo.tbInfo[0].mcs != 0) ||
                  (pdcch->dci.u.format2Info.allocInfo.tbInfo[0].rv != 1))
            {
               tb1Pres = TRUE;
               ndi1 = pdcch->dci.u.format2Info.allocInfo.tbInfo[0].ndi;
            }
            if ((pdcch->dci.u.format2Info.allocInfo.tbInfo[1].mcs != 0) ||
                  (pdcch->dci.u.format2Info.allocInfo.tbInfo[1].rv != 1))
            {   
               tb2Pres = TRUE;
               ndi2 = pdcch->dci.u.format2Info.allocInfo.tbInfo[1].ndi;
            }
            if (vldCWSwapFlag == TRUE)
            {
               cwSwapFlag = pdcch->dci.u.format2Info.allocInfo.transSwap;
            }
#ifdef LTE_ADV
            dciSize = rgAcDci2SizeTbl[portIdx][bwIdx];
#endif  
            vldtResAllocMap = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtResAllocMap",
                  &vldtResAllocMap);
            if(vldtResAllocMap)
            {
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
                     "resAllocMap", resAllocMap, &num);

               if(pdcch->dci.u.format2Info.allocInfo.isAllocType0)
               {   
                  for(i = 0; i < num; i++)
                  {
                     if(pdcch->dci.u.format2Info.allocInfo.resAllocMap[i] !=
                           resAllocMap[i])
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): resAllocMap validation Failed"
                                " exp(%d) rcvd(%d) at Index(%d)\n", resAllocMap[i], 
                                pdcch->dci.u.format2AInfo.allocInfo.resAllocMap[i], i));
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }   
                  }
               }   
            }    
            break;
         }  
      case TFU_DCI_FORMAT_2A:
         {
            hqPId = pdcch->dci.u.format2AInfo.allocInfo.harqProcId;
            /* A TB is disabled if mcs = 0 and rvidx = 1*/
            if ((pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].mcs != 0) ||
                 (pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].rv != 1))
            {   
               tb1Pres = TRUE;
               ndi1 = pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].ndi;
            }
            if ((pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].mcs != 0) ||
               (pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].rv != 1))
            {   
               tb2Pres = TRUE;
               ndi2 = pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].ndi;
            }                              
            if (vldCWSwapFlag == TRUE)
            {
               cwSwapFlag = pdcch->dci.u.format2AInfo.allocInfo.transSwap;
            }

            vldtResAllocMap = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtResAllocMap",
                  &vldtResAllocMap);
            if(vldtResAllocMap)
            {
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
                     "resAllocMap", resAllocMap, &num);

               if(pdcch->dci.u.format2AInfo.allocInfo.isAllocType0)
               {   
                  for(i = 0; i < num; i++)
                  {
                     if(pdcch->dci.u.format2AInfo.allocInfo.resAllocMap[i] !=
                           resAllocMap[i])
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): resAllocMap validation Failed"
                                " exp(%d) rcvd(%d) at Index(%d)\n", resAllocMap[i], 
                                pdcch->dci.u.format2AInfo.allocInfo.resAllocMap[i], i));
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }   
                  }
               }   
            }    
#ifdef LTE_ADV
            dciSize = rgAcDci2aSizeTbl[portIdx][bwIdx];
#endif  
            break;
         } 
#endif  
      case TFU_DCI_FORMAT_0:
         {
#ifdef LTE_ADV
            dciSize = rgAcDci01aSizeTbl[rel][bwIdx];
#endif  
            break;
         }
      case TFU_DCI_FORMAT_3:
         {
#ifdef LTE_ADV
            dciSize = rgAcDci3SizeTbl[bwIdx];
#endif  
            break;
         }
      case TFU_DCI_FORMAT_3A:
         {
#ifdef LTE_ADV
            dciSize = rgAcDci3aSizeTbl[bwIdx];
#endif  
             break;
         }
      default:
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid new DCI format %d\n",
                     pdcch->dci.dciFormat));
            break;
         }
   }
#ifdef LTE_ADV
   ret = cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "dciSize", &dciSize);
   if (ret != CMXTA_ERR_NO_VALUE)
   {
      doNotCheckDciSize = FALSE; /* Mandatorily check DCI Size */
   }
   if ((pdcch->dciNumOfBits != dciSize) && (doNotCheckDciSize == FALSE))
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI SIZE Mismatch for UE [%u] format (%u) exp (%u) rcvd (%u)\n", 
               ueCb->crnti, pdcch->dci.dciFormat, dciSize, pdcch->dciNumOfBits));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
#endif
#ifdef LTEMAC_MIMO
   if (isFormat1b)
   {
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_1B)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mismatch exp (%d) rcvd (%d)\n",
                   TFU_DCI_FORMAT_1B, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (isChkPmi)
      {
         if (chkPmi != pdcch->dci.u.format1bInfo.allocInfo.tPmi)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): PMI mistmatch exp (%d) rcvd (%d)\n",
                      chkPmi, pdcch->dci.u.format1bInfo.allocInfo.tPmi));
            RETVALUE(CMXTA_ERR_NOMATCH);  
         }
         if (pmiCfm != pdcch->dci.u.format1bInfo.allocInfo. pmiCfm)
         {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci():  pmiCfm mistmatch exp (%d) rcvd (%d)\n",
                          pmiCfm, pdcch->dci.u.format1bInfo.allocInfo. pmiCfm));
               RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
   }
   else if (isFormat2) 
   {
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_2)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                    TFU_DCI_FORMAT_2, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (isChkPmi)
      {
         if (chkPmi != pdcch->dci.u.format2Info.allocInfo.precoding)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): PMI mistmatch exp (%d) \
                     rcvd (%d)\n", chkPmi, pdcch->dci.u.format2Info.allocInfo. \
                         precoding));
              RETVALUE(CMXTA_ERR_NOMATCH); 
         }
      }
      isTb1Pres = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1Pres",
                                        &isTb1Pres);
      if (isTb1Pres)
      {
         if (vldtGrant)
         {         
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "imcsTb0",
                               &imcsTb[0]);
            if (imcsTb[0] != pdcch->dci.u.format2Info.allocInfo.tbInfo[0].mcs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): mcs mistmatch for TB1 \
                        exp (%d) rcvd (%d)\n", imcsTb[0], pdcch->dci.u.format2Info. \
                           allocInfo.tbInfo[0].mcs));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }  
            rvTb[0] = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvTb0",
                               &rvTb[0]);
            if (rvTb[0] != pdcch->dci.u.format2Info.allocInfo.tbInfo[0].rv)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rv mistmatch for TB1 \
                        exp (%d) rcvd (%d)\n", rvTb[0], pdcch->dci.u.format2Info. \
                           allocInfo.tbInfo[0].rv));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }
         }
         if ((pdcch->dci.u.format2Info.allocInfo.tbInfo[0].rv == 1) && 
               (pdcch->dci.u.format2Info.allocInfo.tbInfo[0].mcs == 0))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid values of\
                     rv (%d) and mcs (%d) for TB1",pdcch->dci.u.format2Info. \
                        allocInfo.tbInfo[0].rv,pdcch->dci.u.format2Info. \
                           allocInfo.tbInfo[0].mcs));
            RETVALUE(CMXTA_ERR_NOMATCH);  
         }
      }
      isTb2Pres = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb2Pres",
                                        &isTb2Pres);
      if (isTb2Pres)
      {
         if (vldtGrant)
         { 
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "imcsTb1",
                               &imcsTb[1]);
            if (imcsTb[1] != pdcch->dci.u.format2Info.allocInfo.tbInfo[1].mcs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): mcs mistmatchi for TB2\
                        exp (%d) rcvd (%d)\n", imcsTb[1], pdcch->dci.u.format2Info. \
                           allocInfo.tbInfo[1].mcs));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }  
            rvTb[1] = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvTb1",
                               &rvTb[1]);
            if (rvTb[1] != pdcch->dci.u.format2Info.allocInfo.tbInfo[1].rv)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rv mistmatch for TB2\
                        exp (%d) rcvd (%d)\n", rvTb[1], pdcch->dci.u.format2Info. \
                            allocInfo.tbInfo[1].rv));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }
         }
         if ((pdcch->dci.u.format2Info.allocInfo.tbInfo[1].rv == 1) && 
               (pdcch->dci.u.format2Info.allocInfo.tbInfo[1].mcs == 0))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid values of rv (%d)\
               and mcs (%d) for TB2",pdcch->dci.u.format2Info.allocInfo. \
                  tbInfo[1].rv,pdcch->dci.u.format2Info.allocInfo. \
                     tbInfo[1].mcs));
            RETVALUE(CMXTA_ERR_NOMATCH);  
         }
      }
   }
   else if (isFormat2a)
   {
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_2A)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                     TFU_DCI_FORMAT_2A, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (isChkPmi)
      {
         if (chkPmi != pdcch->dci.u.format2AInfo.allocInfo.precoding)
         {
             CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): PMI mistmatch exp (%d) rcvd (%d)\n",
                      chkPmi, pdcch->dci.u.format2AInfo.allocInfo.precoding));
             RETVALUE(CMXTA_ERR_NOMATCH); 
         }
      }
      isTb1Pres = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1Pres",
                                       &isTb1Pres);
      if (isTb1Pres)
      {
         if (vldtGrant)
         {
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "imcsTb0",
                              &imcsTb[0]);
            if (imcsTb[0] != pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].mcs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): mcs mistmatch for TB1\
                       exp (%d) rcvd (%d)\n", imcsTb[0], pdcch->dci.u.format2AInfo. \
                          allocInfo.tbInfo[0].mcs));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvTb0",
                              &rvTb[0]);
            if (rvTb[0] != pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].rv)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rv mistmatch for TB1\
                       exp (%d) rcvd (%d)\n", rvTb[0], pdcch->dci.u.format2AInfo. \
                          allocInfo.tbInfo[0].rv));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }
         if ((pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].rv == 1) && 
               (pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].mcs == 0))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid values of rv (%d) and\
                    mcs (%d) for TB1",pdcch->dci.u.format2AInfo.allocInfo. \
                      tbInfo[0].rv,pdcch->dci.u.format2AInfo.allocInfo. \
                              tbInfo[0].mcs));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
      isTb2Pres = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb2Pres",
                                       &isTb2Pres);
      if (isTb2Pres)
      {
         if (vldtGrant)
         {
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "imcsTb1",
                               &imcsTb[1]);
            if (imcsTb[1] != pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].mcs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): mcs mistmatchi for TB2\
                       exp (%d) rcvd (%d)\n", imcsTb[1], pdcch->dci.u.format2AInfo. \
                          allocInfo.tbInfo[1].mcs));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }  
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rvTb1",
                               &rvTb[1]);
            if (rvTb[1] != pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].rv)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rv mistmatch for TB2\
                        exp (%d) rcvd (%d)\n", rvTb[1], pdcch->dci.u.format2AInfo. \
                            allocInfo.tbInfo[1].rv));
               RETVALUE(CMXTA_ERR_NOMATCH);  
            }  
         }
         if ((pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].rv == 1) && 
              (pdcch->dci.u.format2AInfo.allocInfo.tbInfo[1].mcs == 0))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid values of rv and\
                    mcs for TB2"));
            RETVALUE(CMXTA_ERR_NOMATCH);  
         }
      }
   }
   else if (vldDciFrmt)
   {
      if (isFormat1a && pdcch->dci.dciFormat != TFU_DCI_FORMAT_1A)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                     TFU_DCI_FORMAT_1A, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (isFormat1 && pdcch->dci.dciFormat != TFU_DCI_FORMAT_1)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                     TFU_DCI_FORMAT_1, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   else if (isFormat1d)
   {
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_1D)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                     TFU_DCI_FORMAT_1D, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   if (vldCWSwapFlag)
   {
      if (cwSwapFlag != TRUE)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): cwSwapFlag is  mistmatch exp (%d) rcvd (%d) \n",
                 TRUE,pdcch->dci.u.format2AInfo.allocInfo.transSwap));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
#endif
   if (use != 0)
   {
      prevPdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
      switch (prevPdcchReq->dci.dciFormat)
      {
         case TFU_DCI_FORMAT_1A:
            {
               prevHqPId = prevPdcchReq->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val;
               prevNdi = prevPdcchReq->dci.u.format1aInfo.t.pdschInfo.allocInfo.ndi;
               break;
            }
         case TFU_DCI_FORMAT_1:
            {
               prevHqPId = prevPdcchReq->dci.u.format1Info.allocInfo.harqProcId;
               prevNdi = prevPdcchReq->dci.u.format1Info.allocInfo.ndi;
               break;
            }
#ifdef LTEMAC_MIMO 
         case TFU_DCI_FORMAT_1B:
            {
               prevHqPId = prevPdcchReq->dci.u.format1bInfo.allocInfo.harqProcId;
               prevNdi = prevPdcchReq->dci.u.format1bInfo.allocInfo.ndi;
               break;
            }
         case TFU_DCI_FORMAT_2:
            {
               prevHqPId = prevPdcchReq->dci.u.format2Info.allocInfo.harqProcId;
               /* A TB is disabled if mcs = 0 and rvidx = 1*/
               if ((prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[0].mcs != 0) ||
                    (prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[0].rv != 1))
               {
                  prevTB1Pres = TRUE;
                  prevNdi1 = prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[0].ndi;
               }
               if ((prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[1].mcs != 0) ||
                    (prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[1].rv != 1))
               {
                  prevTB2Pres = TRUE;
                  prevNdi2 = prevPdcchReq->dci.u.format2Info.allocInfo.tbInfo[1].ndi;
               }
               break;
            }
         case TFU_DCI_FORMAT_2A:
            {
               prevHqPId = prevPdcchReq->dci.u.format2AInfo.allocInfo.harqProcId;
                /* A TB is disabled if mcs = 0 and rvidx = 1*/
               if ((prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[0].mcs != 0) ||
                 (prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[0].rv != 1))
               {
                  prevTB1Pres = TRUE;
                  prevNdi1 = prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[0].ndi;
               }
               if ((prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[1].mcs != 0) ||
                  (prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[1].rv != 1))
               {
                  prevTB2Pres = TRUE;
                  prevNdi2 = prevPdcchReq->dci.u.format2AInfo.allocInfo.tbInfo[1].ndi;
               }               
               break;
            }
#endif
         default:
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid old DCI format %d\n",
                        pdcch->dci.dciFormat));
               break;
            }
      }
      if (vldtHqId == TRUE)
      {
         if (hqPId != prevHqPId)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): HARQ ID mismatch exp (%d) rcvd (%d) \n",
                     prevHqPId, hqPId));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
      if (toggleNdi == TRUE)
      {
#ifndef LTEMAC_MIMO      
         if ((ndi == prevNdi))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI not toggled \n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
#else 
         switch (pdcch->dci.dciFormat)
         {
            case TFU_DCI_FORMAT_1B:
            {
               if (ndi == prevNdi)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI not toggled \n"));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
               break;
            }
            case TFU_DCI_FORMAT_2:
            {
               if ((tb1Pres == TRUE) && (prevTB1Pres == TRUE))
               {
                  if (ndi1 == prevNdi1)
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI is not toggled for TB1\n"));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
               }
               if ((tb2Pres == TRUE) && (prevTB2Pres == TRUE))
               {
                  if (ndi2 == prevNdi2)
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI is not toggled for TB2\n"));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
               }   
               break;
            }
            case TFU_DCI_FORMAT_2A:
            {
               if ((tb1Pres == TRUE) && (prevTB1Pres == TRUE))
               {
                  if (ndi1 == prevNdi1)
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI is not toggled for TB1\n"));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
               }
               if ((tb2Pres == TRUE) && (prevTB2Pres == TRUE))
               {
                  if (ndi2 == prevNdi2)
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI is not toggled for TB2\n"));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
               }
               break;
            }
            default:
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Invalid DCI format %d\n",
                        pdcch->dci.dciFormat));
               break;
            }
         }
#endif
      }
      if (vldtRetx == TRUE)
      {
         if (ndi != prevNdi)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): NDI incorrect for Re-Tx\n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
   }
   if (chkTransId != 0)
   {
      rcvdTransId = 0;
      /*
         rcvdTransId |= timingInfo.sfn;
         rcvdTransId = rcvdTransId << 8;
         rcvdTransId |= timingInfo.subframe;
         rcvdTransId = rcvdTransId << 8;
         */
      /* tbindex consideration for MIMO */
      /* Introduced timing delta for DL control in FDD */
#ifdef LTE_TDD
      RGSUBFRMCRNTTIME(timingInfo, rlcTimingInfo, TFU_DELTA);
#else
      RGSUBFRMCRNTTIME(timingInfo, rlcTimingInfo, TFU_DLCNTRL_DLDELTA);
#endif
      rcvdTransId |= (rlcTimingInfo.sfn << 16)|(rlcTimingInfo.subframe << 8)|((hqPId<<2)|1);
      if (rcvdTransId != rgAccCb.transId[chkTransId])
      {
#ifndef ALIGN_64BIT
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): TransId mismatch exp (%ld) rcvd (%ld) \n",
                  rgAccCb.transId[chkTransId], rcvdTransId));
#else
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): TransId mismatch exp (%d) rcvd (%d) \n",
                  rgAccCb.transId[chkTransId], rcvdTransId));
#endif
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }

   /* Nprb indication at PHY for common Ch */
   if (vldtNprb != 0)
   {
      if (rcvdTpcCmd != vldtNprb - 2)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): nPrb column mistmatch exp(%d) rcvd (%d)\n", 
                   vldtNprb, rcvdTpcCmd+2));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   numRb = 0;
   rbStart = 0;
   ret = cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rbStart",  &rbStart);
   if ((ret == CMXTA_ERR_NONE) && (pdcch->dci.dciFormat == TFU_DCI_FORMAT_0))
   {
      if (pdcch->dci.u.format0Info.rbStart != rbStart)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): rbStart mistmatch exp(%u) rcvd (%u)\n", 
                   rbStart, pdcch->dci.u.format0Info.rbStart));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   ret = CMXTA_ERR_NONE;

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "numRb",  &numRb);
   if (vldtRbAlign == TRUE)
   {
      rcvdRbStart = 0;
      rcvdNumRb   = 0;
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_1A) 
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp 1A rcvd (%d)\n", 
                   pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.alloc.type 
            != TFU_ALLOC_TYPE_RIV)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Alloc Type not RIV\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      rgAcUtlCalcRivInfo (pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.alloc.u.riv, 
            rgAccCb.dlTotalBw, &rcvdRbStart, &rcvdNumRb);
      /* chk if this validation is needed */
      if ((rcvdRbStart != rbStart) || (rcvdNumRb != numRb))
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): RB Alignment Failed \
            rcvdRbStart(%d):expdRbStart(%d) rcvdNumRb(%d):numRb(%d)\n", 
            rcvdRbStart, rbStart, rcvdNumRb, numRb));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   
   if (vldtPO == TRUE)
   {
      U32 poRapId = 0;
      U32 prachMaskIdx = 0;
      Bool isPdcchOrder;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, "poRapId",  &poRapId);
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, "prachMaskIdx",  &prachMaskIdx);
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_1A)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n", 
                  0, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      format1a = &(pdcch->dci.u.format1aInfo);
      isPdcchOrder = format1a->isPdcchOrder;
      if ((isPdcchOrder == FALSE) ||
            (poRapId != format1a->t.pdcchOrder.preambleIdx) ||
            (prachMaskIdx != format1a->t.pdcchOrder.prachMaskIdx) )
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): pdcch isn't for pdcch order \
         expected: rapId=%d, mskIdx=%d., rcvd:rapId=%d, mskIdx=%d, isPdcchOdr=%d,\
         \n", (int)poRapId, (int)prachMaskIdx,format1a->t.pdcchOrder.preambleIdx, \
         format1a->t.pdcchOrder.prachMaskIdx, isPdcchOrder));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   /*Added support for SPS*/
#ifdef LTEMAC_SPS
   chkFrmt1aRelPdcch = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkFrmt1aRelPdcch", &chkFrmt1aRelPdcch);
   if (chkFrmt1aRelPdcch == TRUE) 
   {
      ret = rgAcUtlCheckDciFrmt1aRelPdcch(tcCb,spCb,pdcch);
      if(ret!=CMXTA_ERR_NONE)
      {
         RETVALUE(ret);
      }
   }

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "DLSPSInit", &DLSPSInit);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "DLSPSReInit",&DLSPSReInit);
   if(!(DLSPSInit||DLSPSReInit))
   {
      isSPSRetx = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSPSRetx", &isSPSRetx);

      if(isSPSRetx && use != 0)
      {
         if (ueCb->SPScrnti != pdcch->rnti )
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Missmatch  in the RNTI value : Expected = %x Recieved  %x \n", ueCb->crnti, pdcch->rnti));
         }
         PrevSPSPdcch = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
         switch(pdcch->dci.dciFormat)
         {
            case TFU_DCI_FORMAT_1:
               if (pdcch->dci.u.format1Info.allocInfo.harqProcId != 
               PrevSPSPdcch->dci.u.format1Info.allocInfo.harqProcId)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID HARQ Process Id Expected = %d Recieved %d \n",PrevSPSPdcch->dci.u.format1Info.allocInfo.harqProcId, pdcch->dci.u.format1Info.allocInfo.harqProcId ));
               }
               break;
            case TFU_DCI_FORMAT_1A:
               if (pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val!= 
               PrevSPSPdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID HARQ Process Id Expected = %d Recieved %d \n",PrevSPSPdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val, pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val ));
               }
               break;
            case TFU_DCI_FORMAT_2:
               if (pdcch->dci.u.format2Info.allocInfo.harqProcId != 
               PrevSPSPdcch->dci.u.format2Info.allocInfo.harqProcId)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
                  INVALID HARQ Process Id Expected = %d Recieved \
                  %d \n",PrevSPSPdcch->dci.u.format2Info.allocInfo.harqProcId,
                  pdcch->dci.u.format2Info.allocInfo.harqProcId));
               }
               break;
            case TFU_DCI_FORMAT_2A:
               if (pdcch->dci.u.format2AInfo.allocInfo.harqProcId!= 
               PrevSPSPdcch->dci.u.format2AInfo.allocInfo.harqProcId)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
                  INVALID HARQ Process Id Expected = %d Recieved \
                  %d \n",PrevSPSPdcch->dci.u.format2AInfo.allocInfo.harqProcId,
                  pdcch->dci.u.format2AInfo.allocInfo.harqProcId));
               }
               break;
            default: /* ERROR*/
            CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckDci():\
            INVALID dci format in SPS "));
         } /*end of switch*/
      }
   }
   else
   { 
      /*do same int the Validate Dci Format */
      switch(pdcch->dci.dciFormat)
      {
         case TFU_DCI_FORMAT_1:
            if(pdcch->dci.u.format1Info.allocInfo.ndi!= 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID NDI \
               Expected = 0 Recieved  1 \n"));
            }
            if (pdcch->dci.u.format1Info.allocInfo.harqProcId != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID HARQ Process Id Expected = 0 Recieved \
               %d \n",pdcch->dci.u.format1Info.allocInfo.harqProcId ));
            }
            if ((pdcch->dci.u.format1Info.allocInfo.mcs>>4) != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
            }
            if (pdcch->dci.u.format1Info.allocInfo.rv != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
            }
            break;
         case TFU_DCI_FORMAT_1A:
            if(pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.ndi != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID NDI \
               Expected = 0 Recieved  1 \n"));
            }
            if (pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val!= 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID HARQ Process Id Expected = 0 Recieved \
               %d \n",pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.harqProcId.val ));
            }
            if ((pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.mcs>>4) != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
            }
            if (pdcch->dci.u.format1aInfo.t.pdschInfo.allocInfo.rv != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
            }
            break;
         case TFU_DCI_FORMAT_2:
            if(pdcch->dci.u.format2Info.allocInfo.tbInfo[0].ndi != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID NDI \
               Expected = 0 Recieved  1 \n"));
            }
            if (pdcch->dci.u.format2Info.allocInfo.harqProcId != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID HARQ Process Id Expected = 0 Recieved \
               %d \n",pdcch->dci.u.format2Info.allocInfo.harqProcId));
            }
            if ((pdcch->dci.u.format2Info.allocInfo.tbInfo[0].mcs>>4) != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
            }
            if (pdcch->dci.u.format2Info.allocInfo.tbInfo[0].rv != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
            }
            break;
         case TFU_DCI_FORMAT_2A:
            if(pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].ndi != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): INVALID NDI \
               Expected = 0 Recieved  1 \n"));
            }
            if (pdcch->dci.u.format2AInfo.allocInfo.harqProcId!= 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID HARQ Process Id Expected = 0 Recieved \
               %d \n",pdcch->dci.u.format2AInfo.allocInfo.harqProcId));
            }
            if ((pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].mcs>>4) != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
            }
            if (pdcch->dci.u.format2AInfo.allocInfo.tbInfo[0].rv  != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
               INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
            }
            break;
         default: /* ERROR*/
            CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckDci():\
            INVALID dci format in SPS "));
      } /*end of switch*/
   } /*if (chkGrant)*/

#endif
   if (isUlGrant == TRUE)
   {
      U8 cqiReq = 0;
      U8 numCqiBit = 0;
      if (pdcch->dci.dciFormat != TFU_DCI_FORMAT_0)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n", 
                  0, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      format0 = &(pdcch->dci.u.format0Info);
#ifdef LTEMAC_SPS
      ULSPSInit = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "ULSPSInit", &ULSPSInit);
      ULSPSRel = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "ULSPSRel", &ULSPSRel);
      isSPSRetx = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSPSRetx", &isSPSRetx);
      if(ULSPSInit || ULSPSRel)
      {
         if (ueCb->SPScrnti != pdcch->rnti) 
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): SPS rnti mismatch exp (%d) rcvd (%d)\n", 
                     ueCb->SPScrnti, pdcch->rnti));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if(format0->tpcCmd != 0)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): TPC CMD mistmatch exp (%d) rcvd (%d)\n", 
                     0, format0->tpcCmd));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if(format0->nDmrs != 0)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): nDmrs mistmatch exp (%d) rcvd (%d)\n", 
                     0, format0->nDmrs));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if(ULSPSInit)
         {
            if ((format0->mcs>>4) != 0)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): \
                        INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
            }
/*
            if (ueCb->ulPacketSize!= 0)
            {
               tbs    = ueRecpReq->t.puschRecpReq.ulSchInfo.size * 8;
               if (ueCb->ulPacketSize > tbs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci() Error : Grant mismatch  exp (%d) rcvd (%d):\n", 
                           ueCb->ulPacketSize, tbs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }--*/
            if (ueCb->ulPacketSize != 0)
            {
               iTbs   = modTbsInxTbl[format0->mcs].iTbs;
               tbs    = tbsTbl[iTbs][format0->numRb - 1];
               if (ueCb->ulPacketSize > tbs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci() Error : Grant mismatch  exp (%d) rcvd (%d):\n", 
                           (int)ueCb->ulPacketSize, (int)tbs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
         }
         else
         {
            if(format0->mcs != 0x1f )
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): mcs mistmatch exp 0x(%x) rcvd 0x(%x)\n", 
                        31, format0->mcs));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
#ifdef TFU_UPGRADE
            if(format0->riv != 0xffffffff)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): riv mistmatch exp 0xffffffff  rcvd 0x(%x)\n", (int)format0->riv));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }


#endif

         }
      }
      else if(isSPSRetx)
      {
         if (ueCb->SPScrnti != pdcch->rnti) 
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): SPS rnti mismatch exp (%d) rcvd (%d)\n", 
                     ueCb->crnti, pdcch->rnti));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if (pdcch->dci.u.format0Info.ndi != 1) 
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): ndi mismatch exp 1 rcvd 0\n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
#endif
      cqiReq = 0;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "cqiReq", &cqiReq);
      if (cqiReq != format0->cqiReq)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdcch():cqiReq mismatch exp(%d) rcvd(%d)\n", 
                  cqiReq, format0->cqiReq));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
#ifdef LTE_ADV
      Bool chkCqiBit = FALSE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkCqiBit", &chkCqiBit);
      if (chkCqiBit)
      {
         numCqiBit = 0;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "numCqiBit", &numCqiBit);
         if (numCqiBit != format0->numCqiBit)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdcch():numCqiBit mismatch exp(%d) rcvd(%d)\n", 
                     numCqiBit, format0->numCqiBit));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
#endif
#ifdef LTEMAC_MIMO      
      isTxAntSel = FALSE;      
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTxAntSel", &isTxAntSel);
      if (isTxAntSel)
      {
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "txAntenna", &txAntenna);
         if (txAntenna != format0->txAntenna)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdcch():txAntenna mismatch exp(%d) rcvd(%d)\n", 
                     txAntenna, format0->txAntenna));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
#endif
      if (vldtGrant == TRUE)
      {
         /* Added validation for DAI */
#ifdef TFU_TDD
         if (vldtDai)
         {
            U8   dai = 4;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "dai", &dai);
            if (dai != format0->dai)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DAI mistmatch "
               "exp (%d) rcvd (%d)\n", dai, format0->dai));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }
#endif
         if (validateTpc)
         {
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "tpcCmd", &tpcCmd);
            if (tpcCmd != format0->tpcCmd)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): TPC CMD mistmatch exp (%d) rcvd (%d)\n", 
                        tpcCmd, format0->tpcCmd));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }
#ifdef LTEMAC_SPS
      if(!ULSPSRel)
      {
#endif
         if (rgAcUtlCheckNumRb (format0->numRb) == FALSE)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Grant is not a multiple of 2, 3, or 5 \n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if (numRb != 0)
         {
            if ((numRb != format0->numRb) || (rbStart != format0->rbStart))
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci():  numRb mismatch exp (%d) rcvd (%d)\n", 
                        numRb, format0->numRb));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }
#ifdef LTEMAC_SPS
      }  
#endif
      }
      /* duration is to be determined and properly given by tester */
      if (vldtMbr == TRUE)
      {
         format0 = &(pdcch->dci.u.format0Info);
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U32, "ulMbr",
               &ulMbr);
         iTbs       = modTbsInxTbl[format0->mcs].iTbs;
         tbs        = tbsTbl[iTbs][format0->numRb - 1];
         ueCb->ulGrantRcvd += tbs;
         if (ueCb->ulGrantRcvd > (ulMbr *8))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Grant has exceeded UlMbr \n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      } /* end of MBR validation */

      if (vldtTx == TRUE)
      {
         if (format0->mcs > 28)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Incorrect MCS for new Trans IMCS (%d).\n",
                     format0->mcs));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }

      if (vldtAprdCqi)
      {
         if (format0->cqiReq != 1)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Incorrect CQI bit for UL grant %d\n",
                     format0->cqiReq));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
      if (vldtTpc == TRUE)
      {
         ret = rgAcUtlCheckDciPuschTpc (tcCb, spCb, pdcch);
         if (ret != CMXTA_ERR_NONE)
         {
            RETVALUE(ret);
         }
      }
   }
   else if (isFormat3 || isFormat3a)
   {
      if (isFormat3 && pdcch->dci.dciFormat != TFU_DCI_FORMAT_3)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                  TFU_DCI_FORMAT_3, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      else if (isFormat3a && pdcch->dci.dciFormat != TFU_DCI_FORMAT_3A)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DCI format mistmatch exp (%d) rcvd (%d)\n",
                  TFU_DCI_FORMAT_3A, pdcch->dci.dciFormat));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if (vldtGrant)
      {
         ret = rgAcUtlCheckDciForGrpPwr (tcCb, spCb, pdcch, isFormat3a);
         if (ret != CMXTA_ERR_NONE)
         {
            RETVALUE(ret);
         }
      }
   }
   else
   {
         /* Added validation for DAI */
#ifdef TFU_TDD
         if (vldtDai)
         {
            U8   dai = 1;
            U8   pdcchDai = 255;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "dai", &dai);
            switch(pdcch->dci.dciFormat)
            {
               case TFU_DCI_FORMAT_1:
                  pdcchDai = pdcch->dci.u.format1Info.dai;
                  break; 
               case TFU_DCI_FORMAT_1A:
                  pdcchDai = pdcch->dci.u.format1aInfo.t.pdschInfo.dai.val; 
                  break; 
               case TFU_DCI_FORMAT_2:
                  pdcchDai = pdcch->dci.u.format2Info.dai; 
                  break; 
               case TFU_DCI_FORMAT_2A:
                  pdcchDai = pdcch->dci.u.format2AInfo.dai; 
                  break;
               default: 
                  break;
            }
            if (dai != pdcchDai)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): DAI mistmatch "
               "exp (%d) rcvd (%d)\n", dai, pdcchDai));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }
#endif
 
      if (vldtTpc == TRUE)
      {
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "tpcCmd", &tpcCmd);
         if (rcvdTpcCmd != tpcCmd)
         {
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
      }
   }
   RETVALUE(ret);
} /* end of rgAcUtlCheckDci */ 

#ifndef TFU_UPGRADE
 /** @brief This function validates the reception request for HARQ feedback on
  * PUCCH.
  *
  * @details
  * This is the lower-level handler and just validates the HARQ reception
  * request on PUCCH.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateHqRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateHqRecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{ 
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   TfuUePucchRecpReq    *pucchRecpReq;
   U8                   ueId;
   U8                   saveTo;
   Bool                 isRepeating;
   U16                  n1Pucch;
   RgAcUeCb             *ueCb;

   TRC2(rgAcUtlTfuValidateHqRecpReq);
   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   isRepeating = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isRepeating", &isRepeating);
   n1Pucch = 1001;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "n1PucchAnRep", &n1Pucch);
   node = recpReq->ueRecpReqLst.first;
   while (node)
   {
     ueRecpReq = (TfuUeRecpReqInfo *)node->node;
      if ((ueRecpReq->rnti == ueCb->crnti) && 
            (ueRecpReq->type == TFU_RECP_REQ_PUCCH)
#ifdef LTEMAC_SPS 
            || ((ueRecpReq->rnti == ueCb->SPScrnti) && 
               (ueRecpReq->type == TFU_RECP_REQ_PUCCH))
#endif
             )
      {

         pucchRecpReq = &(ueRecpReq->t.pucchRecpReq);
#ifdef TFU_TDD
         {
            Bool vldtNp = FALSE;
            U8 np=0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtNp", 
                                            &vldtNp);
            if (vldtNp == TRUE)
            {
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "np", &np);
               if (np != pucchRecpReq->p[0])
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                     " Np value mismatch exp(%d) rcvd(%d) \n",
                     np, pucchRecpReq->p[0]));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
         }
#endif         

         if (((isRepeating) &&
               (pucchRecpReq->hqType == TFU_HQ_RECP_REQ_N1PUCCH) &&
               (pucchRecpReq->t.n1Pucch == n1Pucch)) ||
               ((!isRepeating) && 
               (pucchRecpReq->hqType == TFU_HQ_RECP_REQ_NORMAL)) ||
         ((!isRepeating) &&
                 (pucchRecpReq->hqType == TFU_HQ_RECP_REQ_N1PUCCH))) 
         {
            /* copy this pdcch i.e. the successfully matched pdcch into the global
             * control block.
             */
            rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            cmLListDelFrm(&recpReq->ueRecpReqLst, node);
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateHqRecpReq */ 

#else

 /** @brief This function validates the reception request for HARQ feedback on
  * PUCCH.
  *
  * @details
  * This is the lower-level handler and just validates the HARQ reception
  * request on PUCCH.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateHqRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateHqRecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   TfuUePucchRecpReq    *pucchRecpReq;

   TfuUePuschRecpReq    *puschRecpReq;

   U8                   ueId;
   U8                   saveTo;
   Bool                 isRepeating;
   U16                  n1PucchAnRep;
   RgAcUeCb             *ueCb;
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   Bool isAMatch = FALSE;
   U16                  n1Pucch = 0;
   Bool                 vldtPucchRb;
   U8                   rb1,rb2;

   TRC2(rgAcUtlTfuValidateHqRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   isRepeating = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isRepeating", &isRepeating);
   n1PucchAnRep = 1001;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "n1PucchAnRep", &n1PucchAnRep);
   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;
   while (node)
   {
      recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
      ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
      if(!(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUCCH_HARQ) &&  
         !(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUSCH_HARQ))
      {
         if(node->next != NULLP)
         {
            node = node->next;
            continue;
         }
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq() Error :Received Recp is not of PUCCH HARQ type\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

      if ((ueRecpReq->rnti == ueCb->crnti) 
#ifdef LTEMAC_SPS
            || (ueRecpReq->rnti == ueCb->SPScrnti)
#endif
         )
      {
         if (ueRecpReq->type == TFU_RECP_REQ_PUCCH)
         {
            pucchRecpReq = &(ueRecpReq->t.pucchRecpReq);
//suhas - #ifndef TFU_TDD
#ifdef LTE_ADV
            U8 vldtPucchRsrc1B = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                  "validate1B", &vldtPucchRsrc1B);
            if(vldtPucchRsrc1B ==TRUE)
            {
               U8 scellPdcchSavedIdx = 255;
               U8 tpc                = 255;
               U8 scellResIdx        = 255;
               TfuPdcchInfo   *sCellPdcch;


               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                     "scellResIdx", &scellResIdx);
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                     "useScellPdcchIdx", &scellPdcchSavedIdx);
               if (scellPdcchSavedIdx != 255)
               {
                  sCellPdcch = &rgAccCb.savedMsgs[scellPdcchSavedIdx].u.pdcchInfo;
                  if (TFU_DCI_FORMAT_1A == sCellPdcch->dci.dciFormat) 
                  {
                     tpc = sCellPdcch->dci.u.format1aInfo.t.pdschInfo.tpcCmd; 
                  }
                  else if (TFU_DCI_FORMAT_2A == sCellPdcch->dci.dciFormat)
                  {
                     tpc = sCellPdcch->dci.u.format2Info.tpcCmd;
                  }
                  else
                  {
                     tpc = 255;
                  }

                  if ((tpc < 4) && (scellResIdx < 4))
                  {
                     U8 isScell2ndTbValid = FALSE;
                     cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                           "isScell2ndTbValid", &isScell2ndTbValid);
                     if ((ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx] != ueCb->sCellAckN1ResCfg.sCellAckN1ResTb1[tpc]) &&
                         (ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx] != 65535))
                     {
                        /*Validation failed for PUCCH resource idx*/
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                                 " PUCCH resrc idx validation failed, value mismatch "
                                 "exp(%d) rcvd(%d) \n",
                                 (ueCb->sCellAckN1ResCfg.sCellAckN1ResTb1[tpc]), 
                                 (ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx])));
                        RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                              recpReq, recpReqInfo);
                        RETVALUE(CMXTA_ERR_NOMATCH);

                     }
                     if ((isScell2ndTbValid && (ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx+1] != ueCb->sCellAckN1ResCfg.sCellAckN1ResTb2[tpc])) &&
                         (ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx+1] != 65535))
                     {
                        /*Validation failed for PUCCH resource idx*/
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                                 " PUCCH resrc idx validation failed, value mismatch "
                                 "exp(%d) rcvd(%d) \n",
                                 (ueCb->sCellAckN1ResCfg.sCellAckN1ResTb2[tpc]), 
                                 (ueRecpReq->t.pucchRecpReq.hqInfo.hqRes[scellResIdx + 1])));
                        RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                              recpReq, recpReqInfo);
                        RETVALUE(CMXTA_ERR_NOMATCH);

                     }
                  }
                  else
                  {
                     //INVALID TPC INDEX
                  }
               }
               else
               {
                  //INVALID PDCCH IDX
               }
            }
#endif
//suhas - #endif
            {
               U8 vldtPucchRsrc=FALSE;
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                     "vldtPucchRsrc", &vldtPucchRsrc);
               if(vldtPucchRsrc==TRUE)
               {
#ifndef TFU_TDD
                  U8 pdcchSavedIdx =1;
                  TfuPdcchInfo   *pdcch;
                  cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                        "pdcchSavedIdx", &pdcchSavedIdx);
                  pdcch = &rgAccCb.savedMsgs[pdcchSavedIdx].u.pdcchInfo;
                  if((pdcch->nCce + rgAccCb.n1PucchAn) != 
                        pucchRecpReq->hqInfo.hqRes[0])
                  {
                     /*Validation failed for PUCCH resource idx*/
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                              " PUCCH resrc idx validation failed, value mismatch "
                              "exp(%d) rcvd(%d) \n",
                              (pdcch->nCce + rgAccCb.n1PucchAn), 
                              pucchRecpReq->hqInfo.hqRes[0]));
                     RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                           recpReq, recpReqInfo);
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
#else
                  U8  M, m = 0;
                  U8  nP, nPPlus1;
                  U8  idx, idx1; 
                  U8 pdcchSavedIdx[9]={0};
                  U16 np[4] = {0};
                  TfuPdcchInfo   *pdcch;
                  U8  noFdbks, pucchResCnt, pdcchIdxCnt;

                  cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                        CMXTA_SEP_COLON, "pdcchIdxs", pdcchSavedIdx, 
                        &pdcchIdxCnt); 
                  cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                        "noFdbks", &noFdbks);
                  cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                        "pucchResCnt", &pucchResCnt);
                  M = noFdbks;
                  if(noFdbks != pucchRecpReq->hqInfo.hqSz) 
                  {
                     /*Validation failed for PUCCH resource idx*/
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                              " PUCCH noFdbks value mismatch "
                              "exp(%d) rcvd(%d) \n",
                              noFdbks, pucchRecpReq->hqInfo.hqSz));
                     RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                           recpReq, recpReqInfo);
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
                  if(pucchResCnt != pucchRecpReq->hqInfo.pucchResCnt) 
                  {
                     /*Validation failed for PUCCH resource idx*/
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                              " PUCCH pucchResCnt value mismatch "
                              "exp(%d) rcvd(%d) \n",
                              pucchResCnt , pucchRecpReq->hqInfo.pucchResCnt));
                     RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                           recpReq, recpReqInfo);
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
                  /*Calculate np values*/
                  for(idx = 1;idx < 4;idx++)
                  {
                     /*np[0] will be 0*/
                     np[idx] = rgAccCb.dlTotalBw*(idx*12-4);
                     np[idx] /= 36; 
                  }
                  for(idx = 0;idx < pucchResCnt;idx++)
                  {
                     m= idx; 
                     /*Find the value of P for this resource */
                     pdcch = &rgAccCb.savedMsgs[pdcchSavedIdx[idx]].u.pdcchInfo;
                     for(idx1 = 1;idx1 < 4;idx1++)
                     {
                        if(pdcch->nCce < np[idx1]) 
                        { 
                           nP = idx1-1;
                           nPPlus1 = idx1;
                           break;
                        }
                     } 
                     n1Pucch = (M-m-1)* np[nP]+ (m* np[nPPlus1]) + pdcch->nCce + 
                        rgAccCb.n1PucchAn;
                     if(n1Pucch != pucchRecpReq->hqInfo.hqRes[idx])  
                     {
                        /*Validation failed for PUCCH resource idx*/
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                                 " PUCCH pucchRest value mismatch "
                                 "exp(%d) rcvd(%d), idx(%d) \n",
                                 n1Pucch , pucchRecpReq->hqInfo.hqRes[idx], idx));
                        RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                              recpReq, recpReqInfo);
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }
                  }
#endif
               }    
            }   
            vldtPucchRb=TRUE;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtPucchRb", 
                  &vldtPucchRb);
            if(vldtPucchRb==TRUE)
            {
               U8 c =3;     
               U8 shift = (c * rgAccCb.nCsAn/rgAccCb.deltaPucchShift); 
               U8 mVal;
#ifdef TFU_TDD 
               if(TFU_ACK_NACK_BUNDLING == pucchRecpReq->hqInfo.hqFdbkMode)
               {
                  n1Pucch = pucchRecpReq->hqInfo.hqRes[0];
               }
               else
               { /* TODO */
               }        
#else
               n1Pucch = pucchRecpReq->hqInfo.hqRes[0];
#endif                                

               c    = (rgAccCb.cp)?3:2;
               mVal = n1Pucch < shift ? rgAccCb.n2RB : ((n1Pucch - shift)/
                     (c * 12/rgAccCb.deltaPucchShift) + rgAccCb.n2RB + (rgAccCb.nCsAn + 7)/8);

               rb1 = mVal/2;
               rb2 = rgAccCb.ulTotalBw - 1 - rb1;

               if(rgAccCb.ulRbMap[rb1] == RGAC_RB_BUSY || 
                     rgAccCb.ulRbMap[rb2] == RGAC_RB_BUSY) 
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): "
                           " PUCCH RB overlap with PUSCH \n "));

                  RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, 
                        recpReq, recpReqInfo);

                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (isRepeating)
            {
#ifndef TFU_TDD
               if(n1PucchAnRep == pucchRecpReq->hqInfo.hqRes[0])
#else
                  if((TFU_ACK_NACK_BUNDLING == pucchRecpReq->hqInfo.hqFdbkMode) &&
                        (n1PucchAnRep == pucchRecpReq->hqInfo.hqRes[0]))
#endif
                  {
                     isAMatch = TRUE;
                  }
                  else
                  {
                     isAMatch = FALSE;
                  }
            }
            else
            {
               isAMatch = TRUE;
            }
         }
         else
         {
            isAMatch = TRUE;
            puschRecpReq = &(ueRecpReq->t.puschRecpReq);
            if(rgAccCb.acUeCb[ueId].puschDedCfg.bACKIdx != puschRecpReq->hqInfo.hqBetaOff)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq() Error : hqBetaOff mismatch exp (%d) rcvd (%d):\n", \
                        rgAccCb.acUeCb[ueId].puschDedCfg.bACKIdx ,puschRecpReq->hqInfo.hqBetaOff));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }

         if(isAMatch)
         {
            /* copy this pdcch i.e. the successfully matched pdcch into the global
             * control block.
             */
            rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_HARQ, recpReqNd, recpReq, recpReqInfo);
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateHqRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateHqRecpReq */ 

#endif

#ifdef TFU_UPGRADE
/** @brief This function validates the reception request for DLCQI on
  * PUCCH/PUSCH.
  *
  * @details
  * This is the lower-level handler and just validates the DLCQI reception
  * request on PUCCH/PUSCH.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateDlCqiRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateDlCqiRecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   TfuUePucchRecpReq    *pucchRecpReq;

   TfuUePuschRecpReq    *puschRecpReq;

   U8                   ueId;
   U8                   saveTo;
   U16                  n2PucchIdx;
   U8                   cqiPmiSz;
   RgAcUeCb             *ueCb;
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   Bool isAMatch = FALSE;
   Bool vldtPucchRsrc;
   Bool vldtCqiPmiSz;
   U8 pdcchSavedIdx;
   TfuUeRecpReqInfo   *ueRecpInfo;
   TRC2(rgAcUtlTfuValidateDlCqiRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   n2PucchIdx = 500;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "n2PucchIdx", &n2PucchIdx);
   cqiPmiSz = 4;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "cqiPmiSz",  &cqiPmiSz);
   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;
   while (node)
   {
      recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
      ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
      if(!(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUCCH_CQI) &&  
         !(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUSCH_CQI))
      {
         if(node->next != NULLP)
         {
            node = node->next;
            continue;
         }
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq() Error :Received Recp is not of PUCCH CQI type\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

     if (ueRecpReq->rnti == ueCb->crnti) 
     {
        if (ueRecpReq->type == TFU_RECP_REQ_PUCCH)
         {
            pucchRecpReq = &(ueRecpReq->t.pucchRecpReq);

            pdcchSavedIdx =1;

            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                            "pdcchSavedIdx", &pdcchSavedIdx);

            vldtPucchRsrc=FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                            "vldtPucchRsrc", &vldtPucchRsrc);
            if(vldtPucchRsrc==TRUE)
            {
               ueRecpInfo = &rgAccCb.savedMsgs[pdcchSavedIdx].u.ueRecpReqInfo;
               if(n2PucchIdx != pucchRecpReq->cqiInfo.n2PucchIdx)
               {
                  /*Validation failed for PUCCH resource idx*/
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq(): "
                  " PUCCH resrc idx validation failed, value mismatch "
                  "exp(%d) rcvd(%d) \n",
                  n2PucchIdx, pucchRecpReq->cqiInfo.n2PucchIdx));
                  RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_CQI, recpReqNd, 
                                              recpReq, recpReqInfo);
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }    

            vldtCqiPmiSz=FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                            "vldtCqiPmiSz", &vldtCqiPmiSz);
            if(vldtCqiPmiSz==TRUE)
            {
               ueRecpInfo = &rgAccCb.savedMsgs[pdcchSavedIdx].u.ueRecpReqInfo;
               if(cqiPmiSz != pucchRecpReq->cqiInfo.cqiPmiSz)
               {
                  /*Validation failed for PUCCH resource idx*/
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq(): "
                  " CqiPmi Size validation failed, value mismatch "
                  "exp(%d) rcvd(%d) \n",
                  cqiPmiSz, pucchRecpReq->cqiInfo.cqiPmiSz));
                  RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_CQI, recpReqNd, 
                                              recpReq, recpReqInfo);
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }   
         isAMatch = TRUE;
         }
         else /*TODO*/
         {
            isAMatch = TRUE;
            puschRecpReq = &(ueRecpReq->t.puschRecpReq);
            if(puschRecpReq->cqiRiInfo.riSz[0].pres)
            {
            if(rgAccCb.acUeCb[ueId].puschDedCfg.bRIIdx!= puschRecpReq->cqiRiInfo.riBetaOff)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq() Error : riBetaOff mismatch exp (%d) rcvd (%d):\n", \
               rgAccCb.acUeCb[ueId].puschDedCfg.bRIIdx, puschRecpReq->cqiRiInfo.riBetaOff));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            }
            else
            {
            if(rgAccCb.acUeCb[ueId].puschDedCfg.bCQIIdx!= puschRecpReq->cqiRiInfo.cqiBetaOff)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq() Error : cqiBetaOff mismatch exp (%d) rcvd (%d):\n", \
               rgAccCb.acUeCb[ueId].puschDedCfg.bCQIIdx, puschRecpReq->cqiRiInfo.cqiBetaOff));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            }
         }

     if(isAMatch)
      {
         rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
         /* Found the correct node - can return success */
         /* OPTIMIZE delete the node once we have a match. */
         if (ueRecpReq->type == TFU_RECP_REQ_PUCCH)
         {
            RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_CQI, recpReqNd, recpReq, recpReqInfo);
         }
         else
         {
            RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUSCH_CQI, recpReqNd, recpReq, recpReqInfo);
         }
         RETVALUE(CMXTA_ERR_NONE);
      }
  }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateDlCqiRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateDlCqiRecpReq */

/** @brief This function validates the reception request for SR on
  * PUCCH.
  *
  * @details
  * This is the lower-level handler and just validates the SR reception
  * request on PUCCH.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateSrRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateSrRecpReq (tcCb, spCb, recpReq)
   CmXtaTCCb           *tcCb;
   CmXtaSpCb           *spCb;
   TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   TfuUePucchRecpReq    *pucchRecpReq;

   U8                   ueId;
   U8                   saveTo;
   U16                  n1PucchIdx;
   RgAcUeCb             *ueCb;
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   Bool isAMatch = FALSE;
   Bool vldtPucchRsrc;
   U8 pdcchSavedIdx;
   TfuUeRecpReqInfo   *ueRecpInfo;
   TRC2(rgAcUtlTfuValidateSrRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   n1PucchIdx = 45;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "n1PucchIdx", &n1PucchIdx);
   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;
   while (node)
   {
      recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
      ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
      if(!(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUCCH_SR))
      {
         if(node->next != NULLP)
         {
            node = node->next;
            continue;
         }
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateSrRecpReq() Error :Received Recp is not of PUCCH SR type\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

      if (ueRecpReq->rnti == ueCb->crnti) 
      {
         pucchRecpReq = &(ueRecpReq->t.pucchRecpReq);
         vldtPucchRsrc=FALSE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
               "vldtPucchRsrc", &vldtPucchRsrc);
         if(vldtPucchRsrc==TRUE)
         {
            pdcchSavedIdx =1;

            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "pdcchSavedIdx", &pdcchSavedIdx);
            ueRecpInfo = &rgAccCb.savedMsgs[pdcchSavedIdx].u.ueRecpReqInfo;
            if((rgAccCb.n1PucchAn) !=  
                  pucchRecpReq->srInfo.n1PucchIdx)
            {
               /*Validation failed for PUCCH resource idx*/
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateSrRecpReq(): "
                        " PUCCH resrc idx validation failed, value mismatch "
                        "exp(%d) rcvd(%d) \n",
                        (rgAccCb.n1PucchAn), 
                        pucchRecpReq->srInfo.n1PucchIdx));
               RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_SR, recpReqNd, 
                     recpReq, recpReqInfo);
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
         }    
         isAMatch = TRUE;


         if(isAMatch)
         {
            rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_SR, recpReqNd, recpReq, recpReqInfo);
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateSrRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateSrRecpReq */ 

/** @brief This function validates the reception request for SRS.
  *
  * @details
  * This is the lower-level handler and just validates the SRS reception
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateSrsRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateSrsRecpReq (tcCb, spCb, recpReq)
   CmXtaTCCb           *tcCb;
   CmXtaSpCb           *spCb;
   TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   TfuUePucchRecpReq    *pucchRecpReq;

   U8                   ueId;
   U8                   saveTo;
   RgAcUeCb             *ueCb;
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   Bool isAMatch = FALSE;
   Bool vldtSrsInfo;
   U8 pdcchSavedIdx;
   TfuUeRecpReqInfo   *ueRecpInfo;
   TRC2(rgAcUtlTfuValidateSrsRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);

   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;
   while (node)
   {
      recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
      ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
      if(!(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUCCH_SRS) &&  
         !(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUSCH_SRS))
      {
         if(node->next != NULLP)
         {
            node = node->next;
            continue;
         }
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateSrsRecpReq() Error :Received Recp is not of PUCCH SRS type\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

      if (ueRecpReq->rnti == ueCb->crnti) 
      {
         pucchRecpReq = &(ueRecpReq->t.pucchRecpReq);
         vldtSrsInfo=FALSE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
               "vldtSrsInfo", &vldtSrsInfo);
         if(vldtSrsInfo==TRUE)
         {
            pdcchSavedIdx =1;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "pdcchSavedIdx", &pdcchSavedIdx);
            ueRecpInfo = &rgAccCb.savedMsgs[pdcchSavedIdx].u.ueRecpReqInfo;
         }    
         isAMatch = TRUE;

         if(isAMatch)
         {
            rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
            /* Found the correct node - can return success */
            /* OPTIMIZE delete the node once we have a match. */
            RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUCCH_SRS, recpReqNd, recpReq, recpReqInfo);
            RETVALUE(CMXTA_ERR_NONE);
         }
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateSrsRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateSrRecpReq */ 

#endif 


#ifndef TFU_UPGRADE
 /** @brief This function validates the reception request for MSG3 of the RACH
  * procedure
  *
  * @details
  * This is the lower-level handler and just validates the MSG3 reception
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateMsg3RecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateMsg3RecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   U8                   ueId;
   U8                   use;
   U8                   saveTo;
   RgAcUeCb             *ueCb;
   Bool                 validate, vldtAdptRetx;
   TfuPdcchInfo         *pdcchReq;
   U8                   iTbs;
   U16                  tbs;
#ifdef TFU_UPGRADE
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
#endif

   TRC2(rgAcUtlTfuValidateMsg3RecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   validate = TRUE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validate", &validate);
   vldtAdptRetx = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtAdptRetx", &vldtAdptRetx);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   use = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   node = recpReq->ueRecpReqLst.first;
   while (node)
   {
      ueRecpReq = (TfuUeRecpReqInfo *)node->node;
      ueCb->rbStart[((recpReq->timingInfo.subframe + 4) % 10)] = ueRecpReq->t.msg3RecpReq.rbStart;
      ueCb->nDmrs[((recpReq->timingInfo.subframe + 4) % 10)] = 0;

      if ( (((ueRecpReq->rnti == ueCb->crnti) || (validate == FALSE)) && 
            (ueRecpReq->type == TFU_RECP_REQ_MSG3)))
      {
         if (vldtAdptRetx)
         {
            /* Pick up the corresponding Format 0 */
            pdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
            if (pdcchReq->dci.u.format0Info.rbStart != ueRecpReq->t.msg3RecpReq.rbStart)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq() Error : Grant mismatch rbStart exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.rbStart, ueRecpReq->t.msg3RecpReq.rbStart));
               break;
            }
            if (pdcchReq->dci.u.format0Info.numRb != ueRecpReq->t.msg3RecpReq.numRb)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq() Error : Grant mismatch numRb exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.numRb, ueRecpReq->t.msg3RecpReq.numRb));
               break;
            }
            if (1)
            {
               TfuModScheme modSchm = (TfuModScheme)modTbsInxTbl[ueRecpReq->t.msg3RecpReq.mcs].qm; 
               iTbs   = modTbsInxTbl[ueRecpReq->t.msg3RecpReq.mcs].iTbs;
               tbs    = tbsTbl[iTbs][ueRecpReq->t.msg3RecpReq.numRb - 1]>>3;
               if ((ueRecpReq->t.msg3RecpReq.mcs < 29) &&
                   ((modSchm != ueRecpReq->t.msg3RecpReq.modType) || 
                   (tbs != ueRecpReq->t.msg3RecpReq.size)))
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq() Error : \
                           mismatch tbs exp (%d) rcvd (%d):: \
                           mismatch qm exp(%d) rcvd(%d)\n",
                           tbs, ueRecpReq->t.msg3RecpReq.size,
                           modSchm, ueRecpReq->t.msg3RecpReq.modType));
                  break;
               }
            }
         }
         else
         if (!((validate == FALSE) || ((ret = rgAcUtlValidateUlGrant (&(ueRecpReq->t.msg3RecpReq), 
                     ueCb->lastUlGrant)) == CMXTA_ERR_NONE)))
         {
            break;
         }
         rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
         /* Found the correct node - can return success */
         /* TODO: OPTIMIZE delete the node once we have a match. */
         cmLListDelFrm(&recpReq->ueRecpReqLst, node);
         RETVALUE(CMXTA_ERR_NONE);
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateMsg3RecpReq */ 

#else
 /** @brief This function validates the reception request for MSG3 of the RACH
  * procedure
  *
  * @details
  * This is the lower-level handler and just validates the MSG3 reception
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateMsg3RecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateMsg3RecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   U8                   ueId;
   U8                   use;
   U8                   saveTo;
   RgAcUeCb             *ueCb;
   Bool                 validate, vldtAdptRetx;
   TfuPdcchInfo         *pdcchReq;

   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   Bool                 vldtRbOvrlap;
   

   TRC2(rgAcUtlTfuValidateMsg3RecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   validate = TRUE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validate", &validate);
   vldtAdptRetx = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtAdptRetx", &vldtAdptRetx);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   use = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;

   while (node)
   {
     recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
     ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
     /* For RG_ULSCHED_AT_CRC we need to maintain
      * context of rbstart and nDmrs for recpReq+4 tti*/
     ueCb->rbStart[((recpReq->timingInfo.subframe + 4) % 10)] 
        = ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart;
     ueCb->nDmrs[((recpReq->timingInfo.subframe + 4) % 10)] = 0;

      if ((ueRecpReq->rnti == ueCb->crnti) || (validate == FALSE))
  
      {
         if (vldtAdptRetx)
         {
            /* Pick up the corresponding Format 0 */
            pdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
            if (pdcchReq->dci.u.format0Info.rbStart != ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq() Error : Grant mismatch rbStart exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.rbStart, ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart));
               break;
            }
            if (pdcchReq->dci.u.format0Info.numRb != ueRecpReq->t.puschRecpReq.ulSchInfo.numRb)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq() Error : Grant mismatch numRb exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.numRb, ueRecpReq->t.puschRecpReq.ulSchInfo.numRb));
               break;
            }
         }
         else
         {
            if (!((validate == FALSE) || ((ret = rgAcUtlValidateUlGrant (tcCb, spCb, &(ueRecpReq->t.puschRecpReq), 
                        ueCb->lastUlGrant)) == CMXTA_ERR_NONE)))
            {
               break;
            }
         }
      
         vldtRbOvrlap = TRUE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtRbOvrlap", &vldtRbOvrlap);
         if(vldtRbOvrlap)
         {
             ret = rgAcTfuUtlVldtUlRbOvrlap(ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart,
                   ueRecpReq->t.puschRecpReq.ulSchInfo.numRb);

             if (ret != CMXTA_ERR_NONE)
             {
                RETVALUE(CMXTA_ERR_NOMATCH);
             }
         }

         rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
         /* Found the correct node - can return success */
         /* TODO: OPTIMIZE delete the node once we have a match. */
         RG_ACC_UPD_BM_N_CHK_NODE_DEL(0, recpReqNd, recpReq, recpReqInfo);
         RETVALUE(CMXTA_ERR_NONE);
      }
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateMsg3RecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateMsg3RecpReq */ 
#endif

#ifdef TFU_UPGRADE
 /** @brief This function validates the reception request for PUSCH data.
  *
  * @details
  * This is the lower-level handler and just validates the PUSCH data reception 
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidatePuschRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidatePuschRecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   U8                   ueId;
   RgAcUeCb             *ueCb;
   U8                   use;
   U8                   saveTo;
   U16                  minGrantBits;
   U8                   vldtRv;
   U16                  tbs;
   TfuPdcchInfo         *pdcchReq;
   RgAcTfuUeRecpReqNode *recpReqNd;
   RgAcTfuUeRecpReqInfo *recpReqInfo;
   U8                   nSrs; /*ccpu00117050 - ADD - Test nSrs */ 
   /* Initial Num RBs support for UCI on PUSCH */
   U8                   vldtInitNumRbs;
   U8                   initNumRbsPres;
   U8                   initNumRbsVal;
   U8                   rbsPres;
    Bool                 isRetx = FALSE;
   Bool                 vldtHarq= FALSE;
   U8                   expHarqProcId;
#ifdef LTEMAC_SPS
   Bool                 isSpsRnti = FALSE;
#endif

  U8                   numRbs;
   Bool                 vldtRbOvrlap;
   Bool                vldtCqi;
   U8                  cqiPmiSzR1[CM_LTE_MAX_CELLS] = {0};
   U8                  cqiPmiSzRn1[CM_LTE_MAX_CELLS] = {0};
   U8                  riPres[CM_LTE_MAX_CELLS] = {0};
   U8                  ri[CM_LTE_MAX_CELLS] = {0};
   U8                  cqiBetaOff;
   U8                  riBetaOff;
   TRC2(rgAcUtlTfuValidatePuschRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   use = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   vldtRv = 5;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "vldtRv", &vldtRv);
   /*ccpu00117050 - ADD - Test nSrs */
   nSrs = 0;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "nSrs", &nSrs);
   recpReqInfo = (RgAcTfuUeRecpReqInfo *)tcCb->data;
   node = recpReqInfo->ueRecpReqNdLst.first;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtHarq", &vldtHarq);
   while (node)
   {
      recpReqNd = (RgAcTfuUeRecpReqNode *)node->node;
      ueRecpReq = (TfuUeRecpReqInfo *)recpReqNd->node;
      if(!(recpReqNd->recpTypeBitMsk & RG_ACC_TFU_PUSCH_DATA))
      {
         if(node->next != NULLP)
         {
            node = node->next;
            continue;
         }
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error :Received Recp is not of PUSCH DATA type\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

     /* For RG_ULSCHED_AT_CRC we need to maintain
      * context of rbstart and nDmrs for recpReq+4 tti*/
      ueCb->rbStart[((recpReq->timingInfo.subframe + 4) % 10)] = 
         ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart;
      ueCb->nDmrs[((recpReq->timingInfo.subframe + 4) % 10)] = 
         ueRecpReq->t.puschRecpReq.ulSchInfo.nDmrs;

      if(vldtHarq)
      {
#ifndef LTE_TDD
         expHarqProcId = (rgAcTfCb.crntTime.sfn * RG_NUM_SUB_FRAMES +
            rgAcTfCb.crntTime.subframe) % RG_NUM_UL_HQ_PROC;
#endif
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "expHarqProcId", &expHarqProcId);
      }

      if(vldtHarq && (ueRecpReq->t.puschRecpReq.ulSchInfo.harqProcId != expHarqProcId))
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : harqProcId mismatch exp (%d) rcvd (%d):\n", 
            expHarqProcId, ueRecpReq->t.puschRecpReq.ulSchInfo.harqProcId));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }

#ifdef LTEMAC_SPS
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSpsRnti", &isSpsRnti);
      if(isSpsRnti && (ueRecpReq->rnti != ueCb->SPScrnti))
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : SPS rnti mismatch exp (%d) rcvd (%d):\n", 
            ueCb->SPScrnti, ueRecpReq->rnti));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      
      /* Basic criteron is the RNTI match, once that suceeds we should be in a
       * position to match everthing else, if not then flag an error and return. 
       */
      if (((ueRecpReq->rnti == ueCb->crnti) || (ueRecpReq->rnti == ueCb->SPScrnti) )&& 
            (ueRecpReq->type == TFU_RECP_REQ_PUSCH) )
#else
      if ((ueRecpReq->rnti == ueCb->crnti) && 
            (ueRecpReq->type == TFU_RECP_REQ_PUSCH) )
#endif
      {
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isRetx", 
            &isRetx);
 
         if(isRetx && !(ueRecpReq->t.puschRecpReq.ulSchInfo.isRtx))
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Retransmission expected but newtx recieved\n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         if (use != 0)
         {
            /* Pick up the corresponding Format 0 */
            pdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
            if (pdcchReq->dci.u.format0Info.rbStart != ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch rbStart exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.rbStart, ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            if (pdcchReq->dci.u.format0Info.numRb != ueRecpReq->t.puschRecpReq.ulSchInfo.numRb)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch numRb exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.numRb, ueRecpReq->t.puschRecpReq.ulSchInfo.numRb));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }

            minGrantBits = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "minGrantBits", &minGrantBits);
#ifdef LTEMAC_SPS
            if(isSpsRnti)
            {
               minGrantBits = ueCb->ulPacketSize;
            }
#endif
            if (minGrantBits != 0)
            {
               tbs    = ueRecpReq->t.puschRecpReq.ulSchInfo.size * 8;
               if (minGrantBits > tbs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch  exp (%d) rcvd (%d):\n", 
                           minGrantBits, tbs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (vldtRv != 5)
            {
               if (vldtRv  != ueRecpReq->t.puschRecpReq.ulSchInfo.rv)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : RV\
                           mismatch exp (%d) rcvd (%d):\n",
                           vldtRv, ueRecpReq->t.puschRecpReq.ulSchInfo.rv));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            /* ccpu00117050 - ADD - nSrs testing */ 
            if (nSrs  != ueRecpReq->t.puschRecpReq.ulSchInfo.nSrs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : nSrs "
                        "mismatch exp (%d) rcvd (%d):\n",
                        nSrs, ueRecpReq->t.puschRecpReq.ulSchInfo.nSrs));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }

   /* Initial Num RBs support for UCI on PUSCH */
            vldtInitNumRbs = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "vldtInitNumRbs", &vldtInitNumRbs);
            initNumRbsPres = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "initNumRbsPres", &initNumRbsPres);
            initNumRbsVal = 6;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "initNumRbsVal", &initNumRbsVal);
            rbsPres = ueRecpReq->t.puschRecpReq.initialNumRbs.pres;
            numRbs = ueRecpReq->t.puschRecpReq.initialNumRbs.val;
            if (vldtInitNumRbs) 
             {
                if((numRbs != initNumRbsVal) || 
                   (rbsPres != initNumRbsPres))
                {
                    CMXTA_DBG_ERR((_cmxtap, 
                            "rgAcUtlTfuValidatePuschRecpReq(): InitialNumRbs Present exp (%d) recvd (%d)\
                             and Its value exp(%d) recvd (%d)!\n",
                             (int)initNumRbsPres, (int)ueRecpReq->t.puschRecpReq.initialNumRbs.pres,\
                            (int)initNumRbsVal, (int)ueRecpReq->t.puschRecpReq.initialNumRbs.val));
                    RETVALUE(CMXTA_ERR_NOMATCH);
                }
             }

            vldtCqi = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtCqi", 
                  &vldtCqi);

            if(vldtCqi)
            {
               U8 idx = 0;
               U8 ccNum = 1;
               Txt *holdMain = NULLP, *tokMain = NULLP, *tok1 = NULLP;

               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ccNum", &ccNum);
               if (ccNum != ueRecpReq->t.puschRecpReq.cqiRiInfo.cCNum)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : ccNum\
                           mismatch exp (%d) rcvd (%d):\n",
                           ccNum, ueRecpReq->t.puschRecpReq.cqiRiInfo.cCNum));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }

               U8 num = 0;
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
                     "cqiPmiSzRn1",cqiPmiSzRn1, &num);
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
                     "cqiPmiSzR1",cqiPmiSzR1, &num);
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
                     "riPres",riPres, &num);
               cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
                     "ri",ri, &num);

               for (idx = 0; idx< ccNum;idx++)
                  {
                  if (cqiPmiSzR1[idx]  != ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiPmiSzR1[idx])
               {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : cqiPmiSzR1\
                           mismatch exp (%d) rcvd (%d):\n",
                              cqiPmiSzR1[idx], ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiPmiSzR1[idx]));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }

                  if (cqiPmiSzRn1[idx]  != ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiPmiSzRn1[idx])
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : cqiPmiSzRn1\
                              mismatch exp (%d) rcvd (%d):\n",
                              cqiPmiSzRn1[idx], ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiPmiSzRn1[idx]));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }

                  //RI Checking
                  if (riPres[idx] != ueRecpReq->t.puschRecpReq.cqiRiInfo.riSz[idx].pres)
               {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : riPres\
                              mismatch exp (%d) rcvd (%d):\n",
                              riPres[idx], ueRecpReq->t.puschRecpReq.cqiRiInfo.riSz[idx].pres));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }

                  if(riPres[idx])
                  {
                     if (ri[idx] != ueRecpReq->t.puschRecpReq.cqiRiInfo.riSz[idx].val)
                  {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : ri\
                              mismatch exp (%d) rcvd (%d):\n",
                                 ri[idx], ueRecpReq->t.puschRecpReq.cqiRiInfo.riSz[idx].val));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }

                  }
                  cqiBetaOff = 0;
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "cqiBetaOff", &cqiBetaOff);

               if (cqiBetaOff  != ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiBetaOff)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : cqiBetaOff\
                           mismatch exp (%d) rcvd (%d):\n",
                           cqiBetaOff, ueRecpReq->t.puschRecpReq.cqiRiInfo.cqiBetaOff));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }



                  riBetaOff = 0;
                  cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "riBetaOff", &riBetaOff);

                  if (riBetaOff  != ueRecpReq->t.puschRecpReq.cqiRiInfo.riBetaOff)
                  {
                     CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : cqiBetaOff\
                              mismatch exp (%d) rcvd (%d):\n",
                              riBetaOff, ueRecpReq->t.puschRecpReq.cqiRiInfo.riBetaOff));
                     RETVALUE(CMXTA_ERR_NOMATCH);
                  }
               }
            }

         }
            vldtRbOvrlap = TRUE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtRbOvrlap", &vldtRbOvrlap);
            if(vldtRbOvrlap)
            {
               ret = rgAcTfuUtlVldtUlRbOvrlap(ueRecpReq->t.puschRecpReq.ulSchInfo.rbStart,
                               ueRecpReq->t.puschRecpReq.ulSchInfo.numRb);

               if (ret != CMXTA_ERR_NONE)
               {
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }

         /* If we could get here it means we have a perfect match - save and
          * return success
          */
         rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
         /* Found the correct node - can return success */
         /* OPTIMIZE delete the node once we have a match. */
         RG_ACC_UPD_BM_N_CHK_NODE_DEL(RG_ACC_TFU_PUSCH_DATA, recpReqNd, recpReq, recpReqInfo);
         RETVALUE(CMXTA_ERR_NONE);
      } /* If RNTI matched */
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidatePuschRecpReq */ 
#else
 /** @brief This function validates the reception request for PUSCH data.
  *
  * @details
  * This is the lower-level handler and just validates the PUSCH data reception 
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Traverse the linked list looking for a best match. 
  *         Optimization could entail deleting the matched node from 
  *         the list of Reception requests. This can be done once we figure out if we need
  *         this information later or not.
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  recpReq pointer to TfuRecpReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidatePuschRecpReq
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuRecpReqInfo      *recpReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidatePuschRecpReq (tcCb, spCb, recpReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuRecpReqInfo      *recpReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuUeRecpReqInfo     *ueRecpReq;
   U8                   ueId;
   RgAcUeCb             *ueCb;
   U8                   use;
   U8                   saveTo;
   U16                  minGrantBits;
   U8                   vldtRv;
   U8                   iTbs;
   U16                  tbs;
   TfuPdcchInfo         *pdcchReq;
   /* Adding validation for isRtx field in recpReq */
   Bool                 isRtx = FALSE;
#ifdef LTEMAC_SPS
   Bool                 isSpsRnti = FALSE;
   Bool                 vldtHarq= FALSE;
   U8                   expHarqProcId;
#endif

   TRC2(rgAcUtlTfuValidatePuschRecpReq);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   saveTo = 9;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
   use = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   vldtRv = 5;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "vldtRv", &vldtRv);
#ifdef LTEMAC_SPS
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSpsRnti", &isSpsRnti);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldtHarq", &vldtHarq);
   if(vldtHarq)
   {
      expHarqProcId = (rgAcTfCb.crntTime.sfn * RG_NUM_SUB_FRAMES +
      rgAcTfCb.crntTime.subframe) % RG_NUM_UL_HQ_PROC;

   }
#endif
   node = recpReq->ueRecpReqLst.first;
   while (node)
   {
      ueRecpReq = (TfuUeRecpReqInfo *)node->node;
      ueCb->rbStart[((recpReq->timingInfo.subframe + 4) % 10)] = ueRecpReq->t.puschRecpReq.rbStart;
      ueCb->nDmrs[((recpReq->timingInfo.subframe + 4) % 10)] = ueRecpReq->t.puschRecpReq.nDmrs;
      /* Basic criteron is the RNTI match, once that suceeds we should be in a
       * position to match everthing else, if not then flag an error and return. 
       */
#ifdef LTEMAC_SPS
      if(isSpsRnti && (ueRecpReq->rnti != ueCb->SPScrnti))
      {
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : \
               SPS rnti mismatch exp (%d) rcvd (%d):\n", 
      ueCb->SPScrnti, ueRecpReq->rnti));
      RETVALUE(CMXTA_ERR_NOMATCH);
      }
      if(vldtHarq && (ueRecpReq->t.puschRecpReq.harqProcId != expHarqProcId))
      {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : \
                  harqProcId mismatch exp (%d) rcvd (%d):\n", 
      ueRecpReq->t.puschRecpReq.harqProcId, expHarqProcId));
      RETVALUE(CMXTA_ERR_NOMATCH);
      }
#endif
#ifdef LTEMAC_SPS
      if (((ueRecpReq->rnti == ueCb->crnti) || (ueRecpReq->rnti == ueCb->SPScrnti))&& 
            (ueRecpReq->type == TFU_RECP_REQ_PUSCH) )
#else
      if ((ueRecpReq->rnti == ueCb->crnti) && 
            (ueRecpReq->type == TFU_RECP_REQ_PUSCH) )
#endif
      {
         if (use != 0)
         {
            /* Pick up the corresponding Format 0 */
            pdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
            if (pdcchReq->dci.u.format0Info.rbStart != ueRecpReq->t.puschRecpReq.rbStart)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch rbStart exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.rbStart, ueRecpReq->t.puschRecpReq.rbStart));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            if (pdcchReq->dci.u.format0Info.numRb != ueRecpReq->t.puschRecpReq.numRb)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch numRb exp (%d) rcvd (%d):\n", 
                        pdcchReq->dci.u.format0Info.numRb, ueRecpReq->t.puschRecpReq.numRb));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isRtx", &isRtx);
            if (isRtx == TRUE)
            {
               if (TRUE != ueRecpReq->t.puschRecpReq.isRtx)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error "
                     ": isRtx field  mismatch isRtx exp (%d) rcvd (%d):\n", 
                             isRtx, ueRecpReq->t.puschRecpReq.isRtx));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            minGrantBits = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "minGrantBits", &minGrantBits);
#ifdef LTEMAC_SPS
      if(isSpsRnti)
      {
         minGrantBits = ueCb->ulPacketSize;
      }
#endif
            if (minGrantBits != 0)
            {
               iTbs   = modTbsInxTbl[ueRecpReq->t.puschRecpReq.mcs].iTbs;
               tbs    = tbsTbl[iTbs][ueRecpReq->t.puschRecpReq.numRb - 1];
               if (minGrantBits > tbs)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : Grant mismatch  exp (%d) rcvd (%d):\n", 
                           minGrantBits, tbs));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (vldtRv != 5)
            {
               if (vldtRv  != ueRecpReq->t.puschRecpReq.rv)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : RV\
                           mismatch exp (%d) rcvd (%d):\n",
                           vldtRv, ueRecpReq->t.puschRecpReq.rv));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
            if (1)
            {
               TfuModScheme modSchm = (TfuModScheme)modTbsInxTbl[ueRecpReq->t.puschRecpReq.mcs].qm; 
               iTbs   = modTbsInxTbl[ueRecpReq->t.puschRecpReq.mcs].iTbs;
               tbs    = tbsTbl[iTbs][ueRecpReq->t.puschRecpReq.numRb - 1]>>3;

               if(ueCb->ueCatEnum != CM_LTE_UE_CAT_5)
               {
                   modSchm = (modSchm > 4) ? 4: modSchm;
               }

               if ((ueRecpReq->t.puschRecpReq.mcs < 29) &&
                   ((modSchm != ueRecpReq->t.puschRecpReq.modType) || 
                   (tbs != ueRecpReq->t.puschRecpReq.size)))
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq() Error : \
                           mismatch tbs exp (%d) rcvd (%d):: \
                           mismatch qm exp(%d) rcvd(%d)\n",
                           tbs, ueRecpReq->t.puschRecpReq.size,
                           modSchm, ueRecpReq->t.puschRecpReq.modType));
                  RETVALUE(CMXTA_ERR_NOMATCH);
               }
            }
         }
         /* If we could get here it means we have a perfect match - save and
          * return success
          */
         rgAccCb.savedMsgs[saveTo].u.ueRecpReqInfo = *ueRecpReq;
         /* Found the correct node - can return success */
         /* OPTIMIZE delete the node once we have a match. */
         cmLListDelFrm(&recpReq->ueRecpReqLst, node);
         RETVALUE(CMXTA_ERR_NONE);
      } /* If RNTI matched */
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePuschRecpReq(): Did not find rnti (%d) \n",
            ueCb->crnti));
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidatePuschRecpReq */ 
#endif


 /** @brief This function validates the BCH data that is sent as part of the
  * data request from MAC to Physical layer.
  *
  * @details
  * This is the lower-level handler and just validates the BCH data
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Match BCH if present
  *         Optimization could entail deleting the matched node from 
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  datReq pointer to TfuDatReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateBch
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuDatReqInfo       *datReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateBch (tcCb, spCb, datReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuDatReqInfo       *datReq;
#endif
{   
   Bool     validate;
   S16      ret;

   TRC2(rgAcUtlTfuValidateBch);

   validate = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validate", &validate);
   if (validate)
   {
      if ((ret = rgAcUtlTfuCompareBuf (datReq->bchDat.val, rgAccCb.bcchBuf[0])) != CMXTA_ERR_NONE)
      {
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateBch(): Comparison failed \n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
#ifdef LTEMAC_HDFDD
   if (rgAcTfuUtlHdfddVldtBCH(tcCb, spCb, datReq) != CMXTA_ERR_NONE)
   {
      CMXTA_DBG_ERR((_cmxtap,
               "rgAcUtlTfuValidateBch(): HD-FDD Validation Failed\n"));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
      
#endif
   SPutMsg(datReq->bchDat.val);
   datReq->bchDat.val = NULLP;
   RETVALUE(CMXTA_ERR_NONE);
 
} /* end of rgAcUtlTfuValidateBch */

#ifdef LTEMAC_MIMO
/** @brief This function calculates the nmbRb from the given resAllocMap
  * value.
  *
  * @details
  *
  *     Function: 
  *
  *         Processing steps:
  *         - 
  *
  *
  * @param  
  * @param 
  * @return 
  */
#ifdef ANSI
PRIVATE Void   rgAcUtlTfuCalcRbs
(
 U8      *resAllocMap, 
 U8      *numRb,
 U8      isAllocType0
 )
#else
PRIVATE Void   rgAcUtlTfuCalcRbs(resAllocMap, numRb, isAllocType0)
 U8      *resAllocMap; 
 U8      *numRb;
 U8      isAllocType0;
#endif
{
   U8       allocIdx = 0;
   U8       tmpIdx = 0;
   U8       numOnes = 0;
   U8       rbgCntr = 0;
   Bool     isLastRbg = FALSE;
   S16      ret;
                           
   for (; allocIdx < TFU_MAX_ALLOC_BYTES && rbgCntr <= rgAccCb.numRbgs;
               ++allocIdx)
   {
      for (tmpIdx = 0; tmpIdx < 8 && rbgCntr <= rgAccCb.numRbgs; 
                    ++tmpIdx)
      {
         rbgCntr++;
         if (*resAllocMap &
                     (1 << (7-tmpIdx)))
         {
            if (rbgCntr == rgAccCb.numRbgs)
            {
               isLastRbg = TRUE;
            }
            else 
            {
               numOnes ++; 
            }
         }
      }
      resAllocMap++;
   } /* End of For loop */
   if (isAllocType0)
   {
   *numRb = numOnes * rgAccCb.rbgSize; 
   if (isLastRbg)
   {
      *numRb += rgAccCb.lastRbgSize; 
   }
   if (!*numRb)
   {
      ret = RFAILED;
   }
   }
   else
   {
       *numRb = numOnes;
   }   
   RETVOID;
}
#endif


 /** @brief This function validates the PDSCH data that is sent as part of the
  * data request from MAC to Physical layer.
  *
  * @details
  * This is the lower-level handler and just validates the PDSCH data for a
  * single UE.
  * request.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Match RNTI 
  *            - if matched proceed to validate other attributes 
  *            - else move to the next node
  *         Optimization could entail deleting the matched node from 
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  datReq pointer to TfuDatReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidatePdsch
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuDatReqInfo       *datReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidatePdsch (tcCb, spCb, datReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuDatReqInfo       *datReq;
#endif
{
   S16                  ret;
   CmLList              *node;
   TfuDatReqPduInfo     *pduInfo;
   TfuDatReqPduInfo     *prevPduInfo = NULLP;
   U8                   ueId;
   RgAcUeCb             *ueCb;
   Bool                 validate;
   Bool                 chkGrant;
   Bool                 chkCcchSh;
   Bool                 chkTA;
   Bool                 chkSdu;
   Bool                 chkSduTb2;
   Bool                 chkPadding;
#ifndef CCPU_OPT      
   Bool                 chkPadBytes;
   U8                   padHdrs;
   U8                   count;
#endif   
   U8                   lcId;
   U8                   lcIdTb2;
   U16                  taVal;
   U16                  padBytes = 0;
#ifdef LTEMAC_MIMO
   U16                  padBytes2 = 0;
   MsgLen               dataLen2 = 0;
#endif
   RgAcSubHeader        *subHdr;
   RgAcCEorSDU          *ce;
   MsgLen               dataLen1 = 0;
   TfuDciFormat1aAllocInfo   *format1A;
   TfuDciFormat1AllocInfo    *format1;
   U8                   iTbs;
   U32                  tbs;
   TfuPdcchInfo         *pdcchReq;
   U8                   use;
   U8                   retxUse;
   U8                   saveTo;
   U8                   bcchIdx;
   Bool                 vldtDciFmt;
   U8                   expDciFmt = 0;
   Bool                 isRetx = FALSE;
   RgAcEdEvent          *rgAcEdEvent; 
   RgAcEdEvent          *rgAcEdEvent2; 
   CmLList              *subHdrNode;
   CmLList              *ceNode;
   TfuDciFormat         dciFmt;
   U8                   rbStart, numRb;
#ifdef LTEMAC_MIMO
   Bool                 vldPuschRptUsd = FALSE;
   Bool                 vldPuschPmiInfo = FALSE;
   Bool                 vldDoa = FALSE;
   Bool                 puschRptUsd;
   Bool                 isVldRb = FALSE;
   U8                   numTb1Rb = 0;
   U8                   numTb2Rb = 0;
   TfuDlCqiPuschMode    puschMode;
   TfuTxMode            transMode;
   U32                  doaVal;
   Bool                 isTb1Retx = FALSE;
   Bool                 isTb2Retx = FALSE;
   U8                   numRbs = 0;   
   U8                   numTb1Lyrs = 0;
   U8                   numTb2Lyrs = 0;
   TfuDciFormat         *preDciFmt;   
   TfuDciFormat1bAllocInfo   *format1B;
   TfuDciFormat2AllocInfo    *format2;   
   TfuDciFormat2AAllocInfo   *format2A;   
#endif
#ifdef LTEMAC_SPS
   Bool DLSPSInit = FALSE;
   Bool DLSPSReInit = FALSE;
   Bool validateSPS = FALSE;
   Bool isSPSRetx = FALSE;
   U8 TbIdx = 0;
   U8 SPSretxUse = 0;
   Bool ChkHarqProcId = FALSE;
#endif /*LTEMAC_SPS*/
#if defined(LTEMAC_SPS) || defined(LTEMAC_MIMO)
   Bool                 isTb1 = FALSE;
   Bool                 isTb2 = FALSE;
#endif
#ifdef TFU_UPGRADE
      Bool                 chkPa = FALSE;
#endif
#ifdef LTE_TDD
   U8 ulDlCfg = rgAccCb.ulDlCfgIdx;
#endif
#ifdef LTE_ADV
   U8  deActCeVal = 2;
   Bool                 chkSCellDeActCeReqd = FALSE;
#endif

   TRC2(rgAcUtlTfuValidatePdsch);

   ret   = CMXTA_ERR_NONE;
   node = NULLP;
   rgAcEdEvent = NULLP;

   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   use = 9;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use", &use);
   bcchIdx = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bcchIdx",  &bcchIdx);
   chkCcchSh = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkCcchSh", &chkCcchSh);
   chkTA = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkTA", &chkTA);
#ifdef LTEMAC_SPS
   chkTA = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkTA", &chkTA);

#endif

#ifdef TFU_UPGRADE
   chkPa = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkPa", &chkPa);
#endif
#ifdef LTE_ADV
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkSCellDeActCe", &chkSCellDeActCeReqd);
#endif
   node = datReq->pdus.first;
   while (node)
   {
      pduInfo = (TfuDatReqPduInfo *)node->node;
      validate = TRUE;
      cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validate", &validate);
      saveTo = 9;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "saveTo",  &saveTo);
      if (saveTo != 9)
      { 
         U8 tmpIdx = 0;
         rgAccCb.savedMsgs[saveTo].u.pduInfo = *pduInfo;
         for (tmpIdx = 0; tmpIdx < TFU_MAX_ALLOC_BYTES; ++tmpIdx)
         {
            rgAccCb.savedMsgs[saveTo].u.pduInfo.dciInfo.u.format1AllocInfo.resAllocMap[tmpIdx] =
              pduInfo->dciInfo.u.format1AllocInfo.resAllocMap[tmpIdx];
         }
      }
      if (validate)
      {
         if ((pduInfo->rnti == RG_P_RNTI) || (pduInfo->rnti == RG_SI_RNTI))
         {
            if ((ret = rgAcUtlTfuCompareBuf (pduInfo->mBuf[0] ,rgAccCb.bcchBuf[bcchIdx])) != CMXTA_ERR_NONE)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Comparison for BCCH PCCH buffer failed \n"));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            SPutMsg(pduInfo->mBuf[0]);
            pduInfo->mBuf[0] = NULLP;
            cmLListDelFrm(&datReq->pdus, &pduInfo->lnk);
            RETVALUE(CMXTA_ERR_NONE);
         }
      } /* end of validate */
      if ((pduInfo->rnti == ueCb->crnti) 
#ifdef LTEMAC_SPS
            || (pduInfo->rnti == ueCb->SPScrnti)
#endif
         )
      {
#ifndef LTEMAC_MIMO
         SFndLenMsg(pduInfo->mBuf[0], &dataLen1);
         if ((ret = rgAcUtlDecodeDataPdu (pduInfo->mBuf[0], &rgAcEdEvent, &padBytes)) != ROK)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Decode of PDU failed \n"));
            RETVALUE(CMXTA_ERR_INT);
         }
#else
         isTb1 = TRUE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1", &isTb1);
         if (isTb1)
         {
            SFndLenMsg(pduInfo->mBuf[0], &dataLen1);
            if ((ret = rgAcUtlDecodeDataPdu (pduInfo->mBuf[0], &rgAcEdEvent, &padBytes)) != ROK)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Decode of PDU of TB1 failed \n"));
               RETVALUE(CMXTA_ERR_INT);
            }            
            pduInfo->mBuf[0] = NULLP; 
         }
         isTb2 = FALSE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb2", &isTb2);
         if (isTb2)
         {    
            SFndLenMsg(pduInfo->mBuf[1], &dataLen2);
            if ((ret = rgAcUtlDecodeDataPdu (pduInfo->mBuf[1], &rgAcEdEvent2, &padBytes2)) != ROK)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Decode of PDU of TB2 failed \n"));
               RETVALUE(CMXTA_ERR_INT);
            }
            pduInfo->mBuf[1] = NULLP; 
         }
#endif
         if (validate)
         {
            ret = ROK;
            chkGrant = TRUE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkGrant", &chkGrant);
            isRetx = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isRetx", &isRetx);
            vldtDciFmt = FALSE;
            if (isRetx)
            {
               retxUse = 9;
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "retxUse", &retxUse);
               if (retxUse != 9)
               {
                  prevPduInfo = &(rgAccCb.savedMsgs[retxUse].u.pduInfo);
               }
            }
#ifdef LTEMAC_MIMO
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldPuschRptUsd",  
                  &vldPuschRptUsd);
            if (vldPuschRptUsd)
            {
               puschRptUsd = FALSE;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "puschRptUsd",  &puschRptUsd);
               if (puschRptUsd != pduInfo->puschRptUsd)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected puschRptUsd %d"
                             "Recieved puschRptUsd %d \n", puschRptUsd, pduInfo->puschRptUsd));
                  RETVALUE(CMXTA_ERR_INT);
               }
            }
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldPuschPmiInfo",
                  &vldPuschPmiInfo);
            if (vldPuschPmiInfo)
            {
               puschMode = TFU_PUSCH_CQI_MODE_12;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, "puschMode",  &puschMode);
               if (puschMode != pduInfo->puschPmiInfo.mode)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected puschMode %d"
                             "Recieved puschMode %d \n",puschMode, pduInfo->puschPmiInfo.mode));
                  RETVALUE(CMXTA_ERR_INT);
               }
            }
            transMode = TFU_UE_TM_1;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, "transMode",  &transMode);
            if (transMode != pduInfo->transMode)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected transMode %d"
                          "Recieved transMode %d \n",transMode, pduInfo->transMode));
               /* RETVALUE(CMXTA_ERR_INT); */
            }
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "vldDoa",  
                  &vldDoa);
            if (vldDoa)
            {
               doaVal = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, "doaVal",  &doaVal);
               if (doaVal != pduInfo->doa.val)
               {
#ifdef ALIGN_64BIT
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected doaVal %ld"
                             "Recieved doaVal %u \n", doaVal, pduInfo->doa.val));
#else
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected doaVal %ld"
                             "Recieved doaVal %lu \n", doaVal, pduInfo->doa.val));
#endif
                  RETVALUE(CMXTA_ERR_INT);
               }
            }
#endif
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validateDciFmt",  &vldtDciFmt);
            if (chkGrant)
            {
               if (use != 9)
               {
                  pdcchReq = &(rgAccCb.savedMsgs[use].u.pdcchInfo);
                  dciFmt = pdcchReq->dci.dciFormat;

                  if (vldtDciFmt)
                  {
                     cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, "dciFormat",  &expDciFmt);
                     if (expDciFmt != dciFmt)
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Expected Format %d"
                                 "Recieved format %d \n", expDciFmt, dciFmt));
                        break;
                     }
                  }
#ifndef LTEMAC_MIMO
     if(isRetx)
     {
        dciFmt = (prevPduInfo->dciInfo.format);
      }
                  switch (dciFmt)
                  {
                     case TFU_DCI_FORMAT_1A:
                        {
                           /* NOTE: Assuming that current and previous alloction
                            * are both of type format 1A */
                           if (!isRetx)
                           {
                              format1A = &(pdcchReq->dci.u.format1aInfo.t.pdschInfo.allocInfo);
                           }
                           else
                           {
                             format1A =  &(prevPduInfo->dciInfo.u.format1aAllocInfo);
                           }
                           rgAcUtlCalcRivInfo (format1A->alloc.u.riv, 
                                 rgAccCb.dlTotalBw, &rbStart, &numRb);
                           iTbs     = dlModTbsInxTbl[format1A->mcs].iTbs;
                           tbs      = tbsTbl[iTbs][numRb - 1];
#ifdef LTE_TDD                           
                           if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                             RGAC_TDD_SPL_SUBFRAME)
                           {
                              tbs = tbsTbl[iTbs][MAX(numRb*3/4,1) - 1];   
                           }
#endif                              

                           if (((MsgLen)(tbs/8) != dataLen1) && (!isRetx))
                           {
#ifndef ALIGN_64BIT
                              CMXTA_DBG_ERR((_cmxtap, 
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%ld) sending (%ld)\n",
                                       (tbs/8), dataLen1));
#else
                              CMXTA_DBG_ERR((_cmxtap, 
                                       "rgAcUtlTfuValidatePdsch(): Grant"
                                       " and Datasize mismatch exp (%d) sending (%d)\n",
                                       (tbs/8), dataLen1));
#endif
                              ret = RFAILED;
                              break;
                           }
                           break;
                        }
                     case TFU_DCI_FORMAT_1:
                        {
                           U8       allocIdx = 0;
                           U8       tmpIdx = 0;
                           U8       numOnes = 0;
                           U8       rbgCntr = 0;
                           U8       numRbs = 0;
                           U8       sbNum;
                           U32      allocBitMask = 0;
                           U32      expAllocBitMask = 0;
                           Bool     isLastRbg = FALSE;
                           U8       dlAllocRbgs[25];
                           U8       sbCnt = 0;
                           Bool     vldtSbAlloc = FALSE;
                           TfuDciFormat1AllocInfo *crntFormat1;
                           cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                                 "vldtSbAlloc", &vldtSbAlloc);
                           /* NOTE: Assuming that current and previous alloction
                            * are both of type format 1 */
                           if (!isRetx)
                           {
                              format1 = &(pdcchReq->dci.u.format1Info.allocInfo);
                              crntFormat1 = format1; 
                           }
                           else
                           {
                              crntFormat1 = &(pdcchReq->dci.u.format1Info.allocInfo);
                              format1 =  &(prevPduInfo->dciInfo.u.format1AllocInfo);
                           }
                           iTbs     = dlModTbsInxTbl[format1->mcs].iTbs;
                           if (format1->isAllocType0)
                           {
                              /* Resource allocation type 0 */
                              /* Validate the tbSize */
                              for (; allocIdx < TFU_MAX_ALLOC_BYTES && rbgCntr <= rgAccCb.numRbgs;
                                    ++allocIdx)
                              {
                                 for (tmpIdx = 0; tmpIdx < 8 && rbgCntr <= rgAccCb.numRbgs; 
                                       ++tmpIdx)
                                 {
                                    rbgCntr++;
                                    if (format1->resAllocMap[allocIdx] &
                                          (1 << (7 -tmpIdx)))
                                    {
                                       if (rbgCntr == rgAccCb.numRbgs)
                                       {
                                          isLastRbg = TRUE;
                                       }
                                       else 
                                       {
                                          numOnes ++; 
                                       }
                                    }
                                 }
                              } /* End of For loop */
                              numRbs = numOnes * rgAccCb.rbgSize; 
                              if (isLastRbg)
                              {
                                 numRbs += rgAccCb.lastRbgSize; 
                              }

                              if (!numRbs)
                              {
                                 ret = RFAILED;
                                 break;
                              }
                              tbs      = tbsTbl[iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                              if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                           RGAC_TDD_SPL_SUBFRAME)
                              {
                                 tbs = tbsTbl[iTbs][MAX(numRbs*3/4,1) - 1];   
                              }
#endif 
                              if ((MsgLen)(tbs/8) != dataLen1)
                              {
#ifndef ALIGN_64BIT
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant and"
                                          " Datasize mismatch exp (%ld) sending (%ld)\n",
                                          (tbs/8), dataLen1));
#else
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant"
                                          " and Datasize mismatch exp (%d) sending (%d)\n",
                                          (tbs/8), dataLen1));
#endif
                                 ret = RFAILED;
                                 break;
                              }
                           }
                           if (crntFormat1->isAllocType0)
                           {
                              /* Resource allocation type 0 for the currently 
                               * recieved format */
                              if (vldtSbAlloc)
                              {
                                 rbgCntr = 0;
                                 isLastRbg = FALSE;
                                 for (allocIdx = 0; allocIdx < TFU_MAX_ALLOC_BYTES && 
                                       rbgCntr <= rgAccCb.numRbgs;
                                       ++allocIdx)
                                 {
                                    rbgCntr++;
                                    for (tmpIdx = 0; tmpIdx < 8 && 
                                          rbgCntr <= rgAccCb.numRbgs; ++tmpIdx)
                                    {
                                       if (crntFormat1->resAllocMap[allocIdx] &
                                             (1 << (7 -tmpIdx)))
                                       {
                                          if (rbgCntr == rgAccCb.numRbgs)
                                          {
                                             isLastRbg = TRUE;
                                          }
                                          else 
                                          {
                                             allocBitMask |= 
                                                1 << (31 - ((allocIdx * 8) + tmpIdx));
                                          }
                                       }
                                    }
                                 } /* End of For loop */
                                 if (isLastRbg)
                                 {
                                    allocBitMask |= 
                                       1 << (31 - (rgAccCb.numRbgs - 1));
                                 }
                                 cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                                       CMXTA_SEP_COLON, "allocSbIds", dlAllocRbgs, &sbNum);
                                 for (sbCnt = 0; sbCnt < sbNum; ++sbCnt)
                                 {
                                    expAllocBitMask |= 1 << (31 - dlAllocRbgs[sbCnt]);
                                 }

                                 /* cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, 
                                    "allocBitMask",  &expAllocBitMask);*/
                                 if (!(expAllocBitMask & allocBitMask))
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, 
                                             "rgAcUtlTfuValidatePdsch(): Expected allocation %d"
                                             " and received allocation %d mismatch\n",
                                             (int)expAllocBitMask, (int)allocBitMask));
                                    ret = RFAILED;
                                    break;
                                 }
                              } /* End of if(vldtSbAlloc) */
                           }
                           break;
                        }
                     default:
                        {
                           CMXTA_DBG_ERR((_cmxtap, "Invalid DCI format"
                                    " : expected format type 1 or 1A\n"));
                           ret = RFAILED;
                        }
                  }/* End of switch */
#else
                  if (isTb1)
                  {
                     isTb1Retx = isRetx;
                     cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                             "isTb1Retx", &isTb1Retx);

                     if (isTb1Retx || isRetx)
                     {
                        preDciFmt = &(prevPduInfo->dciInfo.format);
                        switch(*preDciFmt)
                        {
                           case TFU_DCI_FORMAT_1:
                              {
                                 format1 =  &(prevPduInfo->dciInfo.u.format1AllocInfo);
                                 iTbs    = dlModTbsInxTbl[format1->mcs].iTbs;
                                 if (format1->isAllocType0)
                                 {
                                    rgAcUtlTfuCalcRbs(&format1->resAllocMap[0],&numRbs,format1->isAllocType0);
                                    tbs = tbsTbl[iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                                RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl[iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif 
                                    if ((MsgLen)(tbs/8) != dataLen1)
                                    {
#ifndef ALIGN_64BIT
                                       CMXTA_DBG_ERR((_cmxtap,
                                                "rgAcUtlTfuValidatePdsch(): Grant and"
                                                " Datasize mismatch exp (%d) sending \
                                                (%d)\n",(int)(tbs/8),(int)dataLen1));
#else
                                       CMXTA_DBG_ERR((_cmxtap, 
                                                "rgAcUtlTfuValidatePdsch(): Grant"
                                                " and Datasize mismatch exp (%d) sending \
                                                (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                       ret = RFAILED;
                                    }
                                 }
                                 break;
                              }
                           case TFU_DCI_FORMAT_1A:
                           {
                              /* NOTE: Assuming that current and previous alloction
                                            * are both of type format 1A */
                              format1A =  &(prevPduInfo->dciInfo.u.format1aAllocInfo);                           
                              rgAcUtlCalcRivInfo (format1A->alloc.u.riv, 
                                    rgAccCb.dlTotalBw, &rbStart, &numRb);
                              iTbs     = dlModTbsInxTbl[format1A->mcs].iTbs;
                              tbs      = tbsTbl[iTbs][numRb - 1];
#ifdef LTE_TDD                           
                                 if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                             RGAC_TDD_SPL_SUBFRAME)
                                 {
                                    tbs = tbsTbl[iTbs][MAX(numRb*3/4,1) - 1];   
                                 }
#endif 
                              if (((MsgLen)(tbs/8) != dataLen1) && (!isRetx))
                              {
#ifndef ALIGN_64BIT
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant and"
                                          " Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#else
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant"
                                          " and Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#endif
                                 ret = RFAILED;
                                 break;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_1B:
                           {
                              /* NOTE: Assuming that current and previous alloction
                                            * are both of type format 1A */
                              format1B =  &(prevPduInfo->dciInfo.u.format1bAllocInfo);                           
                              rgAcUtlCalcRivInfo (format1B->alloc.u.riv, 
                                    rgAccCb.dlTotalBw, &rbStart, &numRb);
                              iTbs     = dlModTbsInxTbl[format1B->mcs].iTbs;
                              tbs      = tbsTbl[iTbs][numRb - 1];
#ifdef LTE_TDD                           
                                 if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                       RGAC_TDD_SPL_SUBFRAME)
                                 {
                                    tbs = tbsTbl[iTbs][MAX(numRb*3/4,1) - 1];   
                                 }
#endif 
                              if ((MsgLen)(tbs/8) != dataLen1)
                              {
#ifndef ALIGN_64BIT
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant and"
                                          " Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#else
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant"
                                          " and Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#endif
                                 ret = RFAILED;
                                 break;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2:
                           {
                              format2 =  &(prevPduInfo->dciInfo.u.format2AllocInfo);
                              iTbs   = dlModTbsInxTbl[format2->tbInfo[0].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                   "numTb1Lyrs", &numTb1Lyrs);
                              if (format2->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif 
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                 CMXTA_DBG_ERR((_cmxtap, "Invalid resource \
                                   allocation type"" : expected RA type 0\n"));
                                 ret = RFAILED;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2A:
                           {
                              format2A =  &(prevPduInfo->dciInfo.u.format2AAllocInfo);
                              iTbs     = dlModTbsInxTbl[format2A->tbInfo[0].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                    "numTb1Lyrs", &numTb1Lyrs);
                              if (format2A->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif 
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant and"
                                             " Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant"
                                             " and Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                                 break;
                              }   
                           default:
                           {
                              CMXTA_DBG_ERR((_cmxtap, "Invalid DCI format"
                                       " : expected format type 1 or 1A\n"));
                              ret = RFAILED;
                           }   
                        }  
                     }
                     else /* New Tx */
                     {
                        switch(dciFmt)
                        {
                           case TFU_DCI_FORMAT_1:
                           {
                              format1 =  &(pdcchReq->dci.u.format1Info.allocInfo);
                              iTbs     = dlModTbsInxTbl[format1->mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                    "numTb1Lyrs", &numTb1Lyrs);
                              if (format1->isAllocType0)
                              {
                                    rgAcUtlTfuCalcRbs(&format1->resAllocMap[0],&numRbs,format1->isAllocType0);
                                 tbs = tbsTbl[iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl[iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif 
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                    rgAcUtlTfuCalcRbs(&format1->resAllocMap[0],&numRbs,format1->isAllocType0);
                                    tbs = tbsTbl[iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl[iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif 
                                    if ((MsgLen)(tbs/8) != dataLen1)
                                    {
#ifndef ALIGN_64BIT
                                       CMXTA_DBG_ERR((_cmxtap,
                                                "rgAcUtlTfuValidatePdsch(): Grant and"
                                                " Datasize mismatch exp (%d) sending \
                                                (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                       CMXTA_DBG_ERR((_cmxtap,
                                                "rgAcUtlTfuValidatePdsch(): Grant"
                                                " and Datasize mismatch exp (%d) sending \
                                                (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                       ret = RFAILED;
                                    }
                                    cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                          "isVldRb", &isVldRb);
                                    cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                          "numTb1Rb", &numTb1Rb);
                                    if (isVldRb)
                                    {
                                       if (numRbs != numTb1Rb)
                                       {
                                          CMXTA_DBG_ERR((_cmxtap,
                                                   "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                                   " for TB1 are mismatch exp (%d) sending \
                                                   (%d)\n",numRbs,  numTb2Rb));
                                          ret = RFAILED;
                                       }
                                    }

                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_1A:
                           {
                              /* NOTE: Assuming that current and previous alloction
                                               * are both of type format 1A */
                              format1A = &(pdcchReq->dci.u.format1aInfo.t.pdschInfo.allocInfo);
                              rgAcUtlCalcRivInfo (format1A->alloc.u.riv, 
                                    rgAccCb.dlTotalBw, &rbStart, &numRb);
                              iTbs     = dlModTbsInxTbl[format1A->mcs].iTbs;
                              tbs      = tbsTbl[iTbs][numRb - 1];
#ifdef LTE_TDD                           
                                 if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                       RGAC_TDD_SPL_SUBFRAME)
                                 {
                                    tbs = tbsTbl[iTbs][MAX(numRb*3/4,1) - 1];   
                                 }
#endif 
                              if ((MsgLen)(tbs/8) != dataLen1)
                              {
#ifndef ALIGN_64BIT
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant and"
                                          " Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#else
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant"
                                          " and Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#endif
                                 ret = RFAILED;
                                 break;
                              }
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                   "isVldRb", &isVldRb);
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                   "numTb1Rb", &numTb1Rb);
                              if (isVldRb)
                              {
                                 if (numRb != numTb1Rb)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                        "for TB1 are mismatch exp (%d) sending \
                                        (%d)\n",numRb,  numTb2Rb));
                                    ret = RFAILED;
                                 }
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_1B:
                           {
                              /* NOTE: Assuming that current and previous alloction
                                            * are both of type format 1A */
                              format1B =  &(pdcchReq->dci.u.format1bInfo.allocInfo);
                              rgAcUtlCalcRivInfo (format1B->alloc.u.riv, 
                                    rgAccCb.dlTotalBw, &rbStart, &numRb);
                              iTbs     = dlModTbsInxTbl[format1B->mcs].iTbs;
                              tbs      = tbsTbl[iTbs][numRb - 1];
#ifdef LTE_TDD                           
                                 if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                       RGAC_TDD_SPL_SUBFRAME)
                                 {
                                    tbs = tbsTbl[iTbs][MAX(numRb*3/4,1) - 1];   
                                 }
#endif 
                              if ((MsgLen)(tbs/8) != dataLen1)
                              {
#ifndef ALIGN_64BIT
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant and"
                                          " Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#else
                                 CMXTA_DBG_ERR((_cmxtap, 
                                          "rgAcUtlTfuValidatePdsch(): Grant"
                                          " and Datasize mismatch exp (%d) sending (%d)\n",
                                          (int)(tbs/8), (int)dataLen1));
#endif
                                 ret = RFAILED;
                                 break;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2:
                           {
                              format2=  &(pdcchReq->dci.u.format2Info.allocInfo);
                              iTbs     = dlModTbsInxTbl[format2->tbInfo[0].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                  "numTb1Lyrs", &numTb1Lyrs);
                              if (format2->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                      "isVldRb", &isVldRb);
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                      "numTb1Rb", &numTb1Rb);
                                 if (isVldRb)
                                 {
                                    if (numRbs != numTb1Rb)
                                    {
                                       CMXTA_DBG_ERR((_cmxtap, 
                                           "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                           " for TB1 are mismatch exp (%d) sending \
                                           (%d)\n",numRbs,  numTb2Rb));
                                       ret = RFAILED;
                                    }
                                 }
                              }
                              else
                              {
                                 rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant and"
                                             " Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant"
                                             " and Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                       "isVldRb", &isVldRb);
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                       "numTb1Rb", &numTb1Rb);
                                 if (isVldRb)
                                 {
                                    if (numRbs != numTb1Rb)
                                    {
                                       CMXTA_DBG_ERR((_cmxtap,
                                                "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                                " for TB1 are mismatch exp (%d) sending \
                                                (%d)\n",numRbs,  numTb2Rb));
                                       ret = RFAILED;
                                    }
                                 }

                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2A:
                           {
                              format2A =  &(pdcchReq->dci.u.format2AInfo.allocInfo);
                              iTbs     = dlModTbsInxTbl[format2A->tbInfo[0].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                     "numTb1Lyrs", &numTb1Lyrs);
                              if (format2A->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb1Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen1)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant and"
                                             " Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#else
                                    CMXTA_DBG_ERR((_cmxtap,
                                             "rgAcUtlTfuValidatePdsch(): Grant"
                                             " and Datasize mismatch exp (%d) sending \
                                             (%d)\n",(int)(tbs/8), (int)dataLen1));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              break;
                           }   
                           default:
                           {
                              CMXTA_DBG_ERR((_cmxtap, "Invalid DCI format"
                                       " : expected format type 1 or 1A\n"));
                              ret = RFAILED;
                           }   
                        }
                     }                     
                  }
                  if (isTb2)
                  {
                     isTb2Retx = FALSE;
                     cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                              "isTb2Retx", &isTb2Retx);
                     if (isTb2Retx)
                     {
                        preDciFmt = &(prevPduInfo->dciInfo.format);
                        switch(*preDciFmt)
                        {
                           case TFU_DCI_FORMAT_2:
                           {
                              format2=  &(prevPduInfo->dciInfo.u.format2AllocInfo);
                              iTbs     = dlModTbsInxTbl[format2->tbInfo[1].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                      "numTb2Lyrs", &numTb2Lyrs);
                              if (format2->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen2)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen2));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen2));
#endif
                                    ret = RFAILED;
                                 }
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                      "isVldRb", &isVldRb);
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                      "numTb2Rb", &numTb2Rb);
                                 if (isVldRb)
                                 {
                                    /*Calculate Number of RBs from the current
                                     * Scheduled format2 */
                                    format2=  &(pdcchReq->dci.u.format2Info.allocInfo);
                                    rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                    if (numRbs != numTb2Rb)
                                    {
                                       CMXTA_DBG_ERR((_cmxtap, 
                                           "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                           " for TB2 are mismatch exp (%d) sending \
                                           (%d)\n",numRbs,  numTb2Rb));
                                       ret = RFAILED;
                                    }
                                 }
                              }
                              else
                              {
                                 CMXTA_DBG_ERR((_cmxtap, "Invalid resource \
                                   allocation type"" : expected RA type 0\n"));
                                 ret = RFAILED;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2A:
                           {
                              format2A =  &(prevPduInfo->dciInfo.u.format2AAllocInfo);
                              iTbs     = dlModTbsInxTbl[format2A->tbInfo[1].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                    "numTb2Lyrs", &numTb2Lyrs);
                              if (format2A->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen2)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen2));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen2));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                 CMXTA_DBG_ERR((_cmxtap, "Invalid resource \
                                   allocation type"" : expected RA type 0\n"));
                                 ret = RFAILED;
                              }
                              break;
                           }   
                           default:
                           {
                              CMXTA_DBG_ERR((_cmxtap, "Invalid DCI format"
                                       " : expected format type 1 or 1A\n"));
                              ret = RFAILED;
                           }   
                        }
                     }
                     else /* New Tx */
                     {
                        switch(dciFmt)
                        {
                           case TFU_DCI_FORMAT_2:
                           {
                              format2=  &(pdcchReq->dci.u.format2Info.allocInfo);
                              iTbs     = dlModTbsInxTbl[format2->tbInfo[1].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                      "numTb2Lyrs", &numTb2Lyrs);
                              if (format2->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2->resAllocMap[0],&numRbs,format2->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen2)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen2));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen2));
#endif
                                    ret = RFAILED;
                                 }
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,
                                      "isVldRb", &isVldRb);
                                 cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                      "numTb2Rb", &numTb2Rb);
                                 if (isVldRb)
                                 {
                                    if (numRbs != numTb2Rb)
                                    {
                                       CMXTA_DBG_ERR((_cmxtap, 
                                           "rgAcUtlTfuValidatePdsch(): NUM RBS"
                                           "for TB2 are mismatch exp (%d) sending \
                                           (%d)\n",numRbs,  numTb2Rb));
                                       ret = RFAILED;
                                    }
                                 }
                              }
                              else
                              {
                                 CMXTA_DBG_ERR((_cmxtap, "Invalid resource \
                                   allocation type"" : expected RA type 0\n"));
                                 ret = RFAILED;
                              }
                              break;
                           }
                           case TFU_DCI_FORMAT_2A:
                           {
                              format2A =  &(pdcchReq->dci.u.format2AInfo.allocInfo);
                              iTbs     = dlModTbsInxTbl[format2A->tbInfo[1].mcs].iTbs;
                              cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8,
                                        "numTb2Lyrs", &numTb2Lyrs);
                              if (format2A->isAllocType0)
                              {
                                 rgAcUtlTfuCalcRbs(&format2A->resAllocMap[0],&numRbs,format2A->isAllocType0);
                                 tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][numRbs - 1];
#ifdef LTE_TDD                           
                                    if (rgAcTddUlDlSf[ulDlCfg][datReq->timingInfo.subframe] == 
                                          RGAC_TDD_SPL_SUBFRAME)
                                    {
                                       tbs = tbsTbl2Lyr[numTb2Lyrs-1][iTbs][MAX(numRbs*3/4,1) - 1];   
                                    }
#endif                                    
                                 if ((MsgLen)(tbs/8) != dataLen2)
                                 {
#ifndef ALIGN_64BIT
                                    CMXTA_DBG_ERR((_cmxtap,
                                       "rgAcUtlTfuValidatePdsch(): Grant and"
                                       " Datasize mismatch exp (%d) sending \
                                       (%d)\n",(int)(tbs/8), (int)dataLen2));
#else
                                    CMXTA_DBG_ERR((_cmxtap, 
                                        "rgAcUtlTfuValidatePdsch(): Grant"
                                        " and Datasize mismatch exp (%d) sending \
                                        (%d)\n",(int)(tbs/8), (int)dataLen2));
#endif
                                    ret = RFAILED;
                                 }
                              }
                              else
                              {
                                 CMXTA_DBG_ERR((_cmxtap, "Invalid resource \
                                   allocation type"" : expected RA type 0\n"));
                                 ret = RFAILED;
                              }
                              break;
                           }   
                           default:
                           {
                              CMXTA_DBG_ERR((_cmxtap, "Invalid DCI format"
                                       " : expected format type 1 or 1A\n"));
                              ret = RFAILED;
                           }   
                        }
                     }                     
                  }
#endif  
               }/* End of if (use != 0) */
               if (ret == RFAILED)
               {
                  /* There is some error, break from the while loop */
                  CMXTA_DBG_ERR((_cmxtap, "Error in validation of PDSCH\n"));
                  break;
               }
            } /* End of if(chkgrant) */
         } /* End of if(validate) */
         if (chkCcchSh)
         {
            node = rgAcEdEvent->u.datPdu.subHdrs.first;
            while (node)
            {
               subHdr = (RgAcSubHeader*)node->node;
               if (subHdr->lcId == RG_CCCH_LCID)
                  break;
               node = node->next;
            }
            if (node == NULLP)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): No CCCH present\n"));
               break;
            }
         } /* end of if */
#ifdef LTE_ADV
         {
            if(chkSCellDeActCeReqd == TRUE)
            {
               subHdrNode = rgAcEdEvent->u.datPdu.subHdrs.first;
               ceNode = rgAcEdEvent->u.datPdu.ceOrSdus.first;

               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "deActCeVal", &deActCeVal);
               while ((subHdrNode) && (ceNode))
               {
                  subHdr = (RgAcSubHeader*)subHdrNode->node;
                  if (subHdr->lcId == RG_ACC_SCELL_ACT_CE)
                  {
                     /* If taVal is provided by the user check for value */
                     ce = (RgAcCEorSDU *)ceNode->node;
                     if (ce->u.rgAcCE.u.rgSCellAct.sCellAct != deActCeVal)
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch():Mismatch in activation value exp(%d) rcvd (%d)\n", 
                                 deActCeVal, ce->u.rgAcCE.u.rgSCellAct.sCellAct));
                        (Void)cmFreeMem((Ptr)rgAcEdEvent);
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }
                     break;
                  }
                  subHdrNode = subHdrNode->next;
                  ceNode = ceNode->next;
               } /* end of while */


            }
         
         }
#endif
         if (chkTA)
         {
            taVal = 9999;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "taVal", &taVal);
            subHdrNode = rgAcEdEvent->u.datPdu.subHdrs.first;
            ceNode = rgAcEdEvent->u.datPdu.ceOrSdus.first;
            while ((subHdrNode) && (ceNode))
            {
               subHdr = (RgAcSubHeader*)subHdrNode->node;
               if (subHdr->lcId == RG_ACC_TIMING_ADV_CE)
               {
                  /* If taVal is provided by the user check for value */
                  if (taVal != 9999)
                  {
                     ce = (RgAcCEorSDU *)ceNode->node;
                     if (ce->u.rgAcCE.u.rgAcTimingAdv.timingAdv != taVal)
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): TA Mismatch exp (%d) rcvd (%d)\n", 
                                 taVal, ce->u.rgAcCE.u.rgAcTimingAdv.timingAdv));
                        (Void)cmFreeMem((Ptr)rgAcEdEvent);
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }
                  }
                  break;
               }
               subHdrNode = subHdrNode->next;
               ceNode = ceNode->next;
            } /* end of while */
            if (subHdrNode == NULLP)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): No TA present\n"));
               break;
            }
         } /* end of TA */
         chkPadding = FALSE;
#ifndef CCPU_OPT      
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkPadding", &chkPadding);
         if (chkPadding)
         {
            padHdrs = 0;
            count = 0;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "padHdrs", &padHdrs);
            subHdrNode = rgAcEdEvent->u.datPdu.subHdrs.first;
            while (subHdrNode)
            {
               subHdr = (RgAcSubHeader*)subHdrNode->node;
               if (subHdr->lcId == RG_ACC_PADDING_CE)
               {
                  count++;
               }
               subHdrNode = subHdrNode->next;
            } /* end of while */
            if (count != padHdrs)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): No Padding present\n"));
               break;
            }

            chkPadBytes = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkPadBytes", &chkPadBytes);
            if (chkPadBytes)
            {
               /* we are expecting padBytes to exist */
               if (padBytes == 0)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): No Padding Bytes present not expected\n"));
                  break;
               }
            } /* end of padding bytes */
            else
            {
               if (padBytes != 0)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Padding  present not expected\n"));
                  break;
               }
            }
         } /* end of padding */
#endif      
         chkSdu = FALSE;
         chkSduTb2 = FALSE;
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkSdu", &chkSdu);
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkSduTb2", &chkSduTb2);
         if (chkSdu)
         {
            lcId = 1;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "lcId",  &lcId);
            subHdrNode = rgAcEdEvent->u.datPdu.subHdrs.first;
            while (subHdrNode)
            {
               subHdr = (RgAcSubHeader*)subHdrNode->node;
               if (subHdr->lcId == lcId)
                  break;
               subHdrNode = subHdrNode->next;
            }
            if (subHdrNode == NULLP)
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): No SDU present LcId (%d)\n", lcId));
               break;
            }
         } /* end of chkSdu */
         if (chkSduTb2)
         {
            lcIdTb2 = 1;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "lcIdTb2",  &lcIdTb2);
            subHdrNode = rgAcEdEvent2->u.datPdu.subHdrs.first;
            while (subHdrNode)
            {
               subHdr = (RgAcSubHeader*)subHdrNode->node;
               if (subHdr->lcId == lcIdTb2)
                  break;
               subHdrNode = subHdrNode->next;
            }
            if (subHdrNode == NULLP)
            {
               CMXTA_DBG_ERR((_cmxtap, "TB2:rgAcUtlTfuValidatePdsch(): No SDU present LcId (%d)\n", lcId));
               break;
            }
         } /* end of chkSdu */
#ifdef LTEMAC_SPS
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "DLSPSInit", &DLSPSInit);
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "DLSPSReInit",&DLSPSReInit);
         if (DLSPSReInit || DLSPSInit)
         {
            if ( pduInfo->rnti != ueCb->SPScrnti ) 
            {
               CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): SPS Init or"
                        "Re-init data recieved without SPS RNTI"));
               break;
            }
         }
         if ( pduInfo->rnti == ueCb->SPScrnti ) 
         {
            validateSPS = TRUE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "validateSPS", &validateSPS);
            isTb1 = TRUE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1", &isTb1);

            isTb2 = FALSE;
            cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1", &isTb1);

            if (validateSPS)
            {
               ret = ROK;
               chkGrant = TRUE;
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "chkGrant", &chkGrant);
               isSPSRetx = FALSE;
               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSPSRetx", &isSPSRetx);

               if (isSPSRetx)
               {
                  SPSretxUse = 9;
                  cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "SPSretxUse", &SPSretxUse);
                  if (SPSretxUse != 9)
                  {
                     prevPduInfo = &(rgAccCb.savedMsgs[SPSretxUse].u.pduInfo);
                  }
               }

               cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL,"ChkHarqProcId", &ChkHarqProcId);

               if(DLSPSInit)
               {
                  switch(pduInfo->dciInfo.format)
                  {
                     case TFU_DCI_FORMAT_1 :
                     case TFU_DCI_FORMAT_1A:
                     case TFU_DCI_FORMAT_2 :
                     case TFU_DCI_FORMAT_2A: break;
                     default:
                                             CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): INVALID DCI Format :Expected Formats are [1,1A,2,2A] Recieved format %d \n", pduInfo->dciInfo.format));
                                             ret = RFAILED;
                  }
               }
               if (chkGrant)
               {

                  if(ChkHarqProcId)
                  {
                     ret = rgAcUtlCheckTfuHarqProcId(tcCb,spCb,pduInfo,&datReq->timingInfo);
                     if ( ret != ROK )
                     {
                        CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Missmatch  in the Hq Proc expected"));
                        RETVALUE(CMXTA_ERR_NOMATCH);
                     }
                  } 

                  if(!(DLSPSInit||DLSPSReInit))
                  {
                     if(isSPSRetx)
                     {
                        if (ueCb->SPScrnti != prevPduInfo->rnti )
                        {
                           CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Missmatch  in the RNTI value : Expected = %x Recieved  %x \n", ueCb->crnti, prevPduInfo->rnti));
                        }
                           switch(pduInfo->dciInfo.format)
                           {
                              case TFU_DCI_FORMAT_1:
                                 if (pduInfo->dciInfo.u.format1AllocInfo.ndi != 1)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch():ND1 != 1 " ));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_1A:
                                 if (pduInfo->dciInfo.u.format1aAllocInfo.ndi != 1)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch():ND1 != 1 " ));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_2:
                                 if (pduInfo->dciInfo.u.format2AllocInfo.tbInfo[0].ndi != 1)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch():ND1 != 1 " ));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_2A:
                                 if (pduInfo->dciInfo.u.format2AAllocInfo.tbInfo[0].ndi != 1)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch():ND1 != 1 " ));
                                 }
                                 break;
                              default: /* ERROR*/
                                 CMXTA_DBG_ERR((_cmxtap,"rgAcUtlTfuValidatePdsch():\
                                          INVALID dci format in SPS "));
                           }
                        if (ChkHarqProcId) 
                        {
                           switch(prevPduInfo->dciInfo.format)
                           {
                              case TFU_DCI_FORMAT_1:
                                 if (pduInfo->dciInfo.u.format1AllocInfo.harqProcId != 
                                       prevPduInfo->dciInfo.u.format1AllocInfo.harqProcId)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                             INVALID HARQ Process Id Expected = %d Recieved \
                                             %d \n",prevPduInfo->dciInfo.u.format1AllocInfo.harqProcId,
                                             pduInfo->dciInfo.u.format1AllocInfo.harqProcId ));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_1A:
                                 if (pduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val!= 
                                       prevPduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                             INVALID HARQ Process Id Expected = %d Recieved \
                                             %d \n",prevPduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val,
                                             pduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val ));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_2:
                                 if (pduInfo->dciInfo.u.format2AllocInfo.harqProcId != 
                                       prevPduInfo->dciInfo.u.format2AllocInfo.harqProcId)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                             INVALID HARQ Process Id Expected = %d Recieved \
                                             %d \n",prevPduInfo->dciInfo.u.format2AllocInfo.harqProcId,
                                             pduInfo->dciInfo.u.format2AllocInfo.harqProcId));
                                 }
                                 break;
                              case TFU_DCI_FORMAT_2A:
                                 if (pduInfo->dciInfo.u.format2AAllocInfo.harqProcId!= 
                                       prevPduInfo->dciInfo.u.format2AAllocInfo.harqProcId)
                                 {
                                    CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                             INVALID HARQ Process Id Expected = %d Recieved \
                                             %d \n",prevPduInfo->dciInfo.u.format2AAllocInfo.harqProcId,
                                             pduInfo->dciInfo.u.format2AAllocInfo.harqProcId));
                                 }
                                 break;
                              default: /* ERROR*/
                                 CMXTA_DBG_ERR((_cmxtap,"rgAcUtlTfuValidatePdsch():\
                                          INVALID dci format in SPS "));
                           } /*end of switch*/
                        }
                     }
                  }
                  else
                  {
                     if(isTb1 && isTb2 )
                     {
                        CMXTA_DBG_ERR((_cmxtap,"rgAcUtlTfuValidatePdsch(): INVALID TB's enabled in SPS \n "));
                     }
                     else if (isTb1)
                     {
                        TbIdx = 0;
                     }
                     else
                     {
                        TbIdx = 1;
                     }
                     /*do same int the Validate Dci Format */
                     switch(pduInfo->dciInfo.format)
                     {
                        /*take the eNUm values */
                        case TFU_DCI_FORMAT_1:
                           if(pduInfo->dciInfo.u.format1AllocInfo.ndi != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): INVALID NDI \
                                       Expected = 0 Recieved  1 \n"));
                           }
                           if (pduInfo->dciInfo.u.format1AllocInfo.harqProcId != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID HARQ Process Id Expected = 0 Recieved \
                                       %d \n",pduInfo->dciInfo.u.format1AllocInfo.harqProcId ));
                           }
                           if ((pduInfo->dciInfo.u.format1AllocInfo.mcs>>4) != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           if (pduInfo->dciInfo.u.format1AllocInfo.rv != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           break;
                        case TFU_DCI_FORMAT_1A:
                           if(pduInfo->dciInfo.u.format1aAllocInfo.ndi != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): INVALID NDI \
                                       Expected = 0 Recieved  1 \n"));
                           }
                           if (pduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID HARQ Process Id Expected = 0 Recieved \
                                       %d \n",pduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val ));
                           }
                           if ((pduInfo->dciInfo.u.format1aAllocInfo.mcs>>4) != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           if (pduInfo->dciInfo.u.format1aAllocInfo.rv != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           break;
                        case TFU_DCI_FORMAT_2:
                           if(pduInfo->dciInfo.u.format2AllocInfo.tbInfo[TbIdx].ndi != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): INVALID NDI \
                                       Expected = 0 Recieved  1 \n"));
                           }
                           if (pduInfo->dciInfo.u.format2AllocInfo.harqProcId != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID HARQ Process Id Expected = 0 Recieved \
                                       %d \n",pduInfo->dciInfo.u.format2AllocInfo.harqProcId));
                           }
                           if ((pduInfo->dciInfo.u.format2AllocInfo.tbInfo[TbIdx].mcs>>4) != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           if (pduInfo->dciInfo.u.format2AllocInfo.tbInfo[TbIdx].rv != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           break;
                        case TFU_DCI_FORMAT_2A:
                           if(pduInfo->dciInfo.u.format2AAllocInfo.tbInfo[TbIdx].ndi != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): INVALID NDI \
                                       Expected = 0 Recieved  1 \n"));
                           }
                           if (pduInfo->dciInfo.u.format2AAllocInfo.harqProcId != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID HARQ Process Id Expected = 0 Recieved \
                                       %d \n",pduInfo->dciInfo.u.format2AAllocInfo.harqProcId ));
                           }
                           if ((pduInfo->dciInfo.u.format2AAllocInfo.tbInfo[TbIdx].mcs>>4) != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID MCS Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           if (pduInfo->dciInfo.u.format2AAllocInfo.tbInfo[TbIdx].rv  != 0)
                           {
                              CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): \
                                       INVALID RV Index Id: Expected = 0 Recieved 1 \n" ));
                           }
                           break;
                        default: /* ERROR*/
                           CMXTA_DBG_ERR((_cmxtap,"rgAcUtlTfuValidatePdsch():\
                                    INVALID dci format in SPS "));
                     } /*end of switch*/
                  } /*end of if*/
               }/*if (chkGrant)*/
            } /*validateSPS*/
         } /*if ( pduInfo->rnti == ueCb->SPScrnti ) */
#endif /*LTEMAC_SPS*/
         if (pduInfo->mBuf[0] != NULLP)
         {
            SPutMsg(pduInfo->mBuf[0]);
            pduInfo->mBuf[0] = NULLP;
         }
         if (pduInfo->mBuf[1] != NULLP)
         {
            SPutMsg(pduInfo->mBuf[1]);
            pduInfo->mBuf[1] = NULLP;
         }
         cmLListDelFrm(&datReq->pdus, &pduInfo->lnk);
#ifdef LTEMAC_MIMO
         if (isTb1)
            (Void)cmFreeMem((Ptr)rgAcEdEvent);
         if (isTb2)
            (Void)cmFreeMem((Ptr)rgAcEdEvent2);
#else
         (Void)cmFreeMem((Ptr)rgAcEdEvent);
#endif
#ifdef TFU_UPGRADE
         if(chkPa)
         {
            if(ueCb->dlpcInfo.pA != pduInfo->pa)
            {
               CMXTA_DBG_ERR((_cmxtap,"rgAcUtlTfuValidatePdsch():\
                        Pa did not match: exp(%d) recved(%d)\n",
                        ueCb->dlpcInfo.pA, pduInfo->pa));
            }
         }
#endif
         RETVALUE(CMXTA_ERR_NONE);
      } /* end of If RNTIs match */
      node = node->next;
   } /* end of while */
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidatePdsch(): Did not find rnti (%d) \n",
            ueCb->crnti));
   if (rgAcEdEvent != NULLP)
      (Void)cmFreeMem((Ptr)rgAcEdEvent);
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidatePdsch */


 /** @brief This function validates the RA Response PDU sent from MAC to
  * Physical layer.
  *
  * @details
  * This is the lower-level handler and just validates the RA Response PDU for a
  * single RA-RNTI.
  *
  *     Function: 
  *
  *         Processing steps:
  *         - Look for a PDU having the same RA-RNTI as needed.
  *            - if matched proceed to validate other attributes 
  *            - else move to the next node
  *         Optimization could entail deleting the matched node from 
  * 
  * @param  tcCb pointer to CmXtaTCCb
  * @param  spCb pointer to CmXtaSpCb
  * @param  datReq pointer to TfuDatReqInfo
  * @return CMXTA_ERR_NONE/CMXTA_ERR_INT/CMXTA_ERR_NOMATCH
  */
#ifdef ANSI
PUBLIC S16  rgAcUtlTfuValidateRaRsp
(
 CmXtaTCCb           *tcCb,
 CmXtaSpCb           *spCb,
 TfuDatReqInfo       *datReq
 )
#else
PUBLIC S16  rgAcUtlTfuValidateRaRsp (tcCb, spCb, datReq)
 CmXtaTCCb           *tcCb;
 CmXtaSpCb           *spCb;
 TfuDatReqInfo       *datReq;
#endif
{
   S16               ret;
   CmLList           *node;
   CmLList           *subHdrNode;
   CmLList           *pduNode;
   CmLteRnti         rnti;
   TfuDatReqPduInfo  *pduInfo;
   RgAcEdEvent       *rgAcEdEvent;
   U8                nmbOfRar, biVal=0;
   U8                raRapIds[TFU_MAX_RAPID_IN_SUBFRAME];
   U16               tas[TFU_MAX_RAPID_IN_SUBFRAME];
   U32               ulGrants[TFU_MAX_RAPID_IN_SUBFRAME];
   RgAcRaSubHdr      *rarSubHdr;
   RgAcRarHdrs       *rarPdu;
   RgAcRarPdu        *rgAcRarPdu;
   RgAcPhyRaCb       *acPhyRaCb;       
   U8                raRnti;
   U8                num;
   Bool              bi, biPres, expectAll;/* Set to TRUE if all the RAP-IDs in the request 
                                  are expected in the response, else it is FALSE */
   Bool              uniqueRntiVldt = TRUE;

   TRC2(rgAcUtlTfuValidateRaRsp);

   rgAcEdEvent    = NULLP;
   nmbOfRar       = 0;
   expectAll      = TRUE;
   biPres         = FALSE;
   bi             = FALSE;
   node = datReq->pdus.first;

   /* RA-RNTI can be 0 - 10 only, we can pick anyone doesnt quite matter */
   rnti    = RG_ACC_RA_RNTI;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
         "raRnti", &raRnti);

   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
         "uniqueRntiVldt", &uniqueRntiVldt);
   while (node)
   {
      pduInfo = (TfuDatReqPduInfo *)node->node;
      /* Check if falls within the range of RA-RNTI */
#ifdef LTE_TDD
      if ((pduInfo->rnti < 61) && 
#else
      if ((pduInfo->rnti < 11) && 
#endif
            (pduInfo->rnti == rgAccCb.acRaCb[pduInfo->rnti].raRnti))
      {
         /* This request is coming from MAC, we need to validate the following 
          * 1. RAR PDU for the RAP ID and UL Grant or possibly a BI
          * 2. Possibly DCI info needs validation. 
          */
         if ((ret = rgAcUtlDecodeRarPdu ((pduInfo->mBuf[0]), &rgAcEdEvent, &biPres)) != ROK)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateRaRsp(): Decode RAR failed\n"));
            RETVALUE(CMXTA_ERR_INT);
         }
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "nmbOfRar",  &nmbOfRar);

         /* Planning to get the values as lists of rapIds, timingAdvs, and ulGrant
          * expected. 
          * We need to read an array of RA request infos from the XML 
          * <tapa.expect>
          *    <tapa.tfu.raresp.req raRnti="1" numRaReq="2" rapIds="1:2" tas="2:2" ulGrant="3:0".../>
          * </tapa.expect>
          */

         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rapIds", raRapIds, &num);

         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, CMXTA_SEP_COLON, 
               "timingAdvs", tas, &num);

         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U32, CMXTA_SEP_COLON, 
               "ulGrant", ulGrants, &num);

         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
               "expectAll", &expectAll);

         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
               "bi", &bi);
         cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "biVal", &biVal);
         if (bi != biPres)
         {
            CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateRaRsp(): BI validation failed\n"));
            RETVALUE(CMXTA_ERR_INT);
         }

         rgAcRarPdu = &(rgAcEdEvent->u.rarPdu);

         acPhyRaCb   = &(rgAccCb.acRaCb[pduInfo->rnti]);
         if (expectAll)
         {
            U32 raRapIdRspCnt = rgAcRarPdu->raSubHdrs.count;
            if (biPres)
            {
               /* If BI Subheader present then RAR cnt is 1 less */
               raRapIdRspCnt--;
            }
            if (raRapIdRspCnt != acPhyRaCb->numRaReqInfo)
            {
               CMXTA_DBG_ERR((_cmxtap, 
                        "rgAcUtlTfuValidateRaRsp(): Fewer number of RAP Ids!\n"));
               break;
            }
         }

         /* We do need to store the tempCrnti that goes out, we need these to create
          * the message 3 and also this has to be used by the RRC to configure the UE.
          */
         subHdrNode = rgAcRarPdu->raSubHdrs.first;
         pduNode    = rgAcRarPdu->rarPdus.first;
         while (subHdrNode)
         {
            rarSubHdr = (RgAcRaSubHdr *)subHdrNode->node;
            /* if BI Present then do special validation for first subheader */
            if (biPres)
            {
               if (biVal != rarSubHdr->u.bi)
               {
                  CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateRaRsp(): BI validation failed\n"));
                  RETVALUE(CMXTA_ERR_INT);
               }
               biPres = FALSE;
               subHdrNode = subHdrNode->next;
               continue;
            }
            rarPdu = (RgAcRarHdrs *)pduNode->node;
            /* Get the corresponding RgAcRachCb from the array, raRnti is the index into
             * that array. 
            acPhyRaCb   = &(rgAccCb.acRaCb[rnti]);
             */
            /* Issue is that we need to loop through all the rapIds to find if anyone
             * matches as the order may not be the same as the request.
             */
            if ((ret = rgAcUtlMatchRapId (rarSubHdr->u.rapId, 
                        rarPdu->timingAdv, acPhyRaCb)) == CMXTA_ERR_NOMATCH)
            {
               CMXTA_DBG_ERR((_cmxtap, 
                        "rgAcUtlTfuValidateRaRsp(): RAP ID and timing Adv didnt match!\n"));
               goto NoMatchBlock;
            }
            if(rarPdu->tempCrnti < RG_ACC_DED_RNTI_START)
            {
               if(uniqueRntiVldt)
               {
                  if (TRUE == rgAcUtlMatchRnti (tcCb, spCb, rarPdu->tempCrnti))
                  {
                     CMXTA_DBG_ERR((_cmxtap, 
                              "rgAcUtlTfuValidateRaRsp(): Not a Unique Rnti (%d)!\n", rarPdu->tempCrnti));
                     goto NoMatchBlock;
                  }
               }
               /* Lets store the tempCrnti allocated by MAC into the UE control block. */
               rgAccCb.acUeCb[rgAccCb.nmbOfUes].crnti = rarPdu->tempCrnti;
               cmLListInit(&(rgAccCb.acUeCb[rgAccCb.nmbOfUes].staIndLst));
               rgAccCb.acUeCb[rgAccCb.nmbOfUes++].lastUlGrant = rarPdu->ulGrant;
            }
            else
            {
               U8 ueIdx=0;
               for(;ueIdx < rgAccCb.nmbOfUes; ueIdx++)
               { 
                  if(rgAccCb.acUeCb[ueIdx].crnti == rarPdu->tempCrnti)
                  {
                     rgAccCb.acUeCb[ueIdx].lastUlGrant = 
                         rarPdu->ulGrant;
                     break;
                  }
                }
                if(ueIdx == rgAccCb.nmbOfUes)
                {
                   CMXTA_DBG_ERR((_cmxtap, 
                        "rgAcUtlTfuValidateRaRsp(): Not a Unique HO Rnti (%d)!\n", rarPdu->tempCrnti));
                   goto NoMatchBlock;
                }
            }
            /* Now we shall check for the grant that goes out in the Response. */
            if ((ret = rgAcUtlValidateRarGrant (rarPdu->ulGrant, tcCb, spCb)) == CMXTA_ERR_NOMATCH)
            {
               CMXTA_DBG_ERR((_cmxtap, 
                        "rgAcUtlTfuValidateRaRsp(): RAR Grant incorrect !\n"));
               goto NoMatchBlock;
            }
            subHdrNode = subHdrNode->next;
            pduNode = pduNode->next;
         } /* end of for loop */ 
         /* If we reach here it seems we have a match */
         cmLListDelFrm(&datReq->pdus, node);
         (Void)cmFreeMem((Ptr)rgAcEdEvent);
         RETVALUE(CMXTA_ERR_NONE);
      } /* if RNTIs match */
      node = node->next;
   } /* end of while */
NoMatchBlock:
   /* If we reached here we didn't get a perfect match */
   CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuValidateRaRsp(): Did not find rnti (%d) \n",
            raRnti));
   if (rgAcEdEvent != NULLP)
      (Void)cmFreeMem((Ptr)rgAcEdEvent);
   RETVALUE(CMXTA_ERR_NOMATCH);
} /* end of rgAcUtlTfuValidateRaRsp */

/** @brief This function would call upon all the low level handlers of Data
 * indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuDatIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  datInd pointer to TfuDatIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDatIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuDatIndInfo    *datInd
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDatIndMsg (tcCb, spCb, pst, suId, datInd)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuDatIndInfo    *datInd;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildDatIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDatIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDatIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToMacPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   datInd->cellId  = RG_ACC_CELL_ID;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(datInd->cellId));

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.dat.ind> command. Processing is as follows 
    * - Store the datInd structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(datInd); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&datInd->datIndLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDatIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDatIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into datInd */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
#ifdef LTE_TDD
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, datInd->timingInfo, 3);
#else
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, datInd->timingInfo, 2);
#endif
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, datInd->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildDatIndMsg */

/** @brief This function is responsible to building a datInd information for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of datInd handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuDatInfo
 *         - Allocate a new event structure
 *         - Populate the event structure
 *         - Encode the event into a mBuf
 *         - assign this mBuf to the new node and add to the linked list.
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDat
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuDatIndInfo    *datInd
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDat (tcCb, spCb, datInd)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuDatIndInfo    *datInd;
#endif
{
   S16            ret;
   TfuDatInfo     *newNode;
   Mem            evntMem;
   RgAcEdEvent    *evnt;
   Bool           addPhr;
   Bool           addExtPhr;
   Bool           addCrnti;
   Bool           addTruncBsr;
   Bool           addShortBsr;
   Bool           addLongBsr;
   Bool           isCcchSdu;
   Bool           noSubHdrs;
   Bool           swpCESDU;
   Bool           invLen;
   Bool           invEBit;
   Bool           addInvPad1;
   Bool           addInvPad2;
   Bool           addInvPad3;
   Bool           addInvPad4;
   U8             use;
   U8             lcId = 31;
   U16            tbs = 0;
   U8             lcIds[10];
   U16            sduSzs[10];
   U16            oneSduSz=0;
   U8             num;
   U8             numSdu;
   U8             i;
   U8             ueId;
   U8             addPad = 0;
   S8             dedBufIdx;
   U8             bufIdx=0;
#ifdef LTEMAC_SPS
   Bool           isSpsRnti = FALSE;
#endif

   TRC2(rgAcUtlTfuBuildDat);
   ret = CMXTA_ERR_NONE;

   addPhr      = FALSE;
   addCrnti    = FALSE;
   addTruncBsr = FALSE;
   addLongBsr  = FALSE;
   addShortBsr = FALSE;
   isCcchSdu   = FALSE;
   noSubHdrs   = FALSE;
   swpCESDU    = FALSE;
   invLen      = FALSE;
   invEBit     = FALSE;
   use         = 0;

   /* allocate the new node */
   cmGetMem ((Ptr)&(datInd->memCp), sizeof(TfuDatInfo), (Ptr*)&newNode);
   /* We need to first create the event structure, and populate it. */
   evntMem.region = cmXtaCb.init.region;
   evntMem.pool   = cmXtaCb.init.pool;
   if (cmAllocEvnt (sizeof (RgAcEdEvent), 2000, &evntMem, (Ptr*)&evnt) != ROK)
   {
      CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuBuildDat(): resource error\n"));
      RETVALUE(CMXTA_ERR_RSRC);
   }
   
   cmLListInit (&(evnt->u.datPdu.subHdrs));
   cmLListInit (&(evnt->u.datPdu.ceOrSdus));

   evnt->type = RG_ACC_DAT_PDU;

   /* Now on we have to read the XML to add CE or MAC PDUs */
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "use",  &use);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "bufIdx",  &bufIdx);
   dedBufIdx = bufIdx;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "lcId",  &lcId);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isCcchSdu",  &isCcchSdu);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addPhr",  &addPhr);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addExtPhr",  &addExtPhr);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addCrnti",  &addCrnti);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addTruncBsr",  &addTruncBsr);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addShortBsr",  &addShortBsr);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addLongBsr",  &addLongBsr);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "noSubHdrs",  &noSubHdrs);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "swpCESDU",  &swpCESDU);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "invLen",  &invLen);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "invEBit",  &invEBit);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "addPad",  &addPad);
   addInvPad1 = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addInvPad1",  &addInvPad1);
   addInvPad2 = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addInvPad2",  &addInvPad2);
   addInvPad3 = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addInvPad3",  &addInvPad3);
   addInvPad4 = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "addInvPad4",  &addInvPad4);
   /* Changes for De-mux test case execution */
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "lcIds", lcIds, &num);

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U16, CMXTA_SEP_COLON, 
         "sduSzs", sduSzs, &numSdu);

   if (noSubHdrs == TRUE)
   {
      /* Simple - send a Buffer of any size to MAC */
      if (SGetMsg (cmXtaCb.init.region, cmXtaCb.init.pool, &(newNode->mBuf)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuBuildDat(): resource error\n"));
         RETVALUE (CMXTA_ERR_RSRC);
      }

      if((ret = SAddPstMsgMult ((Data *)&junkData, 10, newNode->mBuf)) != ROK)
      {
         SPutMsg(newNode->mBuf);
         newNode->mBuf = NULLP;
         CMXTA_DBG_FATAL((_cmxtap, "rgAcUtlTfuBuildDat(): resource error\n"));
         RETVALUE (CMXTA_ERR_INT);
      }
      RETVALUE (CMXTA_ERR_NONE);
   }
   /* In the case were we shall be using a saved message to give us the UL Grant
    * information we have to construct the PDU based on that line.
    */
   if (use)
   {
      if ((ret = rgAcUtlUseUlGrant (&tbs, use)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Power head room CE\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addPad != 0)
   {
      for ( i = 0; i < addPad; i++)
      {
         if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
         {
            CMXTA_DBG_FATAL((_cmxtap, 
                     "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
            RETVALUE(CMXTA_ERR_RSRC);
         }
      }
   }

   if (addExtPhr == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_EXT_PWR_HDR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Power head room CE\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addPhr == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_PWR_HDR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Power head room CE\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addCrnti == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_CRNTI_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add CRNTI CE\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addTruncBsr == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_TBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Truncated BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addLongBsr == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_LBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable tp add Long BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addShortBsr == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_SBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }
    if (addInvPad1 == TRUE)
   {
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_SBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }

   if (addInvPad2 == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_SBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }
   if (addInvPad3 == TRUE)
   {
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, tbs, 2)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }
   if (addInvPad4 == TRUE)
   {
      if ((ret = rgAcUtlAddCeToEvnt (tcCb, spCb, evnt, &tbs, RG_ACC_SBSR_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, tbs, 2)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add Short BSR\n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, 1, RG_ACC_PADDING_CE)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add PADDING \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
      tbs = 0;
   }
   if (isCcchSdu == TRUE)
   {
      if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, tbs, RG_ACC_CCCH_SDU)) != ROK)
      {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to add CCCH SDU \n"));
         RETVALUE(CMXTA_ERR_RSRC);
      }
   }
   if ((addInvPad1 != TRUE) &&
         (addInvPad2 != TRUE) &&
         (addInvPad4 != TRUE) &&
         (addInvPad3 != TRUE))
   {
      if ((tbs != 0) && (use != 0))
      {
         if (num != 0)
         {
            if (numSdu == 0)
            {
               oneSduSz = tbs / num;
            }
            for (i = 0; i < num; i++)
            {
               if (numSdu != 0)
                  oneSduSz = sduSzs[i];
               if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, (U16)(oneSduSz * 8), lcIds[i])) != ROK)
               {
                  CMXTA_DBG_FATAL((_cmxtap, 
                           "rgAcUtlTfuBuildDat(): Unable to add CCCH SDU \n"));
                  RETVALUE(CMXTA_ERR_RSRC);
               }
               tbs -= oneSduSz;
            }
         }
         else
         {
            /* Always the last header so add a padding of length (tbs - 1) */
            if ((ret = rgAcUtlAddHdrPduToEvnt (tcCb, spCb, evnt, (U16)(tbs - 1), lcId)) != ROK)
            {
               CMXTA_DBG_FATAL((_cmxtap, 
                        "rgAcUtlTfuBuildDat(): Unable to add CCCH SDU \n"));
               RETVALUE(CMXTA_ERR_RSRC);
            }
            tbs = 0;
         }
      }

      if ((tbs > 0) && (swpCESDU == FALSE) && (addPad == 0))
      {
         if ((ret = rgAcUtlHandlePadding (tcCb, spCb, evnt, tbs)) != ROK)
         {
            CMXTA_DBG_FATAL((_cmxtap, 
                     "rgAcUtlTfuBuildDat(): Unable to encode the PDU \n"));
            RETVALUE(CMXTA_ERR_INT);
         }
      }
   }

   if ((ret = rgAcUtlEncodeDatPdu (evnt, &(newNode->mBuf),  swpCESDU, invEBit, invLen, dedBufIdx)) != ROK)
   {
         CMXTA_DBG_FATAL((_cmxtap, 
                  "rgAcUtlTfuBuildDat(): Unable to encode the PDU \n"));
         RETVALUE(CMXTA_ERR_RSRC);
   }
   /* Now we can free the event structure */
   (Void)cmFreeMem((Ptr)evnt);
   /* Add new node to the linked list */
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
#ifdef LTEMAC_SPS
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isSpsRnti",  &isSpsRnti);
   if(isSpsRnti)
   {
      newNode->rnti = rgAccCb.acUeCb[ueId].SPScrnti;
   }
   else
#endif
   {
      newNode->rnti = rgAccCb.acUeCb[ueId].crnti;
   }
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(datInd->datIndLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildDat */ 

/** @brief This function would call upon all the low level handlers of Data
 * indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuPucchDeltaPwrIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  pucchDeltaPwrIndInfo pointer to TfuPucchDeltaPwrIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildPucchDeltaIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuPucchDeltaPwrIndInfo     *pucchDeltaPwrIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildPucchDeltaIndMsg (tcCb, spCb, pst, suId, pucchDeltaPwrIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuPucchDeltaPwrIndInfo     *pucchDeltaPwrIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildPucchDeltaIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildPucchDeltaIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildPucchDeltaIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   pucchDeltaPwrIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the pucchDeltaPwrIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(pucchDeltaPwrIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&pucchDeltaPwrIndInfo->pucchDeltaPwrLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildPucchDeltaIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildPucchDeltaIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into pucchDeltaPwrIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, pucchDeltaPwrIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, pucchDeltaPwrIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildPucchDeltaIndMsg */

/** @brief This function is responsible to building a PUCCH delta for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of PUCCH delta Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuPucchDeltaPwr
 *         - Add to the linked list of pucchDeltaLst
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildPucchDelta
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuPucchDeltaPwrIndInfo *pucchDeltaIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildPucchDelta (tcCb, spCb, pucchDeltaIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuPucchDeltaPwrIndInfo *pucchDeltaIndInfo;
#endif
{
   TfuPucchDeltaPwr     *newNode;
   U8                   ueId;
   U8                   tempPwr;

   TRC2(rgAcUtlTfuBuildPucchDelta);

   /* allocate the new node */
   cmGetMem ((Ptr)&pucchDeltaIndInfo->memCp, sizeof(TfuPucchDeltaPwr), (Ptr*)&newNode);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;
   newNode->pucchDeltaPwr = 0;
   /* ATTRIB_S8 did not work, so assuming user provided 
    * value which is an offset to -127.*/
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "pucchDeltaPwr",
         &tempPwr);
   newNode->pucchDeltaPwr = -127 + tempPwr;
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&pucchDeltaIndInfo->pucchDeltaPwrLst, &newNode->lnk);
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildPucchDelta */


/** @brief This function would call upon all the low level handlers of Data
 * indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuHqIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  hqIndInfo pointer to TfuHqIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildHqIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuHqIndInfo     *hqIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildHqIndMsg (tcCb, spCb, pst, suId, hqIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuHqIndInfo     *hqIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildHqIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildHqIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildHqIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   hqIndInfo->cellId  = RG_ACC_CELL_ID;

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(hqIndInfo->cellId));
   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the hqIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(hqIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&hqIndInfo->hqIndLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildHqIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildHqIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into hqIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, hqIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, hqIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildHqIndMsg */

/** @brief This function is responsible to building a HARQ feedback for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of HARQ Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuHqInfo
 *         - Add to the linked list of hqIndLst
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildHq
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuHqIndInfo     *hqIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildHq (tcCb, spCb, hqIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuHqIndInfo    *hqIndInfo;
#endif
{
   TfuHqInfo     *newNode;
   U8             ueId;
#ifdef TFU_TDD
   U8             num;
   U8             fbkLst[9];
   U8             indx;
#endif
#ifdef LTEMAC_MIMO
   Bool          isTb1 = TRUE;
   Bool          isTb2 = FALSE;
#ifndef TFU_TDD
#ifdef TFU_UPGRADE
   Bool          fdbk=TRUE;
#endif
#endif
#endif

   TRC2(rgAcUtlTfuBuildHq);

   /* allocate the new node */
   cmGetMem ((Ptr)&(hqIndInfo->memCp), sizeof(TfuHqInfo), (Ptr*)&newNode);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;

#ifdef TFU_UPGRADE
#ifdef TFU_TDD
#ifdef LTEMAC_SPS
   newNode->isPusch = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isPusch",
         &newNode->isPusch);
#endif
#endif
#endif
#ifndef TFU_TDD
#ifndef LTEMAC_MIMO

#ifndef TFU_UPGRADE
   newNode->isAck[0] = TRUE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAck",  &(newNode->isAck[0]));
#else
   newNode->isAck[0] = TRUE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAck",  &(newNode->isAck[0]));
#endif /* TFU_UPGRADE */
#else /* LTEMAC_MIMO */
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1", &isTb1);   
   if (isTb1)
   {

#ifndef TFU_UPGRADE
      newNode->isAck[0] = TRUE;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAck",  &(newNode->isAck[0]));
#else
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, "isAck",  &(fdbk));
      newNode->isAck[0] = (TfuHqFdbk)fdbk;
#endif /* TFU_UPGRADE */
   }
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb2", &isTb2);
   if (isTb2)
   {

#ifndef TFU_UPGRADE
      newNode->isAck[1] = TRUE;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAckTb2",  &(newNode->isAck[1]));   
#else
      newNode->isAck[1] = TFU_HQ_ACK;
      fdbk = TFU_HQ_ACK;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAckTb2",  &(fdbk));
      newNode->isAck[1] = (TfuHqFdbk)fdbk;
#endif /* TFU_UPGRADE */
   }
#endif
#ifdef LTE_ADV
/* CA Dev Start*/
   U8  is1BWithCs = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "is1BWithCs",&is1BWithCs);
   if (is1BWithCs)
   {
      cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U32, CMXTA_SEP_COLON,
            "hqBits",newNode->isAck, &is1BWithCs);
   }
/*CA Dev End*/
#endif
#else /* TFU_TDD */
   newNode->M = 4;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "M",  &newNode->M);
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, "ackNackModeEnum", 
         &(newNode->hqFdbkMode));
#ifndef LTEMAC_MIMO
   newNode->isAck[0] = TRUE;
   CMXTA_ZERO(fbkLst, sizeof(U8) * 8);
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, CMXTA_SEP_COLON, 
         "isAckLst", fbkLst, &num);
   for (indx = 0; (indx < num) && (indx < 8); indx++)
   {

#ifdef TFU_UPGRADE
      newNode->isAck[indx] = (TfuHqFdbk)fbkLst[indx];
#else
      newNode->isAck[indx] = fbkLst[indx];
#endif
   }
#else /* LTEMAC_MIMO */
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb1", &isTb1);   
   if (isTb1)
   {
      /*solaris fixes for g++ compilation  */
#ifdef TFU_UPGRADE
      newNode->isAck[0] =(TfuHqFdbk) TRUE;
#else
      newNode->isAck[0] = (U8)TRUE;
#endif

      cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, CMXTA_SEP_COLON, 
            "isAckLst", fbkLst, &num);
      for (indx = 0; (indx < num) && (indx < 8); indx++)
      {

#ifdef TFU_UPGRADE
         newNode->isAck[indx] = (TfuHqFdbk)fbkLst[indx];
#else
         newNode->isAck[indx] = fbkLst[indx];
#endif
      }
   }
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isTb2", &isTb2);   
   if (isTb2)
   {
      /*solaris fixes for g++ compilation  */
#ifdef TFU_UPGRADE
      newNode->isAck[1] =(TfuHqFdbk) TRUE;
#else
      newNode->isAck[1] = (U8)TRUE;
#endif
      cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, CMXTA_SEP_COLON, 
         "isAckLstTb2", fbkLst, &num);
      for (indx = 0; indx < num && indx < 8; indx++)
      {

#ifdef TFU_UPGRADE
         newNode->isAck[indx] = (TfuHqFdbk)fbkLst[indx];
#else
         newNode->isAck[indx] = fbkLst[indx];
#endif
      }
   }
#endif /* LTEMAC_MIMO */
#endif /* TFU_TDD */
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(hqIndInfo->hqIndLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildHq */

 /** @brief This function would call upon all the low level handlers of SR
 * indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuSrIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  srIndInfo pointer to TfuSrIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildSrIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuSrIndInfo     *srIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildSrIndMsg (tcCb, spCb, pst, suId, srIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuSrIndInfo     *srIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildSrIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildSrIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildSrIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   srIndInfo->cellId  = RG_ACC_CELL_ID;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(srIndInfo->cellId));

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the srIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(srIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&srIndInfo->srLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildSrIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildSrIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into srIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, srIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, srIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildSrIndMsg */

/** @brief This function is responsible to building a SR indication for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of SR Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuSrInfo
 *         - Add to the linked list of srLst
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildSr
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuSrIndInfo     *srIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildSr (tcCb, spCb, srIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuSrIndInfo    *srIndInfo;
#endif
{
   TfuSrInfo     *newNode;
   U8             ueId;

   TRC2(rgAcUtlTfuBuildSr);

   /* allocate the new node */
   cmGetMem ((Ptr)&(srIndInfo->memCp), sizeof(TfuSrInfo), (Ptr*)&newNode);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(srIndInfo->srLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildSr */
 

 /** @brief This function would call upon all the low level handlers of decode
  * failure indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuCrcIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  crcIndInfo pointer to TfuCrcIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildCrcIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuCrcIndInfo     *crcIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildCrcIndMsg (tcCb, spCb, pst, suId, crcIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuCrcIndInfo     *crcIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildCrcIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildCrcIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildCrcIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   crcIndInfo->cellId  = RG_ACC_CELL_ID;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "cellId",  &(crcIndInfo->cellId));

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the crcIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(crcIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&crcIndInfo->crcLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildCrcIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildCrcIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into crcIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
#ifdef LTE_TDD
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, crcIndInfo->timingInfo, 2);
#else
#ifndef RG_ULSCHED_AT_CRC
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, crcIndInfo->timingInfo, 1);
#else
      /* In case ulsched_at_crc is enabled
       * then crcind is at delta 2*/
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, crcIndInfo->timingInfo, 2);
#endif
#endif
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, crcIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildCrcIndMsg */

/** @brief This function is responsible to building a decode failure indication for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of Decode failure Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuCrcIndInfo
 *         - Add to the linked list of crcLst
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildCrc
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuCrcIndInfo     *crcIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildCrc (tcCb, spCb, crcIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuCrcIndInfo    *crcIndInfo;
#endif
{
   TfuCrcInfo     *newNode;
   U8             ueId;
   U8             rv;
   Bool           isFailure;

   TRC2(rgAcUtlTfuBuildCrc);

   /* allocate the new node */
   cmGetMem ((Ptr)&(crcIndInfo->memCp), sizeof(TfuCrcInfo), (Ptr*)&newNode);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   rv = 10;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "rv",  &rv);
   isFailure = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isFailure",  &isFailure);
   newNode->isFailure = isFailure;
   if (rv == 10)
      newNode->rv.pres = FALSE;
   else 
   {
      newNode->rv.pres = TRUE;
      newNode->rv.val = rv;
   } /* end of rv == 10 */
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(crcIndInfo->crcLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildCrc*/

/** @brief This function would call upon all the low level handlers of timing
 * advance indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuTimingAdvIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  timingAdvIndInfo pointer to TfuTimingAdvIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildTimingAdvIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuTimingAdvIndInfo     *timingAdvIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildTimingAdvIndMsg (tcCb, spCb, pst, suId, timingAdvIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuTimingAdvIndInfo     *timingAdvIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildTimingAdvIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildTimingAdvIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildTimingAdvIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   timingAdvIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the timingAdvIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(timingAdvIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&timingAdvIndInfo->timingAdvLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildTimingAdvIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildTimingAdvIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into timingAdvIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, timingAdvIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, timingAdvIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildTimingAdvIndMsg */

/** @brief This function is responsible to building a timing advance indication for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of timing advance Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuTimingAdvIndInfo
 *         - Add to the linked list of TfuTimingAdvInfo
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildTimingAdv
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuTimingAdvIndInfo     *timingAdvIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildTimingAdv (tcCb, spCb, timingAdvIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuTimingAdvIndInfo    *timingAdvIndInfo;
#endif
{
   TfuTimingAdvInfo     *newNode;
   U8             ueId;

   TRC2(rgAcUtlTfuBuildTimingAdv);

   /* allocate the new node */
   cmGetMem ((Ptr)&(timingAdvIndInfo->memCp), sizeof(TfuTimingAdvInfo), (Ptr*)&newNode);
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->timingAdv = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "timingAdv",  &(newNode->timingAdv));
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(timingAdvIndInfo->timingAdvLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildTimingAdv */
 
/** @brief This function would call upon all the low level handlers of UL CQI
 * Indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuUlCqiIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  ulCqiIndInfo pointer to TfuUlCqiIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildUlCqiIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuUlCqiIndInfo     *ulCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildUlCqiIndMsg (tcCb, spCb, pst, suId, ulCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuUlCqiIndInfo     *ulCqiIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildUlCqiIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildUlCqiIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildUlCqiIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   ulCqiIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the ulCqiIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(ulCqiIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&ulCqiIndInfo->ulCqiRpt);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildUlCqiIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildUlCqiIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into ulCqiIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, ulCqiIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, ulCqiIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildUlCqiIndMsg */

/** @brief This function is responsible to building a UL CQI Indications for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of UL CQI Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type ulCqiRptLst
 *         - Add to the linked list of TfuUlCqiRpts
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildUlCqi
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuUlCqiIndInfo     *ulCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildUlCqi (tcCb, spCb, ulCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuUlCqiIndInfo    *ulCqiIndInfo;
#endif
{
   TfuUlCqiRpt   *newNode;
   U8             ueId;
   U8             rbStartLst[TFU_MAX_UL_SUBBAND];
   U8             numRbLst[TFU_MAX_UL_SUBBAND];
   U8             cqiIdxLst[TFU_MAX_UL_SUBBAND];
   U8             i;
   U8             num;
   Bool           isWideBand;



   TRC2(rgAcUtlTfuBuildUlCqi);

   /* allocate the new node */
   cmGetMem ((Ptr)&(ulCqiIndInfo->memCp), sizeof(TfuUlCqiRpt), (Ptr*)&newNode);
   /* We need to populate the TfuUlCqiIndInfo structure with values possibly
    * taken from the test case. 
    * 1. CellId - shall be picked from the CellCb stored as part of the
    * configuration from CRG.
    * 2. rnti - a corresponding UE-ID (U8) shall be picked from XML and
    * corresponding RNTI shall be picked from the UeCb stored as part of the UE
    * configuration from CRG.
    * 3. timingInfo - shall be filled based on the frame/subFrame counters
    * at the current time. 
    * 4. numSubBand - shall be taken from XML
    * 5. ulCqiInfoArr - shall be taken from XML. 
    *    (i)   RB Start 
    *    (ii)  Number of RBs
    *    (iii) CQI index.
    *
    * Test case command will be of the following form. 
    * <tapa.send>
    *    <tapa.tfu.ulcqi.ind ueId="1" numSubBand="2" rbStartLst="1:4" numRb="3:4"
    *    cqiIdx="2:3"/>
    * </tapa.send>
    */
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;

   newNode->numSubband = 1;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "numSubBand",  &(newNode->numSubband));
   isWideBand = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isWideBand",  &isWideBand);
   if (isWideBand == TRUE)
   {
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "wideCqi",  &(newNode->wideCqi));
   }

   rbStartLst[0] = 0;
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "rbStartLst", rbStartLst, &num);
   numRbLst[0] = rgAccCb.ulTotalBw;
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "numRbLst", numRbLst, &num);
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "cqiIdxLst", cqiIdxLst, &num);
   for (i = 0; i < num; i++)
   {
      newNode->ulCqiInfoArr[i].subbandCqi.subband.rbStart  = rbStartLst[i];
      newNode->ulCqiInfoArr[i].subbandCqi.subband.numRb    = numRbLst[i];
      newNode->ulCqiInfoArr[i].subbandCqi.cqiIdx           = cqiIdxLst[i];
   } /* end of for */
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(ulCqiIndInfo->ulCqiRpt), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildUlCqi */

#ifdef LTEMAC_MIMO
/** @brief This function would call upon all the low level handlers of DOA
 * Indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuDoaIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  doaIndInfo pointer to TfuDoaIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDoaIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuDoaIndInfo     *doaIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDoaIndMsg (tcCb, spCb, pst, suId, doaIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuDoaIndInfo     *doaIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildDoaIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDoaIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDoaIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   doaIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the doaIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(doaIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&doaIndInfo->doaRpt);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDoaIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDoaIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildDoaIndMsg */

 /** @brief This function is responsible to building a DOA Indications for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of UL CQI Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type doaRptLst
 *         - Add to the linked list of TfuDoaRpts
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDoa
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuDoaIndInfo     *doaIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDoa (tcCb, spCb, doaIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuDoaIndInfo    *doaIndInfo;
#endif
{
   TfuDoaRpt      *newNode;
   U8             ueId;

   TRC2(rgAcUtlTfuBuildDoa);

   /* allocate the new node */
   cmGetMem ((Ptr)&(doaIndInfo->memCp), sizeof(TfuDoaRpt), (Ptr*)&newNode);
   /* We need to populate the TfuDoaIndInfo structure with values possibly
    * taken from the test case. 
    * 1. CellId - shall be picked from the CellCb stored as part of the
    * configuration from CRG.
    * 2. rnti - a corresponding UE-ID (U8) shall be picked from XML and
    * corresponding RNTI shall be picked from the UeCb stored as part of the UE
    * configuration from CRG.
    * 3. doa -  a corresponding DOA (U32) shall be picked from XML and filled
    *    accordingly
    * 
    * Test case command will be of the following form. 
    * <tapa.send>
    *    <tapa.tfu.doa.ind ueId="1" doa="2" 
    *    
    * </tapa.send>
    */
   ueId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;

   newNode->doa = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, "doa",  &(newNode->doa));
   /* Add to the linked list */
   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(doaIndInfo->doaRpt), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildDoa */
#endif

/** @brief This function would call upon all the low level handlers of DL CQI
 * Indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuDlCqiIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  dlCqiIndInfo pointer to TfuDlCqiIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDlCqiIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuDlCqiIndInfo     *dlCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDlCqiIndMsg (tcCb, spCb, pst, suId, dlCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuDlCqiIndInfo     *dlCqiIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildDlCqiIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDlCqiIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildDlCqiIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   dlCqiIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.hq.ind> command. Processing is as follows 
    * - Store the dlCqiIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   datInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(dlCqiIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&dlCqiIndInfo->dlCqiRptsLst);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep, CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDlCqiIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlTfuBuildDlCqiIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into dlCqiIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, dlCqiIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, dlCqiIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildDlCqiIndMsg */

/** @brief This function is responsible to building a DL CQI Indications for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of DL CQI Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuDlCqiRpt
 *         - Add to the linked list of dlCqiRptLst 
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildDlCqi
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuDlCqiIndInfo     *dlCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildDlCqi (tcCb, spCb, dlCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuDlCqiIndInfo    *dlCqiIndInfo;
#endif
{
   TfuDlCqiRpt       *newNode;
   U8                ueId = 0;
   U8                i;
   U8                numOfSubbands;
   U8                num;
   U8                rbStartLst[TFU_MAX_UL_SUBBAND];
   U8                numRbLst[TFU_MAX_UL_SUBBAND];
   U8                cqiIdxLst[TFU_MAX_UL_SUBBAND];
   TfuCqiPuschMode30 *mode30Info;
   TfuCqiPuschMode20 *mode20Info;
   TfuCqiPucchMode20 *pucchMode20Info;
#ifdef LTEMAC_MIMO
   Bool              isRiPres; 
   TfuCqiPucchMode11 *pucchMode11Info;   
   TfuCqiPucchMode21 *pucchMode21Info;
   TfuCqiPuschMode12 *mode12Info;
   TfuCqiPuschMode22 *mode22Info;
   TfuCqiPuschMode31 *mode31Info;
   U8                cqiIdxLstTb[TFU_MAX_TB][TFU_MAX_UL_SUBBAND];
   U8                pmiIdxLst[TFU_MAX_UL_SUBBAND];
#endif
#ifdef RGR_CQI_REPT
   Bool             cqiPres;
   Bool             isSecCqCqiAvail;
   RgrUeCqiRept     cqiRept;
   S8               secCwCqi;
#endif
#ifdef RGR_CQI_REPT
   RgAcDlPwrCntrlInfo *dlpcInfo;
#endif


   TRC2(rgAcUtlTfuBuildDlCqi);

   /* allocate the new node */
   cmGetMem ((Ptr)&(dlCqiIndInfo->memCp), sizeof(TfuDlCqiRpt), (Ptr*)&newNode);

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->rnti = rgAccCb.acUeCb[ueId].crnti;

   newNode->isPucchInfo = TRUE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U8, 
         "isPucchInfo",  &(newNode->isPucchInfo));

#ifdef RGR_CQI_REPT
   /* Reset the cqi report information */
   cqiRept.cqi[0] = 0;
   cqiRept.cqi[1] = 0;
   cqiRept.cqiMode = 0;
   cqiPres = FALSE;
   secCwCqi = 0;
   isSecCqCqiAvail = FALSE;
#endif
   if (newNode->isPucchInfo)
   {
      newNode->dlCqiInfo.pucchCqi.cellIdx = 0; /* PCELL Index */
      newNode->dlCqiInfo.pucchCqi.mode = TFU_PUCCH_CQI_MODE10;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, 
            "cqiMode",  &(newNode->dlCqiInfo.pucchCqi.mode));

#ifdef RGR_CQI_REPT
      cqiRept.cqiMode = newNode->dlCqiInfo.pucchCqi.mode;
#endif
      if (newNode->dlCqiInfo.pucchCqi.mode == TFU_PUCCH_CQI_MODE10)
      {
#ifndef LTEMAC_MIMO      
         newNode->dlCqiInfo.pucchCqi.u.mode10Info.type = TFU_RPT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiIdx",  &(newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.cqi));
#else
         newNode->dlCqiInfo.pucchCqi.u.mode10Info.type = TFU_RPT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, 
               "type",  &(newNode->dlCqiInfo.pucchCqi.u.mode10Info.type));
         if (newNode->dlCqiInfo.pucchCqi.u.mode10Info.type == TFU_RPT_CQI)
         {
            newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.cqi = RG_ACC_DFLT_CQI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiIdx",  &(newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.cqi));
         }
        else
        {
            newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.ri = RG_ACC_DFLT_RI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                "riIdx",  &(newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.ri));
        }
#endif

#ifdef RGR_CQI_REPT
        cqiRept.cqi[0] = newNode->dlCqiInfo.pucchCqi.u.mode10Info.u.cqi;
        cqiPres = TRUE;
#endif
      }
      else if (newNode->dlCqiInfo.pucchCqi.mode == TFU_PUCCH_CQI_MODE20)
      {
         pucchMode20Info = &(newNode->dlCqiInfo.pucchCqi.u.mode20Info);
         pucchMode20Info->type = TFU_RPT_CQI;
#ifdef LTEMAC_MIMO
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, 
               "type",  &(pucchMode20Info->type));
         if (pucchMode20Info->type == TFU_RPT_CQI)
         {
#endif
            pucchMode20Info->u.cqi.isWideband = TRUE;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                  "isWideband",  &(pucchMode20Info->u.cqi.isWideband));
            if (pucchMode20Info->u.cqi.isWideband)
            {
               pucchMode20Info->u.cqi.u.wideCqi = RG_ACC_DFLT_CQI;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                     "wbCqi",  &(pucchMode20Info->u.cqi.u.wideCqi));

#ifdef RGR_CQI_REPT
              cqiRept.cqi[0] = pucchMode20Info->u.cqi.u.wideCqi;
              cqiPres = TRUE;
#endif
            }
            else
            {
               pucchMode20Info->u.cqi.u.subCqi.cqi = RG_ACC_DFLT_CQI;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                     "sbCqi",  &(pucchMode20Info->u.cqi.u.subCqi.cqi));
               pucchMode20Info->u.cqi.u.subCqi.l = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                     "label",  &(pucchMode20Info->u.cqi.u.subCqi.l));
            }
#ifdef LTEMAC_MIMO
         }
         else
         {
            pucchMode20Info->u.ri = RG_ACC_DFLT_RI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                       "riIdx",  &(pucchMode20Info->u.ri));

         }
#endif
      }
#ifdef LTEMAC_MIMO
      else if (newNode->dlCqiInfo.pucchCqi.mode == TFU_PUCCH_CQI_MODE11)
      {
         pucchMode11Info = &(newNode->dlCqiInfo.pucchCqi.u.mode11Info);
         pucchMode11Info->type = TFU_RPT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, 
               "type",  &(pucchMode11Info->type));
         if (pucchMode11Info->type == TFU_RPT_CQI)
         {
            pucchMode11Info->u.cqi.cqi = RG_ACC_DFLT_CQI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "cqiIdx",  &(pucchMode11Info->u.cqi.cqi));

#ifdef RGR_CQI_REPT
            cqiRept.cqi[0] = pucchMode11Info->u.cqi.cqi;
            cqiPres = TRUE;
#endif

            pucchMode11Info->u.cqi.pmi = RG_ACC_DFLT_PMI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "pmiIdx",  &(pucchMode11Info->u.cqi.pmi));
            pucchMode11Info->u.cqi.wideDiffCqi.pres = 0;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                "wideDiffCqiPres", &(pucchMode11Info->u.cqi.wideDiffCqi.pres));
            if (pucchMode11Info->u.cqi.wideDiffCqi.pres != 0)
            {
                  pucchMode11Info->u.cqi.wideDiffCqi.val = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "wideDiffCqiVal",  &(pucchMode11Info->u.cqi.wideDiffCqi.val));
#ifdef RGR_CQI_REPT
               isSecCqCqiAvail = TRUE;
               secCwCqi = pucchMode11Info->u.cqi.cqi -
                  rgAcCmnDlCqiDiffOfst[pucchMode11Info->u.cqi.wideDiffCqi.val];
#endif
            }
         }  
         else
         {
#ifdef LTEMAC_MIMO 
            pucchMode11Info->u.ri = RG_ACC_DFLT_RI;
#else
            pucchMode20Info->u.cqi.u.subCqi.cqi = RG_ACC_DFLT_CQI;
#endif
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                         "riIdx",  &(pucchMode11Info->u.ri));
         }
      }      
      else /* TFU_PUCCH_CQI_MODE21 */
      {
         pucchMode21Info = &(newNode->dlCqiInfo.pucchCqi.u.mode21Info);
         pucchMode21Info->type = TFU_RPT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_ENUM_U32, 
               "type",  &(pucchMode21Info->type));
         if (pucchMode21Info->type == TFU_RPT_CQI)
         {
            pucchMode21Info->u.cqi.isWideband = FALSE;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
                 "isWideband",  &(pucchMode21Info->u.cqi.isWideband));
            if (pucchMode21Info->u.cqi.isWideband)
            {
               pucchMode21Info->u.cqi.u.wideCqi.cqi = RG_ACC_DFLT_CQI;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                 "cqiIdx",  &(pucchMode21Info->u.cqi.u.wideCqi.cqi));

#ifdef RGR_CQI_REPT
               cqiRept.cqi[0] = pucchMode21Info->u.cqi.u.wideCqi.cqi;
               cqiPres = TRUE;
#endif

               pucchMode21Info->u.cqi.u.wideCqi.pmi = RG_ACC_DFLT_PMI;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                 "pmiIdx",  &(pucchMode21Info->u.cqi.u.wideCqi.pmi));
               pucchMode21Info->u.cqi.u.wideCqi.diffCqi.pres = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                 "diffCqiPres", &(pucchMode21Info->u.cqi.u.wideCqi. \
                         diffCqi.pres));
               if (pucchMode21Info->u.cqi.u.wideCqi.diffCqi.pres != 0)
               {
                  pucchMode21Info->u.cqi.u.wideCqi.diffCqi.val = 0;
                  cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                        "diffCqiVal",  &(pucchMode21Info->u.cqi.u.wideCqi.
                              diffCqi.val));
#ifdef RGR_CQI_REPT
                  isSecCqCqiAvail = TRUE;
                  secCwCqi = pucchMode21Info->u.cqi.u.wideCqi.cqi -
                             rgAcCmnDlCqiDiffOfst[pucchMode21Info->u.\
                             cqi.u.wideCqi.diffCqi.val];
#endif
               }
            }
            else
            {
               pucchMode21Info->u.cqi.u.subCqi.cqi = RG_ACC_DFLT_CQI;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                 "cqiIdx",  &(pucchMode21Info->u.cqi.u.subCqi.cqi));
               pucchMode21Info->u.cqi.u.subCqi.l = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                 "label",  &(pucchMode21Info->u.cqi.u.subCqi.l));
               pucchMode21Info->u.cqi.u.subCqi.diffCqi.pres = 0;
               cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                  "diffCqiPres", &(pucchMode21Info->u.cqi.u.subCqi. \
                         diffCqi.pres));
               if (pucchMode21Info->u.cqi.u.subCqi.diffCqi.pres != 0)
               {
                  pucchMode21Info->u.cqi.u.subCqi.diffCqi.val = 0;
                  cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                        "diffCqiVal",  &(pucchMode21Info->u.cqi.u.subCqi.
                              diffCqi.val));
               }
            }
         }  
         else
         {
            pucchMode21Info->u.ri = RG_ACC_DFLT_RI;
            cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
                      "riIdx",  &(pucchMode21Info->u.ri));
         }
      }
#endif
   }
   else  /* else of if (newNode->isPucchInfo) */
   {
#ifdef LTEMAC_MIMO
      isRiPres = FALSE;      
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
            "isRiPres", &isRiPres);
      newNode->dlCqiInfo.pusch.numOfCells = 1;
      newNode->dlCqiInfo.pusch.puschCqi[0].cellIdx = 0; /* PCELL Index */
      if (isRiPres)
      {
         newNode->dlCqiInfo.pusch.puschCqi[0].ri.pres = isRiPres;
         newNode->dlCqiInfo.pusch.puschCqi[0].ri.val = RG_ACC_DFLT_RI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "ri",  &(newNode->dlCqiInfo.pusch.puschCqi[0].ri.val));
      }
#endif
      /* We are here means we have to report CQI over PUSCH */
      newNode->dlCqiInfo.pusch.puschCqi[0].mode = TFU_PUSCH_CQI_MODE_20;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U32, 
            "cqiMode",  &(newNode->dlCqiInfo.pusch.puschCqi[0].mode));

#ifdef RGR_CQI_REPT
      cqiRept.cqiMode = newNode->dlCqiInfo.pusch.puschCqi[0].mode;
#endif

      if (newNode->dlCqiInfo.pusch.puschCqi[0].mode == TFU_PUSCH_CQI_MODE_20)
      {
         mode20Info = &(newNode->dlCqiInfo.pusch.puschCqi[0].u.mode20Info);

         mode20Info->wideBandCqi = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqi",  &(mode20Info->wideBandCqi));

#ifdef RGR_CQI_REPT
               cqiRept.cqi[0] = mode20Info->wideBandCqi;
               cqiPres = TRUE;
#endif

         mode20Info->cqiIdx = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiIdx",  &(mode20Info->cqiIdx));
         numOfSubbands = 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "numOfSubbands",  &numOfSubbands);

         rbStartLst[0] = 0;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rbStartLst", rbStartLst, &num);

         numRbLst[0] = rgAccCb.dlTotalBw;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "numRbLst", numRbLst, &num);

         mode20Info->numSubband = numOfSubbands;
         for (i = 0; i < numOfSubbands; i++)
         {
            mode20Info->subbandArr[i].rbStart = rbStartLst[i];
            mode20Info->subbandArr[i].numRb = numRbLst[i];
         }

      } /* end of mode20 */
#ifdef LTEMAC_MIMO
      else if (newNode->dlCqiInfo.pusch.puschCqi[0].mode == TFU_PUSCH_CQI_MODE_22)
      {
         mode22Info = &(newNode->dlCqiInfo.pusch.puschCqi[0].u.mode22Info);
         
         mode22Info->wideBandPmi = RG_ACC_DFLT_PMI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbPmi",  &(mode22Info->wideBandPmi));
         
         mode22Info->pmi = RG_ACC_DFLT_PMI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "pmi",  &(mode22Info->pmi));
         
         mode22Info->cqi[0] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiTb0",  &(mode22Info->cqi[0]));

         mode22Info->cqi[1] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiTb1",  &(mode22Info->cqi[1]));

#ifdef RGR_CQI_REPT
         isSecCqCqiAvail = TRUE;
         secCwCqi = mode22Info->cqi[1];
#endif
         mode22Info->wideBandCqi[0] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqiTb0",  &(mode22Info->wideBandCqi[0]));

#ifdef RGR_CQI_REPT
               cqiRept.cqi[0] = mode22Info->wideBandCqi[0];
               cqiPres = TRUE;
#endif

         mode22Info->wideBandCqi[1] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqiTb1",  &(mode22Info->wideBandCqi[1]));

         numOfSubbands = 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "numOfSubbands",  &numOfSubbands);

         rbStartLst[0] = 0;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rbStartLst", rbStartLst, &num);

         numRbLst[0] = rgAccCb.dlTotalBw;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "numRbLst", numRbLst, &num);

         mode22Info->numSubband = numOfSubbands;
         for (i = 0; i < numOfSubbands; i++)
         {
            mode22Info->subbandArr[i].rbStart = rbStartLst[i];
            mode22Info->subbandArr[i].numRb   = numRbLst[i];
         }

      } /* end of mode22 */
      else if (newNode->dlCqiInfo.pusch.puschCqi[0].mode == TFU_PUSCH_CQI_MODE_12)
      {
         mode12Info = &(newNode->dlCqiInfo.pusch.puschCqi[0].u.mode12Info);

         mode12Info->cqiIdx[0] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiTb0",  &(mode12Info->cqiIdx[0]));

#ifdef RGR_CQI_REPT
         cqiRept.cqi[0] = mode12Info->cqiIdx[0];
         cqiPres = TRUE;
#endif

         mode12Info->cqiIdx[1] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "cqiTb1",  &(mode12Info->cqiIdx[1]));
#ifdef RGR_CQI_REPT
         isSecCqCqiAvail = TRUE;
         secCwCqi = mode12Info->cqiIdx[1];
#endif
         numOfSubbands = 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "numOfSubbands",  &numOfSubbands);

         rbStartLst[0] = 0;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rbStartLst", rbStartLst, &num);

         numRbLst[0] = rgAccCb.dlTotalBw;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "numRbLst", numRbLst, &num);
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "pmiIdxLst", pmiIdxLst, &num);

         mode12Info->numSubband = numOfSubbands;
         for (i = 0; i < numOfSubbands; i++)
         {
            mode12Info->subbandArr[i].subBand.rbStart = rbStartLst[i];
            mode12Info->subbandArr[i].subBand.numRb = numRbLst[i];
            mode12Info->subbandArr[i].pmi           = pmiIdxLst[i];
         }
      } /* end of mode12 */
      else if (newNode->dlCqiInfo.pusch.puschCqi[0].mode == TFU_PUSCH_CQI_MODE_31)
      {
         mode31Info = &(newNode->dlCqiInfo.pusch.puschCqi[0].u.mode31Info);

         mode31Info->wideBandCqi[0] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqiTb0",  &(mode31Info->wideBandCqi[0]));

#ifdef RGR_CQI_REPT
               cqiRept.cqi[0] = mode31Info->wideBandCqi[0];
               cqiPres = TRUE;
#endif
         mode31Info->wideBandCqi[1] = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqiTb1",  &(mode31Info->wideBandCqi[1]));
#ifdef RGR_CQI_REPT
         isSecCqCqiAvail = TRUE;
         secCwCqi = mode31Info->wideBandCqi[1];
#endif
         mode31Info->pmi = RG_ACC_DFLT_PMI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "pmiIdx",  &(mode31Info->pmi));
         numOfSubbands = 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "numOfSubbands",  &numOfSubbands);

         rbStartLst[0] = 0;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rbStartLst", rbStartLst, &num);

         numRbLst[0] = rgAccCb.dlTotalBw;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "numRbLst", numRbLst, &num);

         CMXTA_ZERO(cqiIdxLstTb[0], (sizeof(U8) * TFU_MAX_UL_SUBBAND));
         CMXTA_ZERO(cqiIdxLstTb[1], (sizeof(U8) * TFU_MAX_UL_SUBBAND));
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "cqiIdxLstTb0", cqiIdxLstTb[0], &num);
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "cqiIdxLstTb1", cqiIdxLstTb[1], &num);

         mode31Info->numSubband = numOfSubbands;
         for (i = 0; i < numOfSubbands; i++)
         {
            mode31Info->subbandCqiArr[i].subband.rbStart = rbStartLst[i];
            mode31Info->subbandCqiArr[i].subband.numRb = numRbLst[i];
            mode31Info->subbandCqiArr[i].cqiIdx[0] = cqiIdxLstTb[0][i];
            mode31Info->subbandCqiArr[i].cqiIdx[1] = cqiIdxLstTb[1][i];
         }

      } /* end of mode31 */
#endif
      else  /* MODE 3_0 */
      {
         mode30Info = &(newNode->dlCqiInfo.pusch.puschCqi[0].u.mode30Info);
         
         mode30Info->wideBandCqi = RG_ACC_DFLT_CQI;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "wbCqi",  &(mode30Info->wideBandCqi));

#ifdef RGR_CQI_REPT
               cqiRept.cqi[0] = mode30Info->wideBandCqi;
               cqiPres = TRUE;
#endif
         /* If we are here we are meant to create a mode30 report */
         numOfSubbands = 1;
         cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
               "numOfSubbands",  &numOfSubbands);

         rbStartLst[0] = 0;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "rbStartLst", rbStartLst, &num);

         numRbLst[0] = rgAccCb.dlTotalBw;
         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "numRbLst", numRbLst, &num);

         cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
               "cqiIdxLst", cqiIdxLst, &num);
         mode30Info->numSubband  = numOfSubbands;
         for (i = 0; i < numOfSubbands; i++)
         {
            mode30Info->subbandArr[i].subBand.rbStart    = rbStartLst[i];
            mode30Info->subbandArr[i].subBand.numRb      = numRbLst[i];
            mode30Info->subbandArr[i].cqi             = cqiIdxLst[i];
         }
      } /* end of mode30 */
   } /* end of if (isPucchInfo) */

#ifdef RGR_CQI_REPT
   dlpcInfo = &(rgAccCb.acUeCb[ueId].dlpcInfo);
   if(dlpcInfo->cqiReptCount != 0 && cqiPres)
   {
      cqiRept.cqi[1] = 0;
      if(isSecCqCqiAvail)
      {
         cqiRept.cqi[1] = secCwCqi; /* Mode remains same */
      }
      dlpcInfo->cqiRept[dlpcInfo->cqiSentCount]= cqiRept;
      dlpcInfo->cqiSentCount++;
   }
#endif

   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(dlCqiIndInfo->dlCqiRptsLst), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildUlCqi */


#ifdef TFU_UPGRADE
/** @brief This function would call upon all the low level handlers of Raw DL CQI
 * Indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuRawCqiIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  rawDlCqiIndInfo pointer to TfuRawCqiIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildRawDlCqiIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuRawCqiIndInfo     *rawDlCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildRawDlCqiIndMsg(tcCb, spCb, pst, suId, rawDlCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuRawCqiIndInfo *rawDlCqiIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildRawDlCqiIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRawDlCqiIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildRawDlCqiIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   rawDlCqiIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.rawdlcqi.ind> command. Processing is as follows 
    * - Store the rawDlCqiIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   rawDlCqiInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(rawDlCqiIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&rawDlCqiIndInfo->rawCqiRpt);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep,
               CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlTfuBuildRawDlCqiIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlTfuBuildRawDlCqiIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into dlCqiIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, rawDlCqiIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, rawDlCqiIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildRawDlCqiIndMsg */

/** @brief This function is responsible to building a Raw DL CQI Indications for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of Raw DL CQI Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuRawCqiRpt
 *         - Add to the linked list of rawCqiRpt 
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildRawDlCqi
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuRawCqiIndInfo     *rawDlCqiIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildRawDlCqi (tcCb, spCb, rawDlCqiIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuRawCqiIndInfo    *rawDlCqiIndInfo;
#endif
{
   S16               ret;
   TfuRawCqiRpt       *newNode;
   U8                ueId = 0;
   U8    byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
   Bool  rawDlCqiEnc;
   U8    wideBandCqi; 
   U8    wideBandCqi2; 
   U8    subBandCqi; 
   U8    label; 
   U8    cqiIdxLst[TFU_MAX_UL_SUBBAND];
   U8    cqiIdxLst2[TFU_MAX_UL_SUBBAND];
   U8    num1 = 0;
   U8    num2 = 0;
   U8    sbStartPos;
   U8    pos = 0;
   U8    i;
     

   TRC2(rgAcUtlTfuBuildRawDlCqi);

   /* allocate the new node */
   cmGetMem ((Ptr)&(rawDlCqiIndInfo->memCp), sizeof(TfuRawCqiRpt), (Ptr*)&newNode);

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
    newNode->crnti = rgAccCb.acUeCb[ueId].crnti;

   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
         "ri", &newNode->ri, &num1);

   rawDlCqiEnc = FALSE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
         "rawDlCqiEnc",  &rawDlCqiEnc);

   if(rawDlCqiEnc)
   {   
      wideBandCqi = RG_ACC_DFLT_CQI;
      wideBandCqi2 = RG_ACC_DFLT_CQI;

      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "wbCqi",  &wideBandCqi);

      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "wbCqi2",  &wideBandCqi2);

      /* Periodic Subband CQI*/
      subBandCqi = RG_ACC_DFLT_CQI;
      ret = cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "sbCqi",  &subBandCqi);

      label = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "label",  &label);

      /* Aperiodic Subband CQI for CELL 1*/
      cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
            "cqiIdxLst", cqiIdxLst, &num1);

      /* Aperiodic Subband CQI for CELL 2*/
      cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON, 
            "cqiIdxLst2", cqiIdxLst2, &num2);

      newNode->cqiBits[0] |= (wideBandCqi << 4); 
        
      /* Aperiodic SB CQI Encoding*/
      if(num1)
      {
         sbStartPos = 4;
         for(i = 0; i < num1; i++)
         {
            sbStartPos -= 2;
            newNode->cqiBits[pos] |= cqiIdxLst[i]<<sbStartPos;

            if(sbStartPos == 0)
            {   
               pos++;
               sbStartPos = 8;
            }     
         }

         if(num2)
         {
            if(sbStartPos >= 4)
            {
               sbStartPos -= 4;
               newNode->cqiBits[pos] |= wideBandCqi2<<sbStartPos;

               if(sbStartPos == 0)
               {   
                  pos++;
                  sbStartPos = 8;
               }     
            }   
            else if(sbStartPos == 2)  
            {
               newNode->cqiBits[pos] |= wideBandCqi2>>sbStartPos;
               sbStartPos = 6;
               newNode->cqiBits[++pos] |= wideBandCqi2<<sbStartPos;
            }   
            else if(sbStartPos == 0)
            {
               sbStartPos = 4;
               newNode->cqiBits[++pos] |= wideBandCqi2<<sbStartPos;
            }   

            for(i = 0; i < num2; i++)
            {
               sbStartPos -= 2;
               newNode->cqiBits[pos] |= cqiIdxLst2[i]<<sbStartPos;

               if(sbStartPos == 0)
               {   
                  pos++;
                  sbStartPos = 8;
               }     
            }
         }   
      }
      /* Periodic SB CQI Encoding*/
      else if(ret == CMXTA_ERR_NONE)
      {
         newNode->cqiBits[0] = (subBandCqi<<4) | ((label<<2) & 0xc);
      } 
   }
   else
   {   
      byte0 = 128;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte0",  &byte0);
      newNode->cqiBits[0] = byte0;

      byte1 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte1",  &byte1);
      newNode->cqiBits[1] = byte1;

      byte2 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte2",  &byte2);
      newNode->cqiBits[2] = byte2;

      byte3 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte3",  &byte3);
      newNode->cqiBits[3] = byte3;

      byte4 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte4",  &byte4);
      newNode->cqiBits[4] = byte4;

      byte5 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte5",  &byte5);
      newNode->cqiBits[5] = byte5;

      byte6 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte6",  &byte6);
      newNode->cqiBits[6] = byte6;

      byte7 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte7",  &byte7);
      newNode->cqiBits[7] = byte7;

      byte8 = 0;
      cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
            "byte8",  &byte8);
      newNode->cqiBits[8] = byte8;
   }

   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(rawDlCqiIndInfo->rawCqiRpt), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildRawDlCqi */

/** @brief This function would call upon all the low level handlers of SRS
 * Indication primitive. It would effectively build up the message one rnti at a
 * time.
 *
 * @details
 * Invokes all the lower-level handler one by one, populating the whole
 * TfuSrsIndInfo structure.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Loop through the set of embedded xml commands.
 * @param  tcCb pointer to CmXtaTCCb
 * @param  spCb pointer to CmXtaSpCb
 * @param  suId pointer to SuId
 * @param  rawDlCqiIndInfo pointer to TfuRawCqiIndInfo
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildSrsIndMsg
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 Pst              *pst,
 SuId             *suId,
 TfuSrsIndInfo     *srsIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildSrsIndMsg(tcCb, spCb, pst, suId, srsIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 Pst              *pst;
 SuId             *suId;
 TfuSrsIndInfo     *srsIndInfo;
#endif
{
   S16             ret;
   Void            *nxtStep;
   CmXtaXmlCb      *xmlCb;

   TRC2(rgAcUtlTfuBuildSrsIndMsg)

#ifndef ALIGN_64BIT
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildSrsIndMsg(), tcId(%ld)\n", tcCb->tcId));
#else
   CMXTA_DBG_PARAM((_cmxtap, "rgAcUtlTfuBuildSrsIndMsg(), tcId(%d)\n", tcCb->tcId));
#endif

   rgAcUtlTfuGetToSchPst (tcCb, spCb, pst);
   *suId = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_S16, "suId",  suId);
   srsIndInfo->cellId  = RG_ACC_CELL_ID;

   /* The code that follows is to call the handler of the low-level commands
    * embededded in the <tapa.tfu.srs.ind> command. Processing is as follows 
    * - Store the srsIndInfo structure's pointer within the tcCb 
    * - Run through each of the individual low-level commands and call the
    *   corresponding handlers (each handler shall populate it's portion of the
    *   srsInd structure. 
    * - Structure should be completely filled in by the end of the low-level
    *   commands. 
    * - Return.
    */

   /* Typecast and store in the tcCb - low-level handlers shall pick up from
    * tcCb and populate the same. 
    */
   tcCb->data = (Void *)(srsIndInfo); 
   /* Initialize the cmLListInit for the list of TfuDatInfo */
   cmLListInit (&srsIndInfo->srsRpt);
   nxtStep = NULLP;
   while ((nxtStep = cmXtaXmlGetNextOfType(spCb->childStep, nxtStep,
               CMXTA_DOM_ELEMENT_NODE)) != NULLP)
   {
      /*-- Get the XML cb for the simple command --*/
      if ((xmlCb = cmXtaXmlFindFromXml(nxtStep)) == NULLP)
      {
         /*-- XML cmd not registered, flag error --*/
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlTfuBuildSrsIndMsg(): XML cmd not registered\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Sanity check, check its a simple command and of type other --*/
      if ((xmlCb->cmdType != CMXTA_TYPE_LEAF) ||
            (xmlCb->subType != CMXTA_SUBTYPE_OTHER))
      {
         /*-- Wrong type of command inside send tag, validate the test case
           flag error --*/
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlTfuBuildSrsIndMsg(): invalid cmd in <tapa.send>\n"));
         RETVALUE(CMXTA_ERR_INT);
      }

      /*-- Set the child element, this may be used for getting the attributes --*/
      spCb->childStep = nxtStep;

      /*-- Lets make a call finally --*/
      if ((ret = xmlCb->func(tcCb, spCb)) != CMXTA_ERR_NONE)
         RETVALUE(ret);
   }
   /* We need to copy the current time into dlCqiIndInfo */
   if (TRUE == rgAccCb.directives.ulDeltaPrsnt)
   {
      RGSUBFRMCRNTTIME(rgAcTfCb.crntTime, srsIndInfo->timingInfo, 1);
   }
   else
   {
      RGCPYTIMEINFO(rgAcTfCb.crntTime, srsIndInfo->timingInfo);
   }
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildSrsIndMsg */

/** @brief This function is responsible to building a SRS Indications for a
 * single UE i.e. rnti.
 *
 * @details
 * This is called from the lower-level handler of SRS Indication handler.
 *
 *     Function: 
 *
 *         Processing steps:
 *         - Allocate a new node of type TfuSrsRpt
 *         - Add to the linked list of srsRpt 
 * @param  
 * @param 
 * @return 
 */
#ifdef ANSI
PUBLIC S16 rgAcUtlTfuBuildSrs
(
 CmXtaTCCb        *tcCb,
 CmXtaSpCb        *spCb,
 TfuSrsIndInfo     *srsIndInfo
 )
#else
PUBLIC S16 rgAcUtlTfuBuildSrs (tcCb, spCb, srsIndInfo)
 CmXtaTCCb        *tcCb;
 CmXtaSpCb        *spCb;
 TfuSrsIndInfo     *srsIndInfo;
#endif
{
   TfuSrsRpt       *newNode;
   U8                ueId = 0;
   U8 numRbs, rbStart, loop, wideCqi;
   U16 dopEst, ta; 
   Bool wideCqiPres;
   U8 snr[TFU_MAX_UL_RB]={0}; 

   TRC2(rgAcUtlTfuBuildSrs);

   /* allocate the new node */
   cmGetMem ((Ptr)&(srsIndInfo->memCp), sizeof(TfuSrsRpt), (Ptr*)&newNode);

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   newNode->ueId = rgAccCb.acUeCb[ueId].crnti;

   numRbs = 2;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
         "numRbs",  &numRbs);
   newNode->numRbs = numRbs;

   rbStart = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
         "rbStart",  &rbStart);
   newNode->rbStart = rbStart;

   dopEst = 1;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, 
         "dopEst",  &dopEst);
   newNode->dopEst = dopEst;

   ta = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, 
         "ta",  &ta);
   newNode->ta = ta;

   wideCqiPres = TRUE;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, 
         "widecqipres",  &wideCqiPres);
   newNode->wideCqiPres = wideCqiPres;

   
   wideCqi = 1;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
           "widecqi",  &wideCqi);
   newNode->wideCqi = wideCqi;

   rbStart = 0;
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
         "rbStart",  &rbStart);
   newNode->rbStart = rbStart;

   /*Storing SNR*/
   snr[0]=150;
   for(loop =0; loop<TFU_MAX_UL_RB; loop++)
   {
    cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, 
         "snr",  snr);
   newNode->snr[loop] = snr[loop];
   }

   newNode->lnk.node = (PTR)newNode;
   cmLListAdd2Tail (&(srsIndInfo->srsRpt), &(newNode->lnk));
   RETVALUE(CMXTA_ERR_NONE);
} /* end of rgAcUtlTfuBuildSrs */

#endif 


/** @brief This function validates TPC
 *
 * @details
 * Is called from rgAcUtlCheckDci
 *
 *     Function: 
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param pdcch pointer to TfuPdcchInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcUtlCheckDciPuschTpc 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch
)
#else
PRIVATE S16 rgAcUtlCheckDciPuschTpc (tcCb, spCb, pdcch)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuPdcchInfo  *pdcch;
#endif
{
   S16               ret;
   TfuDciFormat0Info *format0;
   Bool              isAccumulated;
   Bool              tpcPositive;
   S8                delPusch;
   U8                tpcCmd = 100; /* init with invalid value */

   TRC2(rgAcUtlCheckDciPuschTpc);

   ret = CMXTA_ERR_NONE;

   format0 = &(pdcch->dci.u.format0Info);
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "tpcCmd", &tpcCmd);

   if (tpcCmd != 100)
   {
      if (tpcCmd != format0->tpcCmd)
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDci(): TPC expected (%d), rcvd (%d)\n",
                  (int)tpcCmd, (int)format0->tpcCmd));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      RETVALUE(ret);
   }

   isAccumulated = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isAccumulated",
         &isAccumulated);
   if (isAccumulated)
   {
      delPusch = accumTpcArr[format0->tpcCmd];
   } 
   else
   {
      delPusch = abstTpcArr[format0->tpcCmd];
   }
   tpcPositive = FALSE;
   cmXtaXmlGetVal (tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "tpcPositive",
         &tpcPositive);
   if ((tpcPositive == TRUE) && (delPusch < 0))
   {
      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Incorrect TPC, expected Positive.\n"));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   else if ((tpcPositive == FALSE) && (delPusch >= 0))
   {

      CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckDci(): Incorrect TPC, expected Negative.\n"));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   RETVALUE(ret);
} /* end of rgAcUtlCheckDciPuschTpc */ 
#ifdef LTEMAC_SPS

/*********************************************************************/
/** @brief This function validates Release Pdcch For the SPS 
 *
 * @details
 * Is called from rgAcUtlCheckDci
 *
 *     Function: 
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param pdcch pointer to TfuPdcchInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16  rgAcUtlCheckDciFrmt1aRelPdcch 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch
)
#else
PRIVATE S16  rgAcUtlCheckDciFrmt1aRelPdcch(tcCb,spCb,pdcch)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuPdcchInfo  *pdcch;
#endif
{
   S16               ret   = 0;
   U32               alloc = 0xffffffff; /*Setting all bits to 1*/
   U8                mcs   = 0x1f;
   U8                rv    = 0;
   Bool              ndi   = 0;   
   U8                HarqProcId = 0;
   TfuDciFormat1aInfo *dci1aInfo = NULLP;

   TRC2(rgAcUtlCheckDciFrmt1arelPdcch);

   ret = CMXTA_ERR_NONE;
   
   dci1aInfo = &pdcch->dci.u.format1aInfo;

   if(dci1aInfo->t.pdschInfo.allocInfo.alloc.u.riv != alloc)
   {
     CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDci(): SPSalloc expected (%d), rcvd (%d)\n",
                  (int)alloc, (int)dci1aInfo->t.pdschInfo.allocInfo.alloc.u.riv));
         RETVALUE(CMXTA_ERR_NOMATCH);
 
   }
   if(dci1aInfo->t.pdschInfo.allocInfo.mcs != mcs)
   {
     CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDci(): SPSmcs expected (%d), rcvd (%d)\n",
                  (int)mcs, (int)dci1aInfo->t.pdschInfo.allocInfo.mcs));
         RETVALUE(CMXTA_ERR_NOMATCH);
 
   }
   if(dci1aInfo->t.pdschInfo.allocInfo.rv != rv)
   {
     CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDci(): SPSRvIdx expected (%d), rcvd (%d)\n",
                  (int)rv, (int)dci1aInfo->t.pdschInfo.allocInfo.rv));
         RETVALUE(CMXTA_ERR_NOMATCH);
 
   }
   if (dci1aInfo->t.pdschInfo.allocInfo.harqProcId.pres)
   {
      if(dci1aInfo->t.pdschInfo.allocInfo.harqProcId.val != HarqProcId)
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDci(): SPSHarqProcId expected (%d), rcvd (%d)\n",
                  (int)HarqProcId, (int)dci1aInfo->t.pdschInfo.allocInfo.harqProcId.val));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }
   if(dci1aInfo->t.pdschInfo.allocInfo.ndi != ndi)
   {
      CMXTA_DBG_ERR((_cmxtap,
            "rgAcUtlCheckDci(): ndi expected (%d), rcvd (%d)\n",
            (Bool)ndi, (Bool)dci1aInfo->t.pdschInfo.allocInfo.ndi));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }

   RETVALUE(ret);
} /* end of rgAcUtlCheckDciFrmt1aRelPdcch */ 





/*********************************************************************/

/** @brief This function validates HARQ Process ID  for a UE  in a Current TTI
*
* @details
* Is called from  rgAcUtlCheckDci()
*
*     Function: 
*
*         Processing steps:
*         - 
*
*
* @param[in] tcCb pointer to CmXtaTCCb 
* @param[in] spCb pointer to CmXtaSpCb 
* @param[in] pdcch pointer to TfuPdcchInfo
* @param[in] pdcch pointer to CmLteTimingInfo
* @return 
* -# CMXTA_ERR_NONE on match
* -# CMXTA_ERR_INT on internal error
* -# CMXTA_ERR_NOMATCH on no match
*/

#ifdef ANSI
  PRIVATE S16  rgAcUtlCheckTfuHarqProcId
  (
   CmXtaTCCb     *tcCb,
   CmXtaSpCb     *spCb,
   TfuDatReqPduInfo *pduInfo,
   CmLteTimingInfo *TimingInfo
  )
#else
  PRIVATE S16  rgAcUtlCheckTfuHarqProcId(tcCb,spCb, pduInfo,TimingInfo )
   CmXtaTCCb     *tcCb;
   CmXtaSpCb     *spCb;
   TfuDatReqPduInfo *pduInfo;
   CmLteTimingInfo *TimingInfo;
#endif
{
   U8 HarqProcId    = 0;
   U8 ExpHarqProcId = 0;
   U16 SPSPrd       = 0;
   U8 NumSPSProc    = 0;
   U8 ueId        = 0;

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   switch (pduInfo->dciInfo.format)
   {
      case TFU_DCI_FORMAT_1:
         HarqProcId = pduInfo->dciInfo.u.format1AllocInfo.harqProcId;
         break;
      case TFU_DCI_FORMAT_1A:
         HarqProcId = pduInfo->dciInfo.u.format1aAllocInfo.harqProcId.val;
         break;
      case TFU_DCI_FORMAT_1B:
         HarqProcId = pduInfo->dciInfo.u.format1bAllocInfo.harqProcId;
         break;
      case TFU_DCI_FORMAT_1C:
         CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckTfuHarqProcId(): INVALID DCI format for HARQ proc "));
         break;
      case TFU_DCI_FORMAT_1D:
         CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckTfuHarqProcId(): INVALID DCI format for HARQ proc "));
         break;
      case TFU_DCI_FORMAT_2:
         HarqProcId =  pduInfo->dciInfo.u.format2AllocInfo.harqProcId;
         break;
      case TFU_DCI_FORMAT_2A:
         HarqProcId = pduInfo->dciInfo.u.format2AAllocInfo.harqProcId;
         break;
      case TFU_DCI_FORMAT_0:
      case TFU_DCI_FORMAT_3:
      case TFU_DCI_FORMAT_3A:
         CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckTfuHarqProcId():"
                  " DCI format not supported %d\n", pduInfo->dciInfo.format));
         break;
      default:
         CMXTA_DBG_ERR((_cmxtap, "rgAcUtlCheckTfuHarqProcId(): Invalid new DCI  format %d\n", pduInfo->dciInfo.format));
   }

/**
*@brief Calculate the Expected HARQ Process ID 
*@details
*HARQ Process ID = [floor(CURRENT_TTI/(Downlink Semi-Persistent Scheduling Interval))]
*modulo Number of Configured SPS Processes,
*where 
*- CURRENT_TTI=[(SFN * 10) + subframe number],
*- Downlink Semi-Persistent Scheduling Interval is the configured periodicity of
*semi-persistent scheduling
*- Number of Configured SPS Processes is the configured number of HARQ processes 
*allocated for semi-persistent scheduling.
*/


   SPSPrd = rgAccCb.acUeCb[ueId].dlSpsPrd;
   NumSPSProc = rgAccCb.acUeCb[ueId].NumSPSProc;
   ExpHarqProcId = 
   (((U32)((TimingInfo->sfn*10)+TimingInfo->subframe)/SPSPrd)%(U32)NumSPSProc);
   if(HarqProcId != ExpHarqProcId) 
   {
      CMXTA_DBG_ERR((_cmxtap,"rgAcUtlCheckTfuHarqProcId(): MissMatch in the HARQ Processes : HARQ Proc Expt = %d rcvd = %d\n",HarqProcId, ExpHarqProcId));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   else
   {
      RETVALUE(CMXTA_ERR_NONE);
   }
} /*End of rgAcUtlCheckTfuHarqProcId()*/





#endif /*(LTEMAC_SPS)*/
/** @brief This function validates TPC
 *
 * @details
 * Is called from rgAcUtlCheckDci
 *
 *     Function: 
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param pdcch pointer to TfuPdcchInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcUtlCheckDciForGrpPwr 
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuPdcchInfo  *pdcch,
 Bool           isFmt3a
)
#else
PRIVATE S16 rgAcUtlCheckDciForGrpPwr (tcCb, spCb, pdcch, isFmt3a)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuPdcchInfo  *pdcch;
 Bool           isFmt3a;
#endif
{
   S16               ret = CMXTA_ERR_NONE;
   CmLteRnti         tpcRnti = 0xffff;
   U8                num1 = 0;
   U8                num2 = 0;
   U8                tpcIndices[TFU_MAX_1BIT_TPC];
   U8                tpcCmds[TFU_MAX_1BIT_TPC];
   U8                maxIndex;
   U8                maxCmd;
   U8                *rcvdCmds;
   S16               i;

   TRC2(rgAcUtlCheckDciForGrpPwr);

   ret = CMXTA_ERR_NONE;

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U16, "tpcRnti",  &tpcRnti);
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
         "tpcIndices", tpcIndices, &num1);
   cmXtaXmlGetValList (tcCb, spCb->childStep, CMXTA_ATTRIB_U8, CMXTA_SEP_COLON,
         "tpcCmds", tpcCmds, &num2);
   if (tpcRnti != pdcch->rnti)
   {
      CMXTA_DBG_ERR((_cmxtap,
               "rgAcUtlCheckDciForGrpPwr(): RNTI Mismatch exp (%d) rcvd (%d)\n",
               tpcRnti, pdcch->rnti));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }
   if (num1 == 0 || num1 != num2)
   {
      CMXTA_DBG_ERR((_cmxtap,
               "rgAcUtlCheckDciForGrpPwr(): Invalid TC input for tpcIndices/tpcCmds\n"));
      RETVALUE(CMXTA_ERR_NOMATCH);
   }

   if (isFmt3a)
   {
      rcvdCmds = pdcch->dci.u.format3AInfo.tpcCmd;
      maxIndex = TFU_MAX_1BIT_TPC;
      maxCmd   = 1;
   }
   else
   {
      rcvdCmds = pdcch->dci.u.format3Info.tpcCmd;
      maxIndex = TFU_MAX_2BIT_TPC;
      maxCmd   = 3;
   }
   for (i = 0; i < num1; ++i)
   {
      if (tpcIndices[i] > maxIndex || tpcCmds[i] > maxCmd)
         ret = CMXTA_ERR_NOMATCH;
      if (ret != CMXTA_ERR_NONE)
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDciForGrpPwr(): Incorrect TPC cmd entered in TC\n"));
         RETVALUE(ret);
      }
      if (rcvdCmds[tpcIndices[i]] != tpcCmds[i])
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "rgAcUtlCheckDciForGrpPwr(): exp(%d), rcvd(%d)\n",
                  tpcCmds[i], rcvdCmds[tpcIndices[i]]));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
   }

   RETVALUE(ret);
} /* end of rgAcUtlCheckDciForGrpPwr */ 


/** @brief Validate Uplink RB (PUCCH/PUSCH) overlap
 *
 * @details
 *
 *     Function:  rgAcTfuUtlVldtUlRbOvrlap
 *
 *         Processing steps:
 *         - 
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcTfuUtlVldtUlRbOvrlap
(
 U8   rbStart,
 U8   numRb
)
#else
PRIVATE S16 rgAcTfuUtlVldtUlRbOvrlap(rbStart, numRb)
 U8   rbStart;
 U8   numRb;
#endif
{
   U8 rb;

   TRC2(rgAcTfuUtlVldtUlRbOvrlap);
   
   for (rb=rbStart; rb < rbStart+numRb; rb++)
   {
      if (rgAccCb.ulRbMap[rb] == RGAC_RB_BUSY)
      {
         CMXTA_DBG_ERR((_cmxtap,
                  "%s(): PUSCH RB overlap detected ! "
                  " rbStart (%u) numRb (%u)!\n",
                  __FUNCTION__, rbStart, numRb));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      else
      {
         rgAccCb.ulRbMap[rb] = RGAC_RB_BUSY;
      }
   } 

   RETVALUE(CMXTA_ERR_NONE);
} 

#ifdef LTEMAC_HDFDD
/** @brief Validate PDCCH allocation with respect to HDFDD feature
 *
 * @details
 * Is called from rgAcUtlTfuValidatePdcch
 *
 *     Function:  rgAcUtlTfuUtlVldtHdfddPDCCH
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param cntrlReq pointer to TfuCntrlReqInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcUtlTfuUtlVldtHdfddPDCCH
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuCntrlReqInfo     *cntrlReq
)
#else
PRIVATE S16 rgAcUtlTfuUtlVldtHdfddPDCCH (tcCb, spCb, cntrlReq)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuCntrlReqInfo     *cntrlReq;
#endif
{
   CmLListCp      *lstUl = NULLP;
   CmLListCp      *lstDl = NULLP;
   CmLList        *nodeUl = NULLP;
   CmLList        *nodeDl = NULLP;
   U8             ueId = 0;
   RgAcUeCb       *ueCb;
   Bool           isUlGrant = FALSE;
   TfuPdcchInfo   *pdcchUl;
   TfuPdcchInfo   *pdcchDl;
   U8             maxSchUe = 1;
   U8             idx;
   U8             *sfDir = NULLP;

   TRC2(rgAcUtlTfuUtlVldtHdfddPDCCH);

   /* Traverse the linked list UL and DL depending on the flag */

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "ueId",  &ueId);
   ueCb = &(rgAccCb.acUeCb[ueId]);
   if (!(ueCb->isHdFddEnbld))
   {
      RETVALUE(ROK);
   }
   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_BOOL, "isUlGrant",  &isUlGrant);
   if (isUlGrant == TRUE)
   {
      lstUl = &cntrlReq->ulPdcchLst;
      nodeUl = lstUl->first;
   }
   lstDl = &cntrlReq->dlPdcchLst;
   nodeDl = lstDl->first;

   /* Look for DL and UL collisions */
   while(nodeUl)
   {
      pdcchUl = (TfuPdcchInfo *)nodeUl->node;
      while(nodeDl)
      {
         pdcchDl = (TfuPdcchInfo *)nodeDl->node;
         if (pdcchUl->rnti == pdcchDl->rnti)
         {
            CMXTA_DBG_ERR((_cmxtap,
            "rgAcUtlTfuUtlVldtHdfddPDCCH(): DL-UL Rnti collision\n"));
            RETVALUE(CMXTA_ERR_NOMATCH);
         }
         nodeDl = nodeDl->next;
      } /* end of while(nodeDl) */
      nodeUl = nodeUl->next;
   } /* end of while(nodeUl) */

   if (isUlGrant == TRUE)
   {
      lstUl = &cntrlReq->ulPdcchLst;
      nodeUl = lstUl->first;
   }
   lstDl = &cntrlReq->dlPdcchLst;
   nodeDl = lstDl->first;

   cmXtaXmlGetVal(tcCb, spCb->childStep, CMXTA_ATTRIB_U8, "maxSchUe",  &maxSchUe);

   /* Validate UL UEs Allocation info w.r.t SF direction*/
   while (nodeUl)
   {
      pdcchUl = (TfuPdcchInfo *)nodeUl->node;

      /* Lookfor proper UeCb stored in rgAcCellCb*/

      for (idx = 0; idx < maxSchUe; idx++)
      {
         if (rgAccCb.acUeCb[idx].crnti == pdcchUl->rnti &&
               rgAccCb.acUeCb[idx].isHdFddEnbld)
         {
            /* Always take the last element in array, as
               this PDCCH is for that element */
            sfDir = &(rgAccCb.ueSfInfo[idx].sfDir[RGAC_HDFDD_SF_HIST - 1]);

            /* Check for Collision of marking*/
            if (*sfDir != RGAC_HDFDD_NOSCHD && *sfDir != RGAC_HDFDD_UL)
            {
              CMXTA_DBG_ERR((_cmxtap,
              "rgAcUtlTfuUtlVldtHdfddPDCCH(): UL-DL SF direction collision\n"));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            /* Check for Guard period */
            if (*(sfDir - 1) != RGAC_HDFDD_NOSCHD &&
                  (*(sfDir - 2) == RGAC_HDFDD_DLDATA && *(sfDir - 1) != RGAC_HDFDD_DLCNTRL))
            {
              CMXTA_DBG_ERR((_cmxtap,
              "rgAcUtlTfuUtlVldtHdfddPDCCH(): Guard period Violation\n"));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }
            /* No issues, update the direction */
            *sfDir = RGAC_HDFDD_UL;
            break;
         }
      } /* end of for (idx = 0; idx... */
      nodeUl = nodeUl->next;
   } /* end of while */

   /* Validate DL UEs Allocation info w.r.t SF direction*/
   while (nodeDl)
   {
      pdcchDl = (TfuPdcchInfo *)nodeDl->node;
      for (idx = 0; idx < maxSchUe; idx++)
      {
         if (rgAccCb.acUeCb[idx].crnti == pdcchDl->rnti &&
               rgAccCb.acUeCb[idx].isHdFddEnbld)
         {
            /* Always take the last element in array, as
               this PDCCH is for that element */
            sfDir = &(rgAccCb.ueSfInfo[idx].sfDir[RGAC_HDFDD_SF_HIST - 1]);

            /* Check for Collision of marking*/
            if (*sfDir != RGAC_HDFDD_NOSCHD && *sfDir == RGAC_HDFDD_UL)
            {
              CMXTA_DBG_ERR((_cmxtap,
              "rgAcUtlTfuUtlVldtHdfddPDCCH(): DL-UL SF direction collision\n"));
               RETVALUE(CMXTA_ERR_NOMATCH);
            }

            /* No issues, update the direction */
            *sfDir = RGAC_HDFDD_DLDATA;
            break;
         }
      } /* end of for (idx = 0; idx... */
      nodeDl = nodeDl->next;
   } /* end of while */
   RETVALUE(CMXTA_ERR_NONE);
} /* End of rgAcUtlTfuUtlVldtHdfddPDCCH */

/** @brief Validate BCH allocation with respect to HDFDD feature
 *
 * @details
 * Is called from rgAcHdlTfuBchDatReq
 *
 *     Function:  rgAcTfuUtlHdfddVldtBCH
 *
 *         Processing steps:
 *         - 
 *
 *
 * @param tcCb pointer to CmXtaTCCb 
 * @param spCb pointer to CmXtaSpCb 
 * @param cntrlReq pointer to TfuCntrlReqInfo
 * @return 
 * -# CMXTA_ERR_NONE on match
 * -# CMXTA_ERR_INT on internal error
 * -# CMXTA_ERR_NOMATCH on no match
 */
#ifdef ANSI
PRIVATE S16 rgAcTfuUtlHdfddVldtBCH
(
 CmXtaTCCb     *tcCb,
 CmXtaSpCb     *spCb,
 TfuDatReqInfo *datReq
)
#else
PRIVATE S16 rgAcTfuUtlHdfddVldtBCH (tcCb, spCb, datReq)
 CmXtaTCCb     *tcCb;
 CmXtaSpCb     *spCb;
 TfuDatReqInfo *datReq;
#endif
{
   U8       idx;
   U8       *sfDir;
   TRC2(rgAcTfuUtlHdfddVldtBCH);
   /* This is cell-wide allocation */
   /* This request is for suframe current + TFU_DELTA */
   /* Always take the last element in array, as
   this PDCCH is for that element */
   for (idx = 0; idx < RG_ACC_MAX_UE && rgAccCb.acUeCb[idx].isHdFddEnbld; idx++)
   {
      sfDir = &(rgAccCb.ueSfInfo[idx].sfDir[RGAC_HDFDD_SF_HIST - 1]);
      if (*sfDir == RGAC_HDFDD_UL)
      {
         CMXTA_DBG_ERR((_cmxtap,
         "rgAcTfuUtlHdfddVldtBCH(): BCH-UL SF direction collision\n"));
         RETVALUE(CMXTA_ERR_NOMATCH);
      }
      *sfDir = RGAC_HDFDD_DLDATA;
   }
   

   RETVALUE(CMXTA_ERR_NONE);
} /* End of function rgAcTfuUtlHdfddVldtBCH */
#endif /* Endif ifdef LTEMAC_HDFDD */

/**********************************************************************
 
         End of file:     rgac_tfuutl.c@@/main/3 - Sat Jul 30 02:21:10 2011
 
**********************************************************************/
 
/**********************************************************************
 
        Notes:
 
**********************************************************************/
 
/**********************************************************************
 
        Revision history:
 
**********************************************************************/
/********************************************************************90**
 
     ver       pat    init                  description
------------ -------- ---- ----------------------------------------------
/main/1      ---     ps              1. Initial Release.
/main/2      ---     ps              1. LTE MAC 2.1 release
           rg001.201 sm              1. ccpu00107387: To include the 
                                        length and ModOrder in DataRecp Req.   
                                     2. ccpu00107637: Nprb indication at 
                                        PHY for common Channel.
           rg002.201 sm              1. Changing raRnti calculation to consider
                                        the preamble length.
           rg003.201 ns              1. race added for functions.
                                     2. Fixed code issues changed hqPId to prevHqPId.
           rg004.201 ps              1. Added validation for isRtx, dai
                     ms              2. DL DTX Handling
           rg005.201 sm              1. Added Cast for c++ compilation
           rg006.201 sd              1. Compilation warnings removal: added
                                        explicit cast.
           rg007.201   ap  1. Added support for MIMO
           rg008.201   rsharon  1. Added support for SPS.
           rg009.201   dv  1. Added Changes of TFU_UPGRADE.
/main/3      ---      nu  1. Updated for release LTE-MAC 3.1
           rg001.301  nudupi  1.Changes for the ticket ccpu00118643. 
           rg002.301  asehgal 1.ccpu00120703: changed the msg3 imcs max to 15
                                from 28
           rg002.301  dvasisht  1.Changes for the ticket ccpu00118352. 
                                2. ccpu00118351: seperate UL & DL deltas.
/main/4    rg003.301 ap         1. ccpu00120938 - Correcting the values of initNumRbs in puschRecpReq.
$SID$      ---       rt         1. LTE MAC 4.1 release
*********************************************************************91*/
