///////////////////////////////////////////////////////////////////////////////
//
// Tr069FileTransfer_fsm.h
//
// Autogenerated from Tr069FileTransfer.fsm
//
// See header file for documentation.
//
// Copyright radisys Limited
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __Tr069FileTransfer_fsm_h_
#define __Tr069FileTransfer_fsm_h_
///////////////////////////////////////////////////////////////////////////////
// System Includes
///////////////////////////////////////////////////////////////////////////////

#include <list>
#include <deque>
#include <system/Trace.h>

///////////////////////////////////////////////////////////////////////////////
// Local Includes
///////////////////////////////////////////////////////////////////////////////

#include "Tr069FileTransfer_fsm_interface.h"

using namespace tr069;

namespace tr069
{

/*** WARNING: Code AUTO-GENERATED from Tr069FileTransfer.fsm. Do not edit! ***/
class FileTransferFsm
{
public:

    FileTransferFsm(
        FileTransferFsmInterface & interfaceClass,
        bool traceEnabled = false,
        const char * name = "FileTransferFsm"
        );
    virtual ~FileTransferFsm();

    void InjectFtpSessionCommand(shared_ptr<FtpSessionCommand> event);
    void InjectActivateSoftware(void* event);
    void InjectFtpCnf(shared_ptr<FtpCnf> event);
    void InjectFtpCompleteInd(shared_ptr<FtpCompleteInd> event);
    void InjectTimerExpiry(void* event);
    void InjectFileOk(void* event);
    void InjectApplyUpdateCnf(shared_ptr<ApplyUpdateCnf> event);
    void InjectInstallUpdateCnf(shared_ptr<InstallUpdateCnf> event);
    void InjectActivateUpdateCnf(shared_ptr<ActivateUpdateCnf> event);
    void InjectTransportCnf(shared_ptr<TransportCnf> event);
    std::string ToString() const
    {
        std::string returnedString(mName);

        if(mState)
        {
            returnedString += ".";
            returnedString += mState->mName;
        }

        return returnedString;
    }

    void Rename( const std::string & newName)
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.-: Renamed to %s", mName.c_str(), newName.c_str() );
        }
        mName = newName;
    }

    void SetFsmTraceEnable( bool traceEnable = true ) { mFsmTraceEnabled = traceEnable; }

    void TracePoint( const char * s )
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.%u: %s", mName.c_str(), mEventCounter, s );
        }
    }

private:
    typedef enum EventId_tag
    {
        FSM_EVENT_FtpSessionCommand,
        FSM_EVENT_ActivateSoftware,
        FSM_EVENT_FtpCnf,
        FSM_EVENT_FtpCompleteInd,
        FSM_EVENT_TimerExpiry,
        FSM_EVENT_FileOk,
        FSM_EVENT_ApplyUpdateCnf,
        FSM_EVENT_InstallUpdateCnf,
        FSM_EVENT_ActivateUpdateCnf,
        FSM_EVENT_TransportCnf,
        NUMBER_OF_INJECTABLE_EVENTS
    } EventId;

    typedef enum EventType_tag
    {
        FSM_EVENT_TYPE_shared_ptr_LT_FtpCnf_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_FtpCompleteInd_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_FtpSessionCommand_GT_,
        FSM_EVENT_TYPE_void_STAR_,
        FSM_EVENT_TYPE_shared_ptr_LT_ApplyUpdateCnf_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_InstallUpdateCnf_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_ActivateUpdateReq_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_ActivateUpdateCnf_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_TransportCnf_GT_,
        NUMBER_OF_EVENT_TYPES
    } EventType;

    class FsmEvent
    {
    public:
        FsmEvent( EventType eventType ) :
            mEventType(eventType) {}
        virtual ~FsmEvent(){}

        EventType mEventType;
    };

    class FsmEvent_shared_ptr_LT_FtpCnf_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_FtpCnf_GT_( shared_ptr<FtpCnf> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_FtpCnf_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_FtpCnf_GT_() {}
    	shared_ptr<FtpCnf> mEvent;
    };

    class FsmEvent_shared_ptr_LT_FtpCompleteInd_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_FtpCompleteInd_GT_( shared_ptr<FtpCompleteInd> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_FtpCompleteInd_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_FtpCompleteInd_GT_() {}
    	shared_ptr<FtpCompleteInd> mEvent;
    };

    class FsmEvent_shared_ptr_LT_FtpSessionCommand_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_FtpSessionCommand_GT_( shared_ptr<FtpSessionCommand> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_FtpSessionCommand_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_FtpSessionCommand_GT_() {}
    	shared_ptr<FtpSessionCommand> mEvent;
    };

    class FsmEvent_void_STAR_ : public FsmEvent
    {
    public:
        FsmEvent_void_STAR_( void* event ) :
            FsmEvent(FSM_EVENT_TYPE_void_STAR_),
            mEvent(event) {}
        ~FsmEvent_void_STAR_() {}
    	void* mEvent;
    };

    class FsmEvent_shared_ptr_LT_ApplyUpdateCnf_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_ApplyUpdateCnf_GT_( shared_ptr<ApplyUpdateCnf> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_ApplyUpdateCnf_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_ApplyUpdateCnf_GT_() {}
    	shared_ptr<ApplyUpdateCnf> mEvent;
    };

    class FsmEvent_shared_ptr_LT_InstallUpdateCnf_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_InstallUpdateCnf_GT_( shared_ptr<InstallUpdateCnf> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_InstallUpdateCnf_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_InstallUpdateCnf_GT_() {}
    	shared_ptr<InstallUpdateCnf> mEvent;
    };

    class FsmEvent_shared_ptr_LT_ActivateUpdateReq_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_ActivateUpdateReq_GT_( shared_ptr<ActivateUpdateReq> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_ActivateUpdateReq_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_ActivateUpdateReq_GT_() {}
    	shared_ptr<ActivateUpdateReq> mEvent;
    };

    class FsmEvent_shared_ptr_LT_ActivateUpdateCnf_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_ActivateUpdateCnf_GT_( shared_ptr<ActivateUpdateCnf> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_ActivateUpdateCnf_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_ActivateUpdateCnf_GT_() {}
    	shared_ptr<ActivateUpdateCnf> mEvent;
    };

    class FsmEvent_shared_ptr_LT_TransportCnf_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_TransportCnf_GT_( shared_ptr<TransportCnf> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_TransportCnf_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_TransportCnf_GT_() {}
    	shared_ptr<TransportCnf> mEvent;
    };

    void Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent );

    class State;
    typedef std::deque< State * > StateHistory;

    class State
    {
    public:
        State(FileTransferFsm & fsm, const char * name ) :
            mFsm(fsm),
            mName(name){}
        virtual ~State(){}

        virtual void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData ) { RSYS_ASSERT_PRINTF(false,"Cannot inject in state %s.", mName.c_str()); }
        virtual bool RunToCompletion() { RSYS_ASSERT_PRINTF(false,"RunToCompletion failure in state %s.", mName.c_str()); return false; };
        virtual bool DeferEvent( EventId ) const { RSYS_ASSERT_PRINTF(false,"Cannot defer in state %s.", mName.c_str()); return false; }

        virtual void Entry()
        {
            RSYS_ASSERT( mFsm.mState == GetSuperstate() );

            UpdateHistoryUponEntry();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (entry) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceEntryMethod();

            mFsm.mState = this;
        }

        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            UpdateHistoryUponExit();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }

        FileTransferFsm& mFsm;
        std::string mName;
        virtual State * GetSuperstate() const { return NULL; }
        virtual void  InterfaceEntryMethod() {}
        virtual void  InterfaceExitMethod() {}
        virtual void  UpdateHistoryUponExit() { mFsm.mCurrentStateTransitionExitsList.push_front( mFsm.mState ); }
        virtual void  UpdateHistoryUponEntry() { mFsm.mCurrentStateTransitionExitsList.clear(); }
    };

    class SimpleState : public State
    {
    public:
        SimpleState(FileTransferFsm & fsm, const char * name) :
            State(fsm, name){}
        virtual ~SimpleState(){}

        void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData );
        virtual bool RunToCompletion() { return true; }

        virtual bool DeferEvent( EventId ) const { return false; }
        virtual void InjectFtpSessionCommand( shared_ptr<FtpSessionCommand> eventData) { EventConsumed(FSM_EVENT_FtpSessionCommand); }
        virtual void InjectActivateSoftware( void* eventData) { EventConsumed(FSM_EVENT_ActivateSoftware); }
        virtual void InjectFtpCnf( shared_ptr<FtpCnf> eventData) { EventConsumed(FSM_EVENT_FtpCnf); }
        virtual void InjectFtpCompleteInd( shared_ptr<FtpCompleteInd> eventData) { EventConsumed(FSM_EVENT_FtpCompleteInd); }
        virtual void InjectTimerExpiry( void* eventData) { EventConsumed(FSM_EVENT_TimerExpiry); }
        virtual void InjectFileOk( void* eventData) { EventConsumed(FSM_EVENT_FileOk); }
        virtual void InjectApplyUpdateCnf( shared_ptr<ApplyUpdateCnf> eventData) { EventConsumed(FSM_EVENT_ApplyUpdateCnf); }
        virtual void InjectInstallUpdateCnf( shared_ptr<InstallUpdateCnf> eventData) { EventConsumed(FSM_EVENT_InstallUpdateCnf); }
        virtual void InjectActivateUpdateCnf( shared_ptr<ActivateUpdateCnf> eventData) { EventConsumed(FSM_EVENT_ActivateUpdateCnf); }
        virtual void InjectTransportCnf( shared_ptr<TransportCnf> eventData) { EventConsumed(FSM_EVENT_TransportCnf); }

    private:
        void EventConsumed( EventId queuedEventId )
        {
            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s consumed %s", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str(), mEventName[queuedEventId] ); }
        }
    };

    class Idle : public SimpleState
    {
    public:
        Idle(FileTransferFsm & fsm) :
            SimpleState(fsm, "Idle") {}
        virtual ~Idle(){}

        virtual void InjectFtpSessionCommand( shared_ptr<FtpSessionCommand> eventData);
    };

    class AwaitTransportCnf : public SimpleState
    {
    public:
        AwaitTransportCnf(FileTransferFsm & fsm) :
            SimpleState(fsm, "AwaitTransportCnf") {}
        virtual ~AwaitTransportCnf(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.AwaitTransportCnfEntry();}
        virtual void InjectTransportCnf( shared_ptr<TransportCnf> eventData);
    };

    class ActivatingSwPackage : public SimpleState
    {
    public:
        ActivatingSwPackage(FileTransferFsm & fsm) :
            SimpleState(fsm, "ActivatingSwPackage") {}
        virtual ~ActivatingSwPackage(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.ActivatingSwPackageEntry();}
        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mInProcedure; }
        virtual void InjectActivateUpdateCnf( shared_ptr<ActivateUpdateCnf> eventData);
    };

    class WaitFtpCnf : public SimpleState
    {
    public:
        WaitFtpCnf(FileTransferFsm & fsm) :
            SimpleState(fsm, "WaitFtpCnf") {}
        virtual ~WaitFtpCnf(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.WaitFtpCnfEntry();}
        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mWaitFtpThreadResponse; }
        virtual void InjectFtpCnf( shared_ptr<FtpCnf> eventData);
        virtual void InjectTimerExpiry( void* eventData);
    };

    class WaitFtpCompleteInd : public SimpleState
    {
    public:
        WaitFtpCompleteInd(FileTransferFsm & fsm) :
            SimpleState(fsm, "WaitFtpCompleteInd") {}
        virtual ~WaitFtpCompleteInd(){}

        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mWaitFtpThreadResponse; }
        virtual void InjectFtpCompleteInd( shared_ptr<FtpCompleteInd> eventData);
        virtual void InjectTimerExpiry( void* eventData);
    };

    class InstallUpdateOnly : public SimpleState
    {
    public:
        InstallUpdateOnly(FileTransferFsm & fsm) :
            SimpleState(fsm, "InstallUpdateOnly") {}
        virtual ~InstallUpdateOnly(){}

        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mInstallUpdate; }
        virtual void InjectInstallUpdateCnf( shared_ptr<InstallUpdateCnf> eventData);
    };

    class InstallUpdateThenActivate : public SimpleState
    {
    public:
        InstallUpdateThenActivate(FileTransferFsm & fsm) :
            SimpleState(fsm, "InstallUpdateThenActivate") {}
        virtual ~InstallUpdateThenActivate(){}

        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mInstallUpdate; }
        virtual void InjectInstallUpdateCnf( shared_ptr<InstallUpdateCnf> eventData);
    };

    class Superstate : public State
    {
    public:
        Superstate(FileTransferFsm & fsm, const char * name) :
            State(fsm, name)
        { }
        virtual ~Superstate()
        { }
    };

    class SuperstateWithInitialState : public Superstate
    {
    public:
        SuperstateWithInitialState(FileTransferFsm & fsm, const char * name) :
            Superstate(fsm, name) {}
        virtual ~SuperstateWithInitialState() {}

        virtual bool RunToCompletion() = 0;
    };

    class InProcedure : public SuperstateWithInitialState
    {
    public:
        InProcedure(FileTransferFsm & fsm) :
            SuperstateWithInitialState(fsm, "InProcedure") {}
        virtual ~InProcedure(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.InProcedureEntry();}
    void InterfaceExitMethod( void ) { mFsm.mInterface.InProcedureExit();}

    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mWaitFtpThreadResponse.Entry();
            }

            return false;
        }
    };

    class WaitFtpThreadResponse : public SuperstateWithInitialState
    {
    public:
        WaitFtpThreadResponse(FileTransferFsm & fsm) :
            SuperstateWithInitialState(fsm, "WaitFtpThreadResponse") {}
        virtual ~WaitFtpThreadResponse(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.WaitFtpThreadResponseEntry();}
    void InterfaceExitMethod( void ) { mFsm.mInterface.WaitFtpThreadResponseExit();}

    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mWaitFtpCnf.Entry();
            }

            return false;
        }
        State * GetSuperstate() const { return &mFsm.mInProcedure; }
    };

    class FileTransferSucceeded : public SuperstateWithInitialState
    {
    public:
        FileTransferSucceeded(FileTransferFsm & fsm) :
            SuperstateWithInitialState(fsm, "FileTransferSucceeded") {}
        virtual ~FileTransferSucceeded(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.FileTransferSucceededEntry();}

    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mTransferSucceededJunction.Entry();
            }

            return false;
        }
        State * GetSuperstate() const { return &mFsm.mInProcedure; }
    };

    class NewSwPackage : public Superstate
    {
    public:
        NewSwPackage(FileTransferFsm & fsm) :
            Superstate(fsm, "NewSwPackage") {}
        virtual ~NewSwPackage(){}


    private:
        State * GetSuperstate() const { return &mFsm.mFileTransferSucceeded; }
    };

    class InstallUpdate : public Superstate
    {
    public:
        InstallUpdate(FileTransferFsm & fsm) :
            Superstate(fsm, "InstallUpdate") {}
        virtual ~InstallUpdate(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.InstallUpdateEntry();}

    private:
        State * GetSuperstate() const { return &mFsm.mNewSwPackage; }
    };

    class TransferComplete : public Superstate
    {
    public:
        TransferComplete(FileTransferFsm & fsm) :
            Superstate(fsm, "TransferComplete") {}
        virtual ~TransferComplete(){}


    private:
        State * GetSuperstate() const { return &mFsm.mInProcedure; }
    };

    class Junction : public State
    {
    public:
        Junction(FileTransferFsm & fsm, const char * name) :
            State(fsm, name) {}
        virtual ~Junction(){}
        virtual void Entry() = 0;
        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }
        virtual void  UpdateHistoryUponExit() {}
        virtual void  UpdateHistoryUponEntry() {}
    };

    class TransferSucceededJunction : public Junction
    {
    public:
        TransferSucceededJunction(FileTransferFsm & fsm) :
            Junction(fsm, "TransferSucceededJunction") {}
        virtual ~TransferSucceededJunction(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mFileTransferSucceeded; }
    };

    class SwLoad : public Junction
    {
    public:
        SwLoad(FileTransferFsm & fsm) :
            Junction(fsm, "SwLoad") {}
        virtual ~SwLoad(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mNewSwPackage; }
    };

    class SendResponse : public Junction
    {
    public:
        SendResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendResponse") {}
        virtual ~SendResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class SendUploadResponse : public Junction
    {
    public:
        SendUploadResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendUploadResponse") {}
        virtual ~SendUploadResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class SendDownloadResponse : public Junction
    {
    public:
        SendDownloadResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendDownloadResponse") {}
        virtual ~SendDownloadResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class SendDownloadSucceededResponse : public Junction
    {
    public:
        SendDownloadSucceededResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendDownloadSucceededResponse") {}
        virtual ~SendDownloadSucceededResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class SendDownloadFailedResponse : public Junction
    {
    public:
        SendDownloadFailedResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendDownloadFailedResponse") {}
        virtual ~SendDownloadFailedResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class SendDownloadInvalidResponse : public Junction
    {
    public:
        SendDownloadInvalidResponse(FileTransferFsm & fsm) :
            Junction(fsm, "SendDownloadInvalidResponse") {}
        virtual ~SendDownloadInvalidResponse(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class ExitPoint : public State
    {
    public:
        ExitPoint(FileTransferFsm & fsm, const char * name) :
            State(fsm, name) {}
        virtual ~ExitPoint(){}
        virtual void Entry() = 0;
        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            mFsm.mState =  GetSuperstate();
        }
        virtual void  UpdateHistoryUponExit() {}
        virtual void  UpdateHistoryUponEntry() {}
    };

    class ResponseSent : public ExitPoint
    {
    public:
        ResponseSent(FileTransferFsm & fsm) :
            ExitPoint(fsm, "ResponseSent") {}
        virtual ~ResponseSent(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mTransferComplete; }
    };

    class GoInactive : public ExitPoint
    {
    public:
        GoInactive(FileTransferFsm & fsm) :
            ExitPoint(fsm, "GoInactive") {}
        virtual ~GoInactive(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mInProcedure; }
    };

    class QueuedFsmEvent
    {
    public:
        QueuedFsmEvent( EventId eventId, shared_ptr<FsmEvent> fsmEvent) :
            mId(eventId),
            mFsmEvent(fsmEvent){}
        ~QueuedFsmEvent(){}

        EventId mId;
        shared_ptr<FsmEvent> mFsmEvent;
    };

    FileTransferFsmInterface & mInterface;
    bool mFsmTraceEnabled;
    std::string mName;
    State * mState;
    Idle mIdle;
    AwaitTransportCnf mAwaitTransportCnf;
    InProcedure mInProcedure;
    ActivatingSwPackage mActivatingSwPackage;
    WaitFtpThreadResponse mWaitFtpThreadResponse;
    WaitFtpCnf mWaitFtpCnf;
    WaitFtpCompleteInd mWaitFtpCompleteInd;
    FileTransferSucceeded mFileTransferSucceeded;
    TransferSucceededJunction mTransferSucceededJunction;
    NewSwPackage mNewSwPackage;
    SwLoad mSwLoad;
    InstallUpdate mInstallUpdate;
    InstallUpdateOnly mInstallUpdateOnly;
    InstallUpdateThenActivate mInstallUpdateThenActivate;
    TransferComplete mTransferComplete;
    SendResponse mSendResponse;
    SendUploadResponse mSendUploadResponse;
    SendDownloadResponse mSendDownloadResponse;
    SendDownloadSucceededResponse mSendDownloadSucceededResponse;
    SendDownloadFailedResponse mSendDownloadFailedResponse;
    SendDownloadInvalidResponse mSendDownloadInvalidResponse;
    ResponseSent mResponseSent;
    GoInactive mGoInactive;
    std::list< shared_ptr<QueuedFsmEvent> > mfsmEventQueue;
    bool mFsmInjectInProgress;
    unsigned mEventCounter;
    StateHistory mCurrentStateTransitionExitsList;
    static const char * mEventName[NUMBER_OF_INJECTABLE_EVENTS];

};

} // -namespace-

#endif // __Tr069FileTransfer_fsm_interface_h_

