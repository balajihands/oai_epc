///////////////////////////////////////////////////////////////////////////////
//
// Tr069SecGwConnection_fsm.h
//
// Autogenerated from /mnt/hgfs/Shared/Master_MSPD_CCPU/tenb_commonplatform/software/apps/fap/management/tr069-v2/Tr069SecGwConnection.fsm
//
// See header file for documentation.
//
// Copyright Radisys Limited
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __Tr069SecGwConnection_fsm_h_
#define __Tr069SecGwConnection_fsm_h_
///////////////////////////////////////////////////////////////////////////////
// System Includes
///////////////////////////////////////////////////////////////////////////////

#include <list>
#include <deque>
#include <system/Trace.h>

///////////////////////////////////////////////////////////////////////////////
// Local Includes
///////////////////////////////////////////////////////////////////////////////

#include "Tr069SecGwConnection_fsm_interface.h"

using namespace tr069;

namespace tr069
{

/*** WARNING: Code AUTO-GENERATED from /mnt/hgfs/Shared/Master_MSPD_CCPU/tenb_commonplatform/software/apps/fap/management/tr069-v2/Tr069SecGwConnection.fsm. Do not edit! ***/
class SecGwConnectionFsm
{
public:

    SecGwConnectionFsm(
        SecGwConnectionFsmInterface & interfaceClass,
        bool traceEnabled = false,
        const char * name = "SecGwConnectionFsm"
        );
    virtual ~SecGwConnectionFsm();

    void InjectStateGuardTimerExpiry(void * event);
    void InjectSecGwModify(shared_ptr<SecGwModifyReq> event);
    void InjectIkeTunnelCreateCnf(shared_ptr<threeway::Queueable> event);
    void InjectIkeTunnelDeleteCnf(shared_ptr<threeway::Queueable> event);
    void InjectIkeTunnelDisconnectionInd(shared_ptr<threeway::Queueable> event);
    void InjectIkeTunnelConnectionInd(shared_ptr<IkeTunnelConnectInd> event);
    void InjectCwmpLockedInd(shared_ptr<LockedInd> event);
    void InjectTransportReq(shared_ptr<TransportReq> event);
    std::string ToString() const
    {
        std::string returnedString(mName);

        if(mState)
        {
            returnedString += ".";
            returnedString += mState->mName;
        }

        return returnedString;
    }

    void Rename( const std::string & newName)
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.-: Renamed to %s", mName.c_str(), newName.c_str() );
        }
        mName = newName;
    }

    void SetFsmTraceEnable( bool traceEnable = true ) { mFsmTraceEnabled = traceEnable; }

    void TracePoint( const char * s )
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.%u: %s", mName.c_str(), mEventCounter, s );
        }
    }

private:
    typedef enum EventId_tag
    {
        FSM_EVENT_StateGuardTimerExpiry,
        FSM_EVENT_SecGwModify,
        FSM_EVENT_IkeTunnelCreateCnf,
        FSM_EVENT_IkeTunnelDeleteCnf,
        FSM_EVENT_IkeTunnelDisconnectionInd,
        FSM_EVENT_IkeTunnelConnectionInd,
        FSM_EVENT_CwmpLockedInd,
        FSM_EVENT_TransportReq,
        NUMBER_OF_INJECTABLE_EVENTS
    } EventId;

    typedef enum EventType_tag
    {
        FSM_EVENT_TYPE_void_STAR_,
        FSM_EVENT_TYPE_shared_ptr_LT_SecGwModifyReq_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_IkeTunnelConnectInd_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_threeway_COLON__COLON_Queueable_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_TransportReq_GT_,
        FSM_EVENT_TYPE_shared_ptr_LT_LockedInd_GT_,
        NUMBER_OF_EVENT_TYPES
    } EventType;

    class FsmEvent
    {
    public:
        FsmEvent( EventType eventType ) :
            mEventType(eventType) {}
        virtual ~FsmEvent(){}

        EventType mEventType;
    };

    class FsmEvent_void_STAR_ : public FsmEvent
    {
    public:
        FsmEvent_void_STAR_( void * event ) :
            FsmEvent(FSM_EVENT_TYPE_void_STAR_),
            mEvent(event) {}
        ~FsmEvent_void_STAR_() {}
    	void * mEvent;
    };

    class FsmEvent_shared_ptr_LT_SecGwModifyReq_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_SecGwModifyReq_GT_( shared_ptr<SecGwModifyReq> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_SecGwModifyReq_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_SecGwModifyReq_GT_() {}
    	shared_ptr<SecGwModifyReq> mEvent;
    };

    class FsmEvent_shared_ptr_LT_IkeTunnelConnectInd_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_IkeTunnelConnectInd_GT_( shared_ptr<IkeTunnelConnectInd> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_IkeTunnelConnectInd_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_IkeTunnelConnectInd_GT_() {}
    	shared_ptr<IkeTunnelConnectInd> mEvent;
    };

    class FsmEvent_shared_ptr_LT_threeway_COLON__COLON_Queueable_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_threeway_COLON__COLON_Queueable_GT_( shared_ptr<threeway::Queueable> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_threeway_COLON__COLON_Queueable_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_threeway_COLON__COLON_Queueable_GT_() {}
    	shared_ptr<threeway::Queueable> mEvent;
    };

    class FsmEvent_shared_ptr_LT_TransportReq_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_TransportReq_GT_( shared_ptr<TransportReq> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_TransportReq_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_TransportReq_GT_() {}
    	shared_ptr<TransportReq> mEvent;
    };

    class FsmEvent_shared_ptr_LT_LockedInd_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_LockedInd_GT_( shared_ptr<LockedInd> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_LockedInd_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_LockedInd_GT_() {}
    	shared_ptr<LockedInd> mEvent;
    };

    void Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent );

    class State;
    typedef std::deque< State * > StateHistory;

    class State
    {
    public:
        State(SecGwConnectionFsm & fsm, const char * name ) :
            mFsm(fsm),
            mName(name){}
        virtual ~State(){}

        virtual void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData ) { RSYS_ASSERT_PRINTF(false,"Cannot inject in state %s.", mName.c_str()); }
        virtual bool RunToCompletion() { RSYS_ASSERT_PRINTF(false,"RunToCompletion failure in state %s.", mName.c_str()); return false; };
        virtual bool DeferEvent( EventId ) const { RSYS_ASSERT_PRINTF(false,"Cannot defer in state %s.", mName.c_str()); return false; }

        virtual void Entry()
        {
            RSYS_ASSERT( mFsm.mState == GetSuperstate() );

            UpdateHistoryUponEntry();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (entry) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceEntryMethod();

            mFsm.mState = this;
        }

        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            UpdateHistoryUponExit();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }

        SecGwConnectionFsm& mFsm;
        std::string mName;
        virtual State * GetSuperstate() const { return NULL; }
        virtual void  InterfaceEntryMethod() {}
        virtual void  InterfaceExitMethod() {}
        virtual void  UpdateHistoryUponExit() { mFsm.mCurrentStateTransitionExitsList.push_front( mFsm.mState ); }
        virtual void  UpdateHistoryUponEntry() { mFsm.mCurrentStateTransitionExitsList.clear(); }
    };

    class SimpleState : public State
    {
    public:
        SimpleState(SecGwConnectionFsm & fsm, const char * name) :
            State(fsm, name){}
        virtual ~SimpleState(){}

        void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData );
        virtual bool RunToCompletion() { return true; }

        virtual bool DeferEvent( EventId ) const { return false; }
        virtual void InjectStateGuardTimerExpiry( void * eventData) { EventConsumed(FSM_EVENT_StateGuardTimerExpiry); }
        virtual void InjectSecGwModify( shared_ptr<SecGwModifyReq> eventData) { EventConsumed(FSM_EVENT_SecGwModify); }
        virtual void InjectIkeTunnelCreateCnf( shared_ptr<threeway::Queueable> eventData) { EventConsumed(FSM_EVENT_IkeTunnelCreateCnf); }
        virtual void InjectIkeTunnelDeleteCnf( shared_ptr<threeway::Queueable> eventData) { EventConsumed(FSM_EVENT_IkeTunnelDeleteCnf); }
        virtual void InjectIkeTunnelDisconnectionInd( shared_ptr<threeway::Queueable> eventData) { EventConsumed(FSM_EVENT_IkeTunnelDisconnectionInd); }
        virtual void InjectIkeTunnelConnectionInd( shared_ptr<IkeTunnelConnectInd> eventData) { EventConsumed(FSM_EVENT_IkeTunnelConnectionInd); }
        virtual void InjectCwmpLockedInd( shared_ptr<LockedInd> eventData) { EventConsumed(FSM_EVENT_CwmpLockedInd); }
        virtual void InjectTransportReq( shared_ptr<TransportReq> eventData) { EventConsumed(FSM_EVENT_TransportReq); }

    private:
        void EventConsumed( EventId queuedEventId )
        {
            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s consumed %s", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str(), mEventName[queuedEventId] ); }
        }
    };

    class CreatingIkeTunnel : public SimpleState
    {
    public:
        CreatingIkeTunnel(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "CreatingIkeTunnel") {}
        virtual ~CreatingIkeTunnel(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.CreatingIkeTunnelEntry();}
        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mConnectionProcedure; }
        virtual void InjectStateGuardTimerExpiry( void * eventData);
        virtual void InjectSecGwModify( shared_ptr<SecGwModifyReq> eventData);
        virtual void InjectIkeTunnelCreateCnf( shared_ptr<threeway::Queueable> eventData);
    };

    class ConnectingIkeTunnel : public SimpleState
    {
    public:
        ConnectingIkeTunnel(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "ConnectingIkeTunnel") {}
        virtual ~ConnectingIkeTunnel(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.ConnectingIkeTunnelEntry();}
        bool DeferEvent( EventId ) const ;
        State * GetSuperstate() const { return &mFsm.mConnectionProcedure; }
        virtual void InjectStateGuardTimerExpiry( void * eventData);
        virtual void InjectSecGwModify( shared_ptr<SecGwModifyReq> eventData);
        virtual void InjectIkeTunnelDisconnectionInd( shared_ptr<threeway::Queueable> eventData);
        virtual void InjectIkeTunnelConnectionInd( shared_ptr<IkeTunnelConnectInd> eventData);
    };

    class DeletingIkeTunnel : public SimpleState
    {
    public:
        DeletingIkeTunnel(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "DeletingIkeTunnel") {}
        virtual ~DeletingIkeTunnel(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.DeletingIkeTunnelEntry();}
        State * GetSuperstate() const { return &mFsm.mDisconnectionProcedure; }
        virtual void InjectSecGwModify( shared_ptr<SecGwModifyReq> eventData);
        virtual void InjectIkeTunnelDeleteCnf( shared_ptr<threeway::Queueable> eventData);
        virtual void InjectTransportReq( shared_ptr<TransportReq> eventData);
    };

    class CwmpEnable : public SimpleState
    {
    public:
        CwmpEnable(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "CwmpEnable") {}
        virtual ~CwmpEnable(){}

        State * GetSuperstate() const { return &mFsm.mConnected; }
        virtual void InjectSecGwModify( shared_ptr<SecGwModifyReq> eventData);
        virtual void InjectIkeTunnelDisconnectionInd( shared_ptr<threeway::Queueable> eventData);
        virtual void InjectTransportReq( shared_ptr<TransportReq> eventData);
    };

    class CwmpDisable : public SimpleState
    {
    public:
        CwmpDisable(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "CwmpDisable") {}
        virtual ~CwmpDisable(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.CwmpDisableEntry();}
        State * GetSuperstate() const { return &mFsm.mConnected; }
        virtual void InjectCwmpLockedInd( shared_ptr<LockedInd> eventData);
    };

    class Terminate : public SimpleState
    {
    public:
        Terminate(SecGwConnectionFsm & fsm) :
            SimpleState(fsm, "Terminate") {}
        virtual ~Terminate(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.TerminateEntry();}
        void InterfaceExitMethod( void ) {  mFsm.mInterface.TerminateExit();}
        virtual void InjectStateGuardTimerExpiry( void * eventData);
        virtual void InjectTransportReq( shared_ptr<TransportReq> eventData);
    };

    class Superstate : public State
    {
    public:
        Superstate(SecGwConnectionFsm & fsm, const char * name) :
            State(fsm, name)
        { }
        virtual ~Superstate()
        { }
    };

    class SuperstateWithInitialState : public Superstate
    {
    public:
        SuperstateWithInitialState(SecGwConnectionFsm & fsm, const char * name) :
            Superstate(fsm, name) {}
        virtual ~SuperstateWithInitialState() {}

        virtual bool RunToCompletion() = 0;
    };

    class ConnectionProcedure : public SuperstateWithInitialState
    {
    public:
        ConnectionProcedure(SecGwConnectionFsm & fsm) :
            SuperstateWithInitialState(fsm, "ConnectionProcedure") {}
        virtual ~ConnectionProcedure(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.ConnectionProcedureEntry();}
    void InterfaceExitMethod( void ) { mFsm.mInterface.ConnectionProcedureExit();}

    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mCreatingIkeTunnel.Entry();
            }

            return false;
        }
    };

    class DisconnectionProcedure : public SuperstateWithInitialState
    {
    public:
        DisconnectionProcedure(SecGwConnectionFsm & fsm) :
            SuperstateWithInitialState(fsm, "DisconnectionProcedure") {}
        virtual ~DisconnectionProcedure(){}


    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mDeletingIkeTunnel.Entry();
            }

            return false;
        }
    };

    class Connected : public SuperstateWithInitialState
    {
    public:
        Connected(SecGwConnectionFsm & fsm) :
            SuperstateWithInitialState(fsm, "Connected") {}
        virtual ~Connected(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.ConnectedEntry();}
    void InterfaceExitMethod( void ) { mFsm.mInterface.ConnectedExit();}

    private:
        bool RunToCompletion( void )
        {
            {
                mFsm.mCwmpEnable.Entry();
            }

            return false;
        }
    };

    class Junction : public State
    {
    public:
        Junction(SecGwConnectionFsm & fsm, const char * name) :
            State(fsm, name) {}
        virtual ~Junction(){}
        virtual void Entry() = 0;
        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }
        virtual void  UpdateHistoryUponExit() {}
        virtual void  UpdateHistoryUponEntry() {}
    };

    class CheckConfig : public Junction
    {
    public:
        CheckConfig(SecGwConnectionFsm & fsm) :
            Junction(fsm, "CheckConfig") {}
        virtual ~CheckConfig(){}

        void Entry(); 

    private:
    };

    class Disconnected : public Junction
    {
    public:
        Disconnected(SecGwConnectionFsm & fsm) :
            Junction(fsm, "Disconnected") {}
        virtual ~Disconnected(){}

        void Entry(); 

    private:
    };

    class ExitPoint : public State
    {
    public:
        ExitPoint(SecGwConnectionFsm & fsm, const char * name) :
            State(fsm, name) {}
        virtual ~ExitPoint(){}
        virtual void Entry() = 0;
        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            mFsm.mState =  GetSuperstate();
        }
        virtual void  UpdateHistoryUponExit() {}
        virtual void  UpdateHistoryUponEntry() {}
    };

    class ConnectionProcedure_Abort : public ExitPoint
    {
    public:
        ConnectionProcedure_Abort(SecGwConnectionFsm & fsm) :
            ExitPoint(fsm, "ConnectionProcedure_Abort") {}
        virtual ~ConnectionProcedure_Abort(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mConnectionProcedure; }
    };

    class QueuedFsmEvent
    {
    public:
        QueuedFsmEvent( EventId eventId, shared_ptr<FsmEvent> fsmEvent) :
            mId(eventId),
            mFsmEvent(fsmEvent){}
        ~QueuedFsmEvent(){}

        EventId mId;
        shared_ptr<FsmEvent> mFsmEvent;
    };

    SecGwConnectionFsmInterface & mInterface;
    bool mFsmTraceEnabled;
    std::string mName;
    State * mState;
    CheckConfig mCheckConfig;
    Disconnected mDisconnected;
    ConnectionProcedure mConnectionProcedure;
    ConnectionProcedure_Abort mConnectionProcedure_Abort;
    CreatingIkeTunnel mCreatingIkeTunnel;
    ConnectingIkeTunnel mConnectingIkeTunnel;
    DisconnectionProcedure mDisconnectionProcedure;
    DeletingIkeTunnel mDeletingIkeTunnel;
    Connected mConnected;
    CwmpEnable mCwmpEnable;
    CwmpDisable mCwmpDisable;
    Terminate mTerminate;
    std::list< shared_ptr<QueuedFsmEvent> > mfsmEventQueue;
    bool mFsmInjectInProgress;
    unsigned mEventCounter;
    StateHistory mCurrentStateTransitionExitsList;
    static const char * mEventName[NUMBER_OF_INJECTABLE_EVENTS];

};

} // -namespace-

#endif // __Tr069SecGwConnection_fsm_interface_h_

