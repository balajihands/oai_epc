///////////////////////////////////////////////////////////////////////////////
//
// Tenpin_fsm.h
//
// Autogenerated from Tenpin.fsm
//
// See header file for documentation.
//
// Copyright radisys Limited
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __Tenpin_fsm_h_
#define __Tenpin_fsm_h_
///////////////////////////////////////////////////////////////////////////////
// System Includes
///////////////////////////////////////////////////////////////////////////////

#include <list>
#include <deque>
#include <system/Trace.h>

///////////////////////////////////////////////////////////////////////////////
// Local Includes
///////////////////////////////////////////////////////////////////////////////

#include "Tenpin_fsm_interface.h"

using namespace Tenpin;

namespace Tenpin
{

/*** WARNING: Code AUTO-GENERATED from Tenpin.fsm. Do not edit! ***/
class TenpinFsm
{
public:

    TenpinFsm(
        TenpinFsmInterface & interfaceClass,
        bool traceEnabled = false,
        const char * name = "TenpinFsm"
        );
    virtual ~TenpinFsm();

    void InjectGo(void* event);
    void InjectStop(void* event);
    void InjectExpiryGuardTimer(void* event);
    void InjectExpiryIkeGraceTimer(void* event);
    void InjectOamStart(void* event);
    void InjectDnsServerAddReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectFirewallOpenReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectFirewallOpenCnf(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectFirewallCloseReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectFirewallCloseCnf(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectSignatureVerifyReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectMibSubscribeAttributesInd(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectIkeTunnelCreateReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectIkeTunnelDeleteReq(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectIkeTunnelConnectInd(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectIkeTunnelDisconnectInd(shared_ptr<threeway::MessageSerialisedData> event);
    void InjectHwCryptoAvailableInd(shared_ptr<threeway::MessageSerialisedData> event);
    std::string ToString() const
    {
        std::string returnedString(mName);

        if(mState)
        {
            returnedString += ".";
            returnedString += mState->mName;
        }

        return returnedString;
    }

    void Rename( const std::string & newName)
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.-: Renamed to %s", mName.c_str(), newName.c_str() );
        }
        mName = newName;
    }

    void SetFsmTraceEnable( bool traceEnable = true ) { mFsmTraceEnabled = traceEnable; }

    void TracePoint( const char * s )
    {
        if(mFsmTraceEnabled)
        {
        	TRACE_PRINTF("%s.%u: %s", mName.c_str(), mEventCounter, s );
        }
    }

private:
    typedef enum EventId_tag
    {
        FSM_EVENT_Go,
        FSM_EVENT_Stop,
        FSM_EVENT_ExpiryGuardTimer,
        FSM_EVENT_ExpiryIkeGraceTimer,
        FSM_EVENT_OamStart,
        FSM_EVENT_DnsServerAddReq,
        FSM_EVENT_FirewallOpenReq,
        FSM_EVENT_FirewallOpenCnf,
        FSM_EVENT_FirewallCloseReq,
        FSM_EVENT_FirewallCloseCnf,
        FSM_EVENT_SignatureVerifyReq,
        FSM_EVENT_MibSubscribeAttributesInd,
        FSM_EVENT_IkeTunnelCreateReq,
        FSM_EVENT_IkeTunnelDeleteReq,
        FSM_EVENT_IkeTunnelConnectInd,
        FSM_EVENT_IkeTunnelDisconnectInd,
        FSM_EVENT_HwCryptoAvailableInd,
        NUMBER_OF_INJECTABLE_EVENTS
    } EventId;

    typedef enum EventType_tag
    {
        FSM_EVENT_TYPE_void_STAR_,
        FSM_EVENT_TYPE_shared_ptr_LT_threeway_COLON__COLON_MessageSerialisedData_GT_,
        NUMBER_OF_EVENT_TYPES
    } EventType;

    class FsmEvent
    {
    public:
        FsmEvent( EventType eventType ) :
            mEventType(eventType) {}
        virtual ~FsmEvent(){}

        EventType mEventType;
    };

    class FsmEvent_void_STAR_ : public FsmEvent
    {
    public:
        FsmEvent_void_STAR_( void* event ) :
            FsmEvent(FSM_EVENT_TYPE_void_STAR_),
            mEvent(event) {}
        ~FsmEvent_void_STAR_() {}
    	void* mEvent;
    };

    class FsmEvent_shared_ptr_LT_threeway_COLON__COLON_MessageSerialisedData_GT_ : public FsmEvent
    {
    public:
        FsmEvent_shared_ptr_LT_threeway_COLON__COLON_MessageSerialisedData_GT_( shared_ptr<threeway::MessageSerialisedData> event ) :
            FsmEvent(FSM_EVENT_TYPE_shared_ptr_LT_threeway_COLON__COLON_MessageSerialisedData_GT_),
            mEvent(event) {}
        ~FsmEvent_shared_ptr_LT_threeway_COLON__COLON_MessageSerialisedData_GT_() {}
    	shared_ptr<threeway::MessageSerialisedData> mEvent;
    };

    void Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent );

    class State;
    typedef std::deque< State * > StateHistory;

    class State
    {
    public:
        State(TenpinFsm & fsm, const char * name ) :
            mFsm(fsm),
            mName(name){}
        virtual ~State(){}

        virtual void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData ) { RSYS_ASSERT_PRINTF(false,"Cannot inject in state %s.", mName.c_str()); }
        virtual bool RunToCompletion() { RSYS_ASSERT_PRINTF(false,"RunToCompletion failure in state %s.", mName.c_str()); return false; };
        virtual bool DeferEvent( EventId ) const { RSYS_ASSERT_PRINTF(false,"Cannot defer in state %s.", mName.c_str()); return false; }

        virtual void Entry()
        {
            RSYS_ASSERT( mFsm.mState == GetSuperstate() );

            UpdateHistoryUponEntry();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (entry) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceEntryMethod();

            mFsm.mState = this;
        }

        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            UpdateHistoryUponExit();

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }

        TenpinFsm& mFsm;
        std::string mName;
        virtual State * GetSuperstate() const { return NULL; }
        virtual void  InterfaceEntryMethod() {}
        virtual void  InterfaceExitMethod() {}
        virtual void  UpdateHistoryUponExit() { mFsm.mCurrentStateTransitionExitsList.push_front( mFsm.mState ); }
        virtual void  UpdateHistoryUponEntry() { mFsm.mCurrentStateTransitionExitsList.clear(); }
    };

    class SimpleState : public State
    {
    public:
        SimpleState(TenpinFsm & fsm, const char * name) :
            State(fsm, name){}
        virtual ~SimpleState(){}

        void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData );
        virtual bool RunToCompletion() { return true; }

        virtual bool DeferEvent( EventId ) const { return false; }
        virtual void InjectGo( void* eventData) { EventConsumed(FSM_EVENT_Go); }
        virtual void InjectStop( void* eventData) { EventConsumed(FSM_EVENT_Stop); }
        virtual void InjectExpiryGuardTimer( void* eventData) { EventConsumed(FSM_EVENT_ExpiryGuardTimer); }
        virtual void InjectExpiryIkeGraceTimer( void* eventData) { EventConsumed(FSM_EVENT_ExpiryIkeGraceTimer); }
        virtual void InjectOamStart( void* eventData) { EventConsumed(FSM_EVENT_OamStart); }
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_DnsServerAddReq); }
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_FirewallOpenReq); }
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_FirewallOpenCnf); }
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_FirewallCloseReq); }
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_FirewallCloseCnf); }
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_SignatureVerifyReq); }
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_MibSubscribeAttributesInd); }
        virtual void InjectIkeTunnelCreateReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_IkeTunnelCreateReq); }
        virtual void InjectIkeTunnelDeleteReq( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_IkeTunnelDeleteReq); }
        virtual void InjectIkeTunnelConnectInd( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_IkeTunnelConnectInd); }
        virtual void InjectIkeTunnelDisconnectInd( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_IkeTunnelDisconnectInd); }
        virtual void InjectHwCryptoAvailableInd( shared_ptr<threeway::MessageSerialisedData> eventData) { EventConsumed(FSM_EVENT_HwCryptoAvailableInd); }

    private:
        void EventConsumed( EventId queuedEventId )
        {
            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s consumed %s", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str(), mEventName[queuedEventId] ); }
        }
    };

    class Initial : public SimpleState
    {
    public:
        Initial(TenpinFsm & fsm) :
            SimpleState(fsm, "Initial") {}
        virtual ~Initial(){}

        State * GetSuperstate() const { return &mFsm.mAll; }
        virtual void InjectGo( void* eventData);
        virtual void InjectStop( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class Unusable : public SimpleState
    {
    public:
        Unusable(TenpinFsm & fsm) :
            SimpleState(fsm, "Unusable") {}
        virtual ~Unusable(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.UnusableEntry();}
        State * GetSuperstate() const { return &mFsm.mAll; }
        virtual void InjectStop( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class NotConfigured : public SimpleState
    {
    public:
        NotConfigured(TenpinFsm & fsm) :
            SimpleState(fsm, "NotConfigured") {}
        virtual ~NotConfigured(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.NotConfiguredEntry();}
        void InterfaceExitMethod( void ) {  mFsm.mInterface.NotConfiguredExit();}
        State * GetSuperstate() const { return &mFsm.mUsable; }
        virtual void InjectStop( void* eventData);
        virtual void InjectExpiryGuardTimer( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class NotStarted : public SimpleState
    {
    public:
        NotStarted(TenpinFsm & fsm) :
            SimpleState(fsm, "NotStarted") {}
        virtual ~NotStarted(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.NotStartedEntry();}
        State * GetSuperstate() const { return &mFsm.mUsable; }
        virtual void InjectStop( void* eventData);
        virtual void InjectExpiryGuardTimer( void* eventData);
        virtual void InjectOamStart( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class Starting : public SimpleState
    {
    public:
        Starting(TenpinFsm & fsm) :
            SimpleState(fsm, "Starting") {}
        virtual ~Starting(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.StartingEntry();}
        void InterfaceExitMethod( void ) {  mFsm.mInterface.StartingExit();}
        State * GetSuperstate() const { return &mFsm.mUsable; }
        virtual void InjectStop( void* eventData);
        virtual void InjectExpiryIkeGraceTimer( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class Operational : public SimpleState
    {
    public:
        Operational(TenpinFsm & fsm) :
            SimpleState(fsm, "Operational") {}
        virtual ~Operational(){}

        void InterfaceEntryMethod( void ) { mFsm.mInterface.OperationalEntry();}
        void InterfaceExitMethod( void ) {  mFsm.mInterface.OperationalExit();}
        State * GetSuperstate() const { return &mFsm.mStarted; }
        virtual void InjectStop( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectIkeTunnelCreateReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectIkeTunnelDeleteReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectIkeTunnelConnectInd( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectIkeTunnelDisconnectInd( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectHwCryptoAvailableInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class Stopped : public SimpleState
    {
    public:
        Stopped(TenpinFsm & fsm) :
            SimpleState(fsm, "Stopped") {}
        virtual ~Stopped(){}

        State * GetSuperstate() const { return &mFsm.mAll; }
        virtual void InjectStop( void* eventData);
        virtual void InjectDnsServerAddReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallOpenCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectFirewallCloseCnf( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectSignatureVerifyReq( shared_ptr<threeway::MessageSerialisedData> eventData);
        virtual void InjectMibSubscribeAttributesInd( shared_ptr<threeway::MessageSerialisedData> eventData);
    };

    class Superstate : public State
    {
    public:
        Superstate(TenpinFsm & fsm, const char * name) :
            State(fsm, name)
        { }
        virtual ~Superstate()
        { }
    };

    class SuperstateWithInitialState : public Superstate
    {
    public:
        SuperstateWithInitialState(TenpinFsm & fsm, const char * name) :
            Superstate(fsm, name) {}
        virtual ~SuperstateWithInitialState() {}

        virtual bool RunToCompletion() = 0;
    };

    class All : public Superstate
    {
    public:
        All(TenpinFsm & fsm) :
            Superstate(fsm, "All") {}
        virtual ~All(){}


    private:
    };

    class Usable : public Superstate
    {
    public:
        Usable(TenpinFsm & fsm) :
            Superstate(fsm, "Usable") {}
        virtual ~Usable(){}


    private:
        State * GetSuperstate() const { return &mFsm.mAll; }
    };

    class Started : public Superstate
    {
    public:
        Started(TenpinFsm & fsm) :
            Superstate(fsm, "Started") {}
        virtual ~Started(){}

    void InterfaceEntryMethod( void ) { mFsm.mInterface.StartedEntry();}

    private:
        State * GetSuperstate() const { return &mFsm.mUsable; }
    };

    class Junction : public State
    {
    public:
        Junction(TenpinFsm & fsm, const char * name) :
            State(fsm, name) {}
        virtual ~Junction(){}
        virtual void Entry() = 0;
        virtual void Exit()
        {
            RSYS_ASSERT( mFsm.mState == this);

            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s (exit) ", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }

            InterfaceExitMethod();

            mFsm.mState =  GetSuperstate();
        }
        virtual void  UpdateHistoryUponExit() {}
        virtual void  UpdateHistoryUponEntry() {}
    };

    class UsabilityTest : public Junction
    {
    public:
        UsabilityTest(TenpinFsm & fsm) :
            Junction(fsm, "UsabilityTest") {}
        virtual ~UsabilityTest(){}

        void Entry(); 

    private:
        State * GetSuperstate() const { return &mFsm.mAll; }
    };

    class QueuedFsmEvent
    {
    public:
        QueuedFsmEvent( EventId eventId, shared_ptr<FsmEvent> fsmEvent) :
            mId(eventId),
            mFsmEvent(fsmEvent){}
        ~QueuedFsmEvent(){}

        EventId mId;
        shared_ptr<FsmEvent> mFsmEvent;
    };

    TenpinFsmInterface & mInterface;
    bool mFsmTraceEnabled;
    std::string mName;
    State * mState;
    All mAll;
    Initial mInitial;
    Unusable mUnusable;
    Usable mUsable;
    NotConfigured mNotConfigured;
    NotStarted mNotStarted;
    Starting mStarting;
    Started mStarted;
    Operational mOperational;
    Stopped mStopped;
    UsabilityTest mUsabilityTest;
    std::list< shared_ptr<QueuedFsmEvent> > mfsmEventQueue;
    bool mFsmInjectInProgress;
    unsigned mEventCounter;
    StateHistory mCurrentStateTransitionExitsList;
    static const char * mEventName[NUMBER_OF_INJECTABLE_EVENTS];

};

} // -namespace-

#endif // __Tenpin_fsm_interface_h_

