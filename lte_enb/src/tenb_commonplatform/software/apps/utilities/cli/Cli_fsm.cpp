///////////////////////////////////////////////////////////////////////////////
//
//Cli_fsm.cpp
//
// Autogenerated from Cli.fsm
//
// See header file for documentation.
//
// Copyright Radisys Limited
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// System Includes
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <sstream>
#include <iostream>
#include <system/Trace.h>

///////////////////////////////////////////////////////////////////////////////
// Local Includes
///////////////////////////////////////////////////////////////////////////////

#include "Cli_fsm.h"

using namespace std;

///////////////////////////////////////////////////////////////////////////////
// Static Data
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////


/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
CommandLineFsm::CommandLineFsm(
    CommandLineFsmInterface & interfaceClass,
    bool traceEnabled,
    const char * name 
    ) :
    mInterface(interfaceClass),
    mFsmTraceEnabled(traceEnabled),
    mName(name),
    mState(NULL),
    mUserIoThreadRunning(*this ),
    mAwaitCommand(*this ),
    mCommandInProgress(*this ),
    mQuitting(*this ),
    mfsmEventQueue(),
    mFsmInjectInProgress(false),
    mEventCounter(0)
{
    // Initial State
    mUserIoThreadRunning.Entry();
    mAwaitCommand.Entry();

    if(NULL != mState)
    {
       while( !mState->RunToCompletion() )
       {
          continue;
       }
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
CommandLineFsm::~CommandLineFsm()
{
    RSYS_ASSERT_PRINTF(!mFsmInjectInProgress, "CommandLineFsm deleted while event-inject in progress.");

    mfsmEventQueue.clear();
    mCurrentStateTransitionExitsList.clear();
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectStart(void* event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_void_STAR_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_Start, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectStop(shared_ptr<std::string> event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_shared_ptr_LT_std_COLON__COLON_string_GT_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_Stop, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectCommandLine(shared_ptr<CliCommand> event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_shared_ptr_LT_CliCommand_GT_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_CommandLine, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectTimeout(void* event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_void_STAR_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_Timeout, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectCommandComplete(shared_ptr<CliExecuteCmdCnf> event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_shared_ptr_LT_CliExecuteCmdCnf_GT_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_CommandComplete, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectCommandResponse(shared_ptr<CliExecuteCmdInd> event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_shared_ptr_LT_CliExecuteCmdInd_GT_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_CommandResponse, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::InjectCommandProgressing(shared_ptr<CliExecuteCmdProgressInd> event)
{
    shared_ptr<FsmEvent> fsmEvent(new FsmEvent_shared_ptr_LT_CliExecuteCmdProgressInd_GT_(event));
    Enqueue( CommandLineFsm::FSM_EVENT_CommandProgressing, fsmEvent);
}
/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent )
{
    RSYS_ASSERT(eventId < NUMBER_OF_INJECTABLE_EVENTS);

    // Reentrancy Protection is NOT intended to make thread-safe
    shared_ptr<QueuedFsmEvent>  qEvent(new QueuedFsmEvent(eventId, fsmEvent));
    mfsmEventQueue.push_back(qEvent);

    if(!mFsmInjectInProgress)
    {
        mFsmInjectInProgress = true;

        list< shared_ptr<QueuedFsmEvent> >::iterator event = mfsmEventQueue.begin();

        while( event != mfsmEventQueue.end() )
        {
            RSYS_ASSERT(*event);
            RSYS_ASSERT(mState);

            EventId queuedEventId = (*event)->mId;

            RSYS_ASSERT(queuedEventId < NUMBER_OF_INJECTABLE_EVENTS);

            if( !mState->DeferEvent( queuedEventId ) )
            {
                ++mEventCounter;

                if(mFsmTraceEnabled) { TRACE_PRINTF("%s.%u: %s <--(%s)-- ", mName.c_str(), mEventCounter, mState->mName.c_str(), mEventName[queuedEventId] ); }

                mState->Inject(queuedEventId, (*event)->mFsmEvent);

                while( !mState->RunToCompletion() )
                {
                    continue;
                }

                mfsmEventQueue.erase(event);
                event = mfsmEventQueue.begin();
            }
            else
            {
                if(mFsmTraceEnabled) { TRACE_PRINTF("%s.-: %s (%s deferred)", mName.c_str(), mState->mName.c_str(), mEventName[queuedEventId] ); };
                event++;
            }
        }

        mFsmInjectInProgress = false;
    }
    else
    {
        if(mFsmTraceEnabled) { TRACE_PRINTF("%s.-: (%s enqueued)", mName.c_str(), mEventName[eventId] ); }
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
const char * CommandLineFsm::mEventName[NUMBER_OF_INJECTABLE_EVENTS] =
{
    "Start",
    "Stop",
    "CommandLine",
    "Timeout",
    "CommandComplete",
    "CommandResponse",
    "CommandProgressing",
};

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::SimpleState::Inject(
    EventId eventId,
    shared_ptr<FsmEvent> fsmEvent
    )
{
    RSYS_ASSERT(eventId < NUMBER_OF_INJECTABLE_EVENTS);

    switch(eventId)
    {
        case CommandLineFsm::FSM_EVENT_Start:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_void_STAR_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_void_STAR_> event = dynamic_pointer_cast<FsmEvent_void_STAR_>(fsmEvent);
            InjectStart(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_Stop:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_shared_ptr_LT_std_COLON__COLON_string_GT_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_shared_ptr_LT_std_COLON__COLON_string_GT_> event = dynamic_pointer_cast<FsmEvent_shared_ptr_LT_std_COLON__COLON_string_GT_>(fsmEvent);
            InjectStop(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_CommandLine:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_shared_ptr_LT_CliCommand_GT_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_shared_ptr_LT_CliCommand_GT_> event = dynamic_pointer_cast<FsmEvent_shared_ptr_LT_CliCommand_GT_>(fsmEvent);
            InjectCommandLine(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_Timeout:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_void_STAR_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_void_STAR_> event = dynamic_pointer_cast<FsmEvent_void_STAR_>(fsmEvent);
            InjectTimeout(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_CommandComplete:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_shared_ptr_LT_CliExecuteCmdCnf_GT_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_shared_ptr_LT_CliExecuteCmdCnf_GT_> event = dynamic_pointer_cast<FsmEvent_shared_ptr_LT_CliExecuteCmdCnf_GT_>(fsmEvent);
            InjectCommandComplete(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_CommandResponse:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_shared_ptr_LT_CliExecuteCmdInd_GT_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_shared_ptr_LT_CliExecuteCmdInd_GT_> event = dynamic_pointer_cast<FsmEvent_shared_ptr_LT_CliExecuteCmdInd_GT_>(fsmEvent);
            InjectCommandResponse(event->mEvent);
        }
        break;

        case CommandLineFsm::FSM_EVENT_CommandProgressing:
        {
            RSYS_ASSERT(FSM_EVENT_TYPE_shared_ptr_LT_CliExecuteCmdProgressInd_GT_ == fsmEvent->mEventType);
            shared_ptr<FsmEvent_shared_ptr_LT_CliExecuteCmdProgressInd_GT_> event = dynamic_pointer_cast<FsmEvent_shared_ptr_LT_CliExecuteCmdProgressInd_GT_>(fsmEvent);
            InjectCommandProgressing(event->mEvent);
        }
        break;

        default:
            RSYS_ASSERT(false);
            break;
    }
}

// Event Start not handled in state AwaitCommand

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::AwaitCommand::InjectStop(
    shared_ptr<std::string> event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackStopReason" );

        mFsm.mInterface.FeedbackStopReason(event);

        mFsm.mQuitting.Entry();
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::AwaitCommand::InjectCommandLine(
    shared_ptr<CliCommand> event
    )
{
    // Guard condition
    if( mFsm.mInterface.QueryQuitCommanded(event))
    {
        mFsm.TracePoint( "QueryQuitCommanded? (true)" );

        mFsm.mState->Exit();
        mFsm.mState->Exit();
        mFsm.mQuitting.Entry();
    }
    else
    // Guard condition
    if( mFsm.mInterface.QueryCommandEmpty(event))
    {
        mFsm.TracePoint( "QueryCommandEmpty? (true)" );

        mFsm.mState->Exit();
        mFsm.mAwaitCommand.Entry();
    }
    else
    // Guard condition
    if( mFsm.mInterface.CommandLineParser(event))
    {
        mFsm.TracePoint( "CommandLineParser? (true)" );

        mFsm.mState->Exit();
        mFsm.TracePoint( "Action SendCommandReq" );

        mFsm.mInterface.SendCommandReq(event);

        mFsm.mCommandInProgress.Entry();
    }
    else
    {
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackCommandRejected" );

        mFsm.mInterface.FeedbackCommandRejected(event);

        mFsm.mAwaitCommand.Entry();
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::AwaitCommand::InjectTimeout(
    void* event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.mState->Exit();
        mFsm.mQuitting.Entry();
    }
}

// Event CommandComplete not handled in state AwaitCommand

// Event CommandResponse not handled in state AwaitCommand

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::AwaitCommand::InjectCommandProgressing(
    shared_ptr<CliExecuteCmdProgressInd> event
    )
{
    {
        mFsm.TracePoint( "Action FeedbackProgress" );

        mFsm.mInterface.FeedbackProgress(event);

    }
}

// State AwaitCommand has no deferred events.

// Event Start not handled in state CommandInProgress

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::CommandInProgress::InjectStop(
    shared_ptr<std::string> event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackStopReason" );

        mFsm.mInterface.FeedbackStopReason(event);

        mFsm.mQuitting.Entry();
    }
}

// Event CommandLine deferred in state CommandInProgress

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::CommandInProgress::InjectTimeout(
    void* event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackTimeout" );

        mFsm.mInterface.FeedbackTimeout(event);

        mFsm.mAwaitCommand.Entry();
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::CommandInProgress::InjectCommandComplete(
    shared_ptr<CliExecuteCmdCnf> event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackCompletionResult" );

        mFsm.mInterface.FeedbackCompletionResult(event);

        mFsm.mAwaitCommand.Entry();
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::CommandInProgress::InjectCommandResponse(
    shared_ptr<CliExecuteCmdInd> event
    )
{
    {
        mFsm.mState->Exit();
        mFsm.TracePoint( "Action FeedbackResponse" );

        mFsm.mInterface.FeedbackResponse(event);

        mFsm.mCommandInProgress.Entry();
    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
void CommandLineFsm::CommandInProgress::InjectCommandProgressing(
    shared_ptr<CliExecuteCmdProgressInd> event
    )
{
    {
        mFsm.TracePoint( "Action FeedbackProgress" );

        mFsm.mInterface.FeedbackProgress(event);

    }
}

/*** WARNING: Code AUTO-GENERATED from Cli.fsm. Do not edit! ***/
bool CommandLineFsm::CommandInProgress::DeferEvent( EventId eventId ) const
{
    switch( eventId )
    {
        case CommandLineFsm::FSM_EVENT_CommandLine:
            return true;


        default:
            return false;
    }
}

// Event Start not handled in state Quitting

// Event Stop not handled in state Quitting

// Event CommandLine not handled in state Quitting

// Event Timeout not handled in state Quitting

// Event CommandComplete not handled in state Quitting

// Event CommandResponse not handled in state Quitting

// Event CommandProgressing not handled in state Quitting

// State Quitting has no deferred events.


