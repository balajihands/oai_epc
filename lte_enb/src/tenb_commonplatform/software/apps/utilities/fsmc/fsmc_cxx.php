<?php



$source;
$header;
$interface;

$interfaceDefinition;

function GenerateCxx( )
{
	global $source, $header, $interface;

	// Write the output files...
	generateCpp( $source );
	generateFsmHpp( $header );
	generateInterface( $interface );
}


function writeCppIntro( &$cppFile )
{
  global $fsmFeatureList, $argv, $argv;

  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "//\n");
  fwrite( $cppFile, "//" . fsmDotCpp() . "\n");
  fwrite( $cppFile, "//\n");
  fwrite( $cppFile, "// Autogenerated from " . $argv[1] . "\n");
  fwrite( $cppFile, "//\n");
  fwrite( $cppFile, "// See header file for documentation.\n");
  fwrite( $cppFile, "//\n");
  fwrite( $cppFile, "// Copyright Radisys Limited\n");
  fwrite( $cppFile, "//\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "// System Includes\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "#include <stdio.h>\n");
  fwrite( $cppFile, "#include <stdlib.h>\n");
  fwrite( $cppFile, "#include <sstream>\n");
  fwrite( $cppFile, "#include <iostream>\n");
  fwrite( $cppFile, "#include <system/Trace.h>\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "// Local Includes\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "#include \"" . fsmDotH() . "\"\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "using namespace " . "std" . ";\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "// Static Data\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "// Constants\n");
  fwrite( $cppFile, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $cppFile, "\n");
}


function writeUsingNamespace($file)
{
  global $fsmFeatureList;

  $namespace = $fsmFeatureList["namespace"];

  if( $namespace )
  {
    fwrite( $file, "using namespace " . $namespace . ";\n");
    fwrite( $file, "\n");
  }
}

function writeNamespaceBegin($file)
{
  global $fsmFeatureList;

  $namespace = $fsmFeatureList["namespace"];

  if( $namespace )
  {
    fwrite( $file, "namespace " . $namespace . "\n");
    fwrite( $file, "{\n");
  }

  fwrite( $file, "\n");
}

function writeNamespaceEnd($file)
{
  global $fsmFeatureList;

  $namespace = $fsmFeatureList["namespace"];

  if( $namespace )
  {
    fwrite( $file, "} // -namespace-\n");
  }

  fwrite( $file, "\n");
}

function AddConstructionOfState ( $file, &$statesList, $state )
{
	if($statesList[$state] != "done")
	{
		//echo "AddConstructionOfState " . $state . "\n";

		$statesList[$state] = "done";

		global $fsmSuperstates;
		
		$superstate = $fsmSuperstates[$state];
		
		if( $superstate )
		{
			AddConstructionOfState ( $file, $statesList, $superstate );
		}
		
		fwrite( $file, "    m" . $state . "(*this ),\n");
	}
}


function writeFsmStateInitialiser( $file )
{
	global $fsmStates;

	$statesList = array();

	foreach( $fsmStates as $key => $state )
	{
		if($key)
		{
			$statesList[$key] = $key;
		}
	}

	foreach( $statesList as $key => $state )
	{
		AddConstructionOfState ( $file, $statesList, $state );
	}
}

function writeDoNotEditWarning($file)
{
	global $argv;
	
	fwrite( $file, "/*** WARNING: Code AUTO-GENERATED from " . $argv[1] . ". Do not edit! ***/\n");
}



function writeFsmConstructor($file)
{
	global $fsmStates, $fsmSuperstates, $fsmComponent, $fsmFeatureList;

	writeDoNotEditWarning($file);

	fwrite( $file, fsmClass() . "::" . fsmClass() . "(\n");
	fwrite( $file, "    " . fsmInterfaceClass() . " & interfaceClass,\n");
	fwrite( $file, "    bool traceEnabled,\n");
	fwrite( $file, "    const char * name \n");
	fwrite( $file, "    ) :\n");
	fwrite( $file, "    mInterface(interfaceClass),\n");
	fwrite( $file, "    mFsmTraceEnabled(traceEnabled),\n");
	fwrite( $file, "    mName(name),\n");
	fwrite( $file, "    mState(NULL),\n");

	writeFsmStateInitialiser( $file );

	fwrite( $file, "    mfsmEventQueue(),\n");
	fwrite( $file, "    mFsmInjectInProgress(false),\n");
	fwrite( $file, "    mEventCounter(0)\n");
	fwrite( $file, "{\n");

	$initial_state = $fsmFeatureList["initial_state"];

	if( $initial_state )
	{
		fwrite( $file, "    // Initial State\n");

	    $statesToEnter = stateNestedDepth( "", $initial_state );

	    while($statesToEnter-- > 0)
	    {
	      $entryStateName = ancestorStateName( $initial_state, $statesToEnter );
	
          fwrite( $file, "    m" . $entryStateName . ".Entry();\n");
	    }

          fwrite( $file, "\n");
          fwrite( $file, "    while( !mState->RunToCompletion() )\n");
          fwrite( $file, "    {\n");
          fwrite( $file, "        continue;\n");
          fwrite( $file, "    }\n");

	}
	else
	{
		error( "EOF", "No initial_state specified for FSM." );
	}

  fwrite( $file, "}\n");
  fwrite( $file, "\n");
}

function writeFsmDestructor($file)
{
  global $fsmStates;

  writeDoNotEditWarning($file);

  fwrite( $file, fsmClass() . "::~" . fsmClass() . "()\n");
  fwrite( $file, "{\n");

  fwrite( $file, "    RSYS_ASSERT_PRINTF(!mFsmInjectInProgress, \"" . fsmClass() . " deleted while event-inject in progress.\");\n");
  fwrite( $file, "\n");

  fwrite( $file, "    mfsmEventQueue.clear();\n");
  fwrite( $file, "    mCurrentStateTransitionExitsList.clear();\n");  
  fwrite( $file, "}\n");
  fwrite( $file, "\n");
}

function writeFsmInjectMethods( $file )
{
  global $fsmComponent;
  global $fsmEventTypes;

  foreach( $fsmComponent as $eventName => $type )
  {
    if($type == "event")
    {
      $eventType = $fsmEventTypes[$eventName];
      $typeToken = stringToToken($eventType);
      $fsmEventClass = "FsmEvent_" . $typeToken;

      writeDoNotEditWarning($file);
      
      fwrite( $file, "void " . fsmClass() . "::Inject" .$eventName . "(" . $eventType . " event)\n");
      fwrite( $file, "{\n");
      fwrite( $file, "    shared_ptr<FsmEvent> fsmEvent(new " . $fsmEventClass . "(event));\n");
      fwrite( $file, "    Enqueue( " . fsmClass() . "::FSM_EVENT_" . $eventName . ", fsmEvent);\n");
      fwrite( $file, "}\n");
    }
  }
}


function writeFsmEnqueueMethod( $file )
{
    writeDoNotEditWarning($file);

    fwrite( $file, "void " . fsmClass() . "::Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent )\n");
    fwrite( $file, "{\n");
    fwrite( $file, "    RSYS_ASSERT(eventId < NUMBER_OF_INJECTABLE_EVENTS);\n");
    fwrite( $file, "\n");
    fwrite( $file, "    // Reentrancy Protection is NOT intended to make thread-safe\n");
    fwrite( $file, "    shared_ptr<QueuedFsmEvent>  qEvent(new QueuedFsmEvent(eventId, fsmEvent));\n");
    fwrite( $file, "    mfsmEventQueue.push_back(qEvent);\n");
    fwrite( $file, "\n");
    fwrite( $file, "    if(!mFsmInjectInProgress)\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "        mFsmInjectInProgress = true;\n");
    fwrite( $file, "\n");
    fwrite( $file, "        list< shared_ptr<QueuedFsmEvent> >::iterator event = mfsmEventQueue.begin();\n");
    fwrite( $file, "\n");
    fwrite( $file, "        while( event != mfsmEventQueue.end() )\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            RSYS_ASSERT(*event);\n");
    fwrite( $file, "            RSYS_ASSERT(mState);\n");
    fwrite( $file, "\n");
    fwrite( $file, "            EventId queuedEventId = (*event)->mId;\n");
    fwrite( $file, "\n");
    fwrite( $file, "            RSYS_ASSERT(queuedEventId < NUMBER_OF_INJECTABLE_EVENTS);\n");
    fwrite( $file, "\n");
    fwrite( $file, "            if( !mState->DeferEvent( queuedEventId ) )\n");
    fwrite( $file, "            {\n");
    fwrite( $file, "                ++mEventCounter;\n");
    fwrite( $file, "\n");
    fwrite( $file, "                if(mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s <--(%s)-- \", mName.c_str(), mEventCounter, mState->mName.c_str(), mEventName[queuedEventId] ); }\n");
    fwrite( $file, "\n");
    fwrite( $file, "                mState->Inject(queuedEventId, (*event)->mFsmEvent);\n");
    fwrite( $file, "\n");
    fwrite( $file, "                while( !mState->RunToCompletion() )\n");
    fwrite( $file, "                {\n");
    fwrite( $file, "                    continue;\n");
    fwrite( $file, "                }\n");
    fwrite( $file, "\n");
    fwrite( $file, "                mfsmEventQueue.erase(event);\n");
    fwrite( $file, "                event = mfsmEventQueue.begin();\n");
    fwrite( $file, "            }\n");
    fwrite( $file, "            else\n");
    fwrite( $file, "            {\n");
    fwrite( $file, "                if(mFsmTraceEnabled) { TRACE_PRINTF(\"%s.-: %s (%s deferred)\", mName.c_str(), mState->mName.c_str(), mEventName[queuedEventId] ); };\n");
    fwrite( $file, "                event++;\n");
    fwrite( $file, "            }\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "\n");        
    fwrite( $file, "        mFsmInjectInProgress = false;\n");
    fwrite( $file, "    }\n");
    fwrite( $file, "    else\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "        if(mFsmTraceEnabled) { TRACE_PRINTF(\"%s.-: (%s enqueued)\", mName.c_str(), mEventName[eventId] ); }\n");
    fwrite( $file, "    }\n");
    fwrite( $file, "}\n" );
    fwrite( $file, "\n");        
        
}

function writeFsmMethodEventName( $file )
{
    global $fsmComponent;

    writeDoNotEditWarning($file);

    fwrite( $file, "const char * " . fsmClass() . "::mEventName[NUMBER_OF_INJECTABLE_EVENTS] =\n");
    fwrite( $file, "{\n");

    foreach( $fsmComponent as $event => $type )
    {
        if($type == "event")
        {
            fwrite( $file, "    \"" . $event . "\",\n");
        }
    }
    fwrite( $file, "};\n");
    fwrite( $file, "\n");
}


function writeMethodInjectEvent($file)
{
  global $fsmComponent, $fsmEventTypes;

  writeDoNotEditWarning($file);

  fwrite( $file, "void " . fsmClass() . "::SimpleState::Inject(\n");
  fwrite( $file, "    EventId eventId,\n");
  fwrite( $file, "    shared_ptr<FsmEvent> fsmEvent\n");
  fwrite( $file, "    )\n");
  fwrite( $file, "{\n");
  fwrite( $file, "    RSYS_ASSERT(eventId < NUMBER_OF_INJECTABLE_EVENTS);\n");
  fwrite( $file, "\n");
  fwrite( $file, "    switch(eventId)\n");
  fwrite( $file, "    {\n");

  foreach( $fsmComponent as $event => $typeOfComponent )
  {
    if($typeOfComponent == "event")
    {
      $c_type = $fsmEventTypes[$event];
      $c_typeToken = stringToToken($c_type);
      $fsmEventClass = "FsmEvent_" . $c_typeToken;
      $fsmTypeEnum = "FSM_EVENT_TYPE_" . $c_typeToken;

      fwrite( $file, "        case " . fsmClass() . "::FSM_EVENT_" . $event . ":\n");
      fwrite( $file, "        {\n");
      fwrite( $file, "            RSYS_ASSERT(". $fsmTypeEnum . " == fsmEvent->mEventType);\n");
      
      fwrite( $file, "            shared_ptr<" . $fsmEventClass . "> event = dynamic_pointer_cast<" . $fsmEventClass . ">(fsmEvent);\n");



      fwrite( $file, "            Inject" . $event . "(event->mEvent);\n");
      fwrite( $file, "        }\n");
      fwrite( $file, "        break;\n");
      fwrite( $file, "\n");
    }
  }
  fwrite( $file, "        default:\n");
  fwrite( $file, "            RSYS_ASSERT(false);\n");
  fwrite( $file, "            break;\n");
  fwrite( $file, "    }\n");
  fwrite( $file, "}\n");
  fwrite( $file, "\n");
}


function getStateThatHandlesEvent( &$state, $eventName )
{
	if($state->_name)
	{
		if(!$state->_eventList[$eventName])
		{
			return getAncestorStateThatHandlesEvent( $state, $eventName );
		}
	}

	return $state;
}

function getAncestorStateThatHandlesEvent( &$state, $eventName )
{
	global $fsmSuperstates;

  	$superstateName = $fsmSuperstates[$state->_name];

	$superstate = getStateFromName($superstateName);

	return getStateThatHandlesEvent( $superstate, $eventName );
}


function writeStateEventGuardConditionsCode( $file, &$state, &$reaction )
{
  // State is the actual state within which to handle event
  // Reaction may be inherited from super-state 

	if($reaction->_guard_condition)
	{
		fwrite( $file, "    // Guard condition\n");
		fwrite( $file, "    if( mFsm.mInterface." . $reaction->_guard_condition . "(event))\n");
		fwrite( $file, "    {\n");
		fwrite( $file, "        mFsm.TracePoint( \"" . $reaction->_guard_condition . "? (true)\" );\n");
		fwrite( $file, "\n");
	}
	else
	{
		fwrite( $file, "    {\n");
	}

	writeStateExit( $file, $state, $reaction, "        " );

	$numberOfActions = count($reaction->_action);
  
	if( $numberOfActions > 0)
	{
	    global $fsmActionResults;
	  
		foreach($reaction->_action as $actionIdx => $action )
		{
			fwrite( $file, "        mFsm.TracePoint( \"Action " . $action->_name . "\" );\n");
			fwrite( $file, "\n");
	
			if( count($fsmActionResults[$action->_name]) > 1 )
			{
				fwrite( $file, "        switch( mFsm.mInterface." . $action->_name . "(event))\n");
				fwrite( $file, "        {\n");
	
				fwrite( $file, "            case " . fsmClass() . "Action" . $action->_name . "::FSM_ACTION_SUCCESS:\n");
				fwrite( $file, "            {\n");
				fwrite( $file, "                mFsm.TracePoint( \"" . $action->_name . "=SUCCESS\" );\n");

				if( ($actionIdx + 1) == $numberOfActions )
				{
					fwrite( $file, "\n");
					writeStateTransitionAfterAction(  $file, $state, $reaction, $action, "SUCCESS", "                " );
				}
	
				fwrite( $file, "            }\n");
				fwrite( $file, "            break;\n");
				
				foreach( $action->_faultList as $fault => $nextState )
				{
				    fwrite( $file, "\n");
					fwrite( $file, "            case " . fsmClass() . "Action" . $action->_name . "::FSM_ACTION_" . $fault . ":\n");
					fwrite( $file, "            {\n");
					fwrite( $file, "                mFsm.TracePoint( \"" . $action->_name . "=" . $fault . "\" );\n");
					fwrite( $file, "\n");
	
					writeStateTransitionAfterAction(  $file, $state, $reaction, $action, $fault, "                " );
	
					fwrite( $file, "            }\n");
					fwrite( $file, "            return;\n");
				}
				fwrite( $file, "        }\n");
				fwrite( $file, "\n");
			}
			else
			{
				fwrite( $file, "        mFsm.mInterface." . $action->_name . "(event);\n");
				fwrite( $file, "\n");
	
				if( ($actionIdx + 1) == $numberOfActions )
				{
					writeStateTransitionAfterAction(  $file, $state, $reaction, $action, "SUCCESS", "        " );
				}
			}
		}
	}
	else
	{
		writeStateEntry( $file, $state, $reaction, "        " );
	}  

	fwrite( $file, "    }\n");
}

function writePseudoStateGuardConditionsCode( $file, &$state, &$reaction, $indentation )
{
  if($reaction->_guard_condition)
  {
    fwrite( $file, $indentation . "// Guard condition\n");
    fwrite( $file, $indentation . "if( mFsm.mInterface." . $reaction->_guard_condition . "())\n");
    fwrite( $file, $indentation . "{\n");
    fwrite( $file, $indentation . "    mFsm.TracePoint( \"" . $reaction->_guard_condition . "? (true)\" );\n");
    fwrite( $file, "\n");
  }
  else
  {
    fwrite( $file, $indentation . "{\n");
  }

  	writeStateExit( $file, $state, $reaction, $indentation . "    " );
  
	$numberOfActions = count($reaction->_action);
  
	if( $numberOfActions > 0)
	{
	    global $fsmActionResults;
	  
		foreach($reaction->_action as $actionIdx => $action )
		{
			fwrite( $file, $indentation . "    mFsm.TracePoint( \"Action " . $action->_name . "\" );\n");
			fwrite( $file, "\n");
	
			if( count($fsmActionResults[$action->_name]) > 1 )
			{
				error("eof", "e0536 Junction " . $state->_name . " containes actions that can fail for event " . $reaction->_eventName . ", which is not allowed.");
			}
			else
			{
				fwrite( $file, $indentation . "    mFsm.mInterface." . $action->_name . "();\n");
				fwrite( $file, "\n");
	
				if( ($actionIdx + 1) == $numberOfActions )
				{
					writeStateTransitionAfterAction(  $file, $state, $reaction, $action, "SUCCESS", $indentation . "    "  );
				}
			}
		}
	}
	else
	{
		writeStateEntry( $file, $state, $reaction, $indentation . "    " );
	}  
  
	fwrite( $file, $indentation . "}\n");
}

function  writeStateEventGuardConditions( $file, &$state, $eventName )
{
	$baseClassToConsumeEvent = false;
	
    $handlerState = getStateThatHandlesEvent( $state, $eventName );

    if( $handlerState->_eventList[$eventName]->_defer )
    {
	      fwrite( $file, "    // -Deferred-\n");
    }
    else
    {
	  while( $handlerState->_name && !$handlerState->_eventList[$eventName]->_unConditionalParsed )
	  {

	    foreach( $handlerState->_eventList[$eventName]->_reaction as $idx => $reaction )
	    {
	      writeStateEventGuardConditionsCode( $file, $state, $reaction );
	      fwrite( $file, "    else\n");
	
	    }
	    $handlerState = getAncestorStateThatHandlesEvent( $handlerState, $eventName );
	  }
	
	  if( $handlerState->_name )
	  {
		  if(!$handlerState->_eventList[$eventName]->_unConditionalParsed)
		  {
			$baseClassToConsumeEvent = true;
		  }

		  foreach( $handlerState->_eventList[$eventName]->_reaction as $idx => $reaction )
		  {
		    writeStateEventGuardConditionsCode( $file, $state, $reaction );
		
		    if($reaction->_guard_condition)
		    {
		      fwrite( $file, "    else\n");
		    }
		  }
	  }
	  else
	  {
	  	$baseClassToConsumeEvent = true;
	  }

	  if($baseClassToConsumeEvent)
	  {
	      fwrite( $file, "    {\n");
	      fwrite( $file, "        SimpleState::Inject" . $eventName . "(event);\n");
	      fwrite( $file, "    }\n");
	  }
    }
}

function  writeJunctionGuardConditions( $file, &$state )
{
    $eventName = "*";

    writePseudoStateGuardConditions( $file, $state, $eventName, "    "  );
}

function  writePseudoStateGuardConditions( $file, &$state, $eventName, $indentation  )
{
    foreach( $state->_eventList[$eventName]->_reaction as $idx => $reaction )
    {
        writePseudoStateGuardConditionsCode( $file, $state, $reaction, $indentation );

        if($reaction->_guard_condition)
        {
           fwrite( $file, $indentation . "else\n");
        }
    }
}


function writeStateEventMethods( $file, &$state)
{
	global $fsmComponent, $fsmEventTypes;

	foreach( $fsmComponent as $eventName => $componentType )
	{
		if($componentType == "event")
		{
			$handlerState = getStateThatHandlesEvent( $state, $eventName );

			if($handlerState->_name)
			{
			    if( !stateDefersThisEvent($state, $eventName) )
			    {
					$c_type = $fsmEventTypes[$eventName];
					$c_typeToken = stringToToken($c_type);
					$fsmEventClass = "FsmEvent_" . $c_typeToken;
					$fsmTypeEnum = "FSM_EVENT_TYPE_" . $c_typeToken;
		
					writeDoNotEditWarning($file);
		  
					fwrite( $file, "void " . fsmClass() . "::" . $state->_name . "::Inject" . $eventName . "(\n");
					fwrite( $file, "    " . $c_type . " event\n");
					fwrite( $file, "    )\n");
					fwrite( $file, "{\n");
					writeStateEventGuardConditions( $file, $state, $eventName );
					fwrite( $file, "}\n");
					fwrite( $file, "\n");
				}
				else
	  			{
					fwrite( $file, "// Event " . $eventName . " deferred in state " . $state->_name . "\n\n");
				}
			}
			else
  			{
				fwrite( $file, "// Event " . $eventName . " not handled in state " . $state->_name . "\n\n");
			}
		}
	}
}


function stateDefersThisEvent( $state, $eventName )
{
	$theEventIsDeferred = false;
	
    $handlerState = getStateThatHandlesEvent( $state, $eventName );

    if( $handlerState->_name && $handlerState->_eventList[$eventName]->_defer )
    {
    	$theEventIsDeferred = true;
    }

	return $theEventIsDeferred;
}

function writeStateDeferEvent( $file, &$state, $eventName )
{
    $handlerState = getStateThatHandlesEvent( $state, $eventName );

    if( $handlerState->_eventList[$eventName]->_defer )
    {
        fwrite( $file, "        case " . fsmClass() . "::FSM_EVENT_" . $eventName . ":\n");
        fwrite( $file, "            return true;\n");
        fwrite( $file, "\n");
    }

}


function stateDefersOneOrMoreEvents(&$state)
{
    global $fsmComponent;
    
	foreach( $fsmComponent as $eventName => $type )
	{
		if($type == "event")
		{
			if( stateDefersThisEvent( $state, $eventName ) )
			{
				return true;
			}
		}
	}
	
	return false;
}

function writeStateDeferEventMethod( $file, &$state)
{
    if( stateDefersOneOrMoreEvents($state) )
    {
		global $fsmComponent;
    
		writeDoNotEditWarning($file);
		
		fwrite( $file, "bool " . fsmClass() . "::" . $state->_name . "::DeferEvent( EventId eventId ) const\n");
		fwrite( $file, "{\n");
		fwrite( $file, "    switch( eventId )\n");
		fwrite( $file, "    {\n");

		foreach( $fsmComponent as $eventName => $type )
		{
		  if($type == "event")
		  {
		    writeStateDeferEvent( $file, $state, $eventName );
		  }
		}
	    fwrite( $file, "\n");
	    fwrite( $file, "        default:\n");
	    fwrite( $file, "            return false;\n");
	    fwrite( $file, "    }\n");
	    fwrite( $file, "}\n");
	    fwrite( $file, "\n");
	}
	else
	{
		fwrite( $file, "// State " . $state->_name . " has no deferred events.\n\n");
	}
}


function writeJunctionEntryMethod( $file, &$state )
{
    writeDoNotEditWarning($file);
    
    fwrite( $file, "void " . fsmClass() . "::" . $state->_name . "::Entry( )\n");
    fwrite( $file, "{\n");

    $superstateName = getSuperstateName( $state->_name );

    if( $superstateName )
    {
        fwrite( $file, "    RSYS_ASSERT(mFsm.mState == &mFsm.m" . $superstateName . ");\n");
    }
    else
    {
        fwrite( $file, "    RSYS_ASSERT(mFsm.mState == NULL);\n");
    }
    fwrite( $file, "\n");

    fwrite( $file, "    if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (entry) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    
    if( $state->_featureList["entry"] )
    {
        fwrite( $file, "    mFsm.mInterface." . $state->_name . "Entry();\n");
        fwrite( $file, "\n");
    }

    fwrite( $file, "    mFsm.mState = &mFsm.m" . $state->_name . ";\n");
    fwrite( $file, "\n");

    writeJunctionGuardConditions( $file, $state );
    
    fwrite( $file, "}\n");
    fwrite( $file, "\n");
}

function writeExitPointEntryMethod( $file, &$state )
{
    writeDoNotEditWarning($file);
    
    fwrite( $file, "void " . fsmClass() . "::" . $state->_name . "::Entry( )\n");
    fwrite( $file, "{\n");

    $superstateName = getSuperstateName( $state->_name );

    if( $superstateName )
    {
        fwrite( $file, "    RSYS_ASSERT(mFsm.mState == &mFsm.m" . $superstateName . ");\n");
    }
    else
    {
        fwrite( $file, "    RSYS_ASSERT(mFsm.mState == NULL);\n");
    }
    fwrite( $file, "\n");

    fwrite( $file, "    if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (entry) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    
    fwrite( $file, "    mFsm.mState = &mFsm.m" . $state->_name . ";\n");
    fwrite( $file, "\n");

    writeJunctionGuardConditions( $file, $state );
    
    fwrite( $file, "}\n");
    fwrite( $file, "\n");
}

function writeStateMethods($file)
{
  global $fsmComponent;

  foreach( $fsmComponent as $stateName => $type )
  {
    if($type == "state")
    {
      $state = getStateFromName($stateName);

      writeStateEventMethods( $file, $state);

      writeStateDeferEventMethod( $file, $state); 
    }
  }
}


function writeSuperstateMethods($file)
{
	// All done in bass classes
}

function writeJunctionMethods($file)
{
  global $fsmComponent;

  foreach( $fsmComponent as $junctionName => $type )
  {
    if($type == "junction")
    {
      $state = getStateFromName($junctionName);

      if($state->_status == "defined")
      {
        writeJunctionEntryMethod( $file, $state);
      } 
    }
  }
}

function writeExitPointMethods($file)
{
  global $fsmComponent;

  foreach( $fsmComponent as $exitPointName => $type )
  {
    if($type == "exit_point")
    {
      $state = getStateFromName($exitPointName);

      if($state->_status == "defined")
      {
        writeExitPointEntryMethod( $file, $state);
      } 
    }
  }
}


function generateCpp( $source )
{
  writeCppIntro($source);

  writeUsingNamespace($source);
  
  writeNamespaceBegin($source);

  writeFsmConstructor($source);

  writeFsmDestructor($source);

  writeFsmInjectMethods($source);

  writeFsmEnqueueMethod( $source );

  writeFsmMethodEventName($source);

  writeMethodInjectEvent($source);

  writeStateMethods($source);

  writeSuperstateMethods($source);

  writeJunctionMethods($source);
  
  writeExitPointMethods($source);
  
  writeNamespaceEnd($source);
}



function writeHppIntro( $file )
{
  global $fsmComponent, $fsmFeatureList, $argv, $argv;

  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// " .  fsmDotH() . "\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// Autogenerated from " . $argv[1] . "\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// See header file for documentation.\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// Copyright Radisys Limited\n");
  fwrite( $file, "//\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");
  fwrite( $file, "#ifndef __" . $fsmFeatureList["basename"] . "_fsm_h_\n");
  fwrite( $file, "#define __" . $fsmFeatureList["basename"] . "_fsm_h_\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "// System Includes\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");
  fwrite( $file, "#include <list>\n");
  fwrite( $file, "#include <deque>\n");
  fwrite( $file, "#include <system/Trace.h>\n");
  fwrite( $file, "\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "// Local Includes\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");
  fwrite( $file, "#include \"" . interfaceDotH() . "\"\n");
  fwrite( $file, "\n");
  writeUsingNamespace( $file);
  writeNamespaceBegin( $file);

}

function writeHppFooter( $file )
{
  global $fsmFeatureList;

  writeNamespaceEnd( $file);
  fwrite( $file, "#endif // __" . $fsmFeatureList["basename"] . "_fsm_interface_h_\n");
  fwrite( $file, "\n");
}

function writeHppInjectMethods( $file )
{
  global $fsmComponent, $fsmEventTypes;

  foreach( $fsmComponent as $eventName => $type )
  {
    if($type == "event")
    {
      $eventType = $fsmEventTypes[$eventName];
    
      fwrite( $file, "    void Inject" . $eventName . "(". $eventType . " event);\n");
    }
  }
}

function writeHppEnqueueMethod( $file )
{
    fwrite( $file, "    void Enqueue( EventId eventId, shared_ptr<FsmEvent> fsmEvent );\n\n");
}

function writeHppToStringMethod( $file )
{
    fwrite( $file, "    std::string ToString() const\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "        std::string returnedString(mName);\n");
    fwrite( $file, "\n");
    fwrite( $file, "        if(mState)\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            returnedString += \".\";\n");
    fwrite( $file, "            returnedString += mState->mName;\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "\n");
    fwrite( $file, "        return returnedString;\n");
    fwrite( $file, "    }\n");
    fwrite( $file, "\n");
}

function writeHppRenameMethod( $file )
{
    fwrite( $file, "    void Rename( const std::string & newName)\n");
    fwrite( $file, "    {\n");
	fwrite( $file, "        if(mFsmTraceEnabled)\n");
	fwrite( $file, "        {\n");
	fwrite( $file, "        	TRACE_PRINTF(\"%s.-: Renamed to %s\", mName.c_str(), newName.c_str() );\n");
	fwrite( $file, "        }\n");
    fwrite( $file, "        mName = newName;\n");
    fwrite( $file, "    }\n");
    fwrite( $file, "\n");
}

function writeHppTraceEnable( $file )
{
    fwrite( $file, "    void SetFsmTraceEnable( bool traceEnable = true ) { mFsmTraceEnabled = traceEnable; }\n");
    fwrite( $file, "\n");        
}

function writeHppTraceMethod( $file )
{
	fwrite( $file, "    void TracePoint( const char * s )\n");
	fwrite( $file, "    {\n");
	fwrite( $file, "        if(mFsmTraceEnabled)\n");
	fwrite( $file, "        {\n");
	fwrite( $file, "        	TRACE_PRINTF(\"%s.%u: %s\", mName.c_str(), mEventCounter, s );\n");
	fwrite( $file, "        }\n");
	fwrite( $file, "    }\n");
	fwrite( $file, "\n");        
}


function writeHppEventIdEnum( $file )
{
    global $fsmComponent;

    fwrite( $file, "    typedef enum EventId_tag\n");
    fwrite( $file, "    {\n");

    foreach( $fsmComponent as $event => $type )
    {
        if($type == "event")
        {
            fwrite( $file, "        FSM_EVENT_" . $event . ",\n");
        }
    }

    fwrite( $file, "        NUMBER_OF_INJECTABLE_EVENTS\n");
    fwrite( $file, "    } EventId;\n");
    fwrite( $file, "\n");        
}

function writeHppEventTypeEnum( $file )
{
    global $fsmComponent;

    fwrite( $file, "    typedef enum EventType_tag\n");
    fwrite( $file, "    {\n");

    foreach( $fsmComponent as $type => $component )
    {
        if($component == "type")
        {
            fwrite( $file, "        FSM_EVENT_TYPE_" . stringToToken($type) . ",\n");
        }
    }

    fwrite( $file, "        NUMBER_OF_EVENT_TYPES\n");
    fwrite( $file, "    } EventType;\n");
    fwrite( $file, "\n");        
}

function writeHppFsmEventClasses( $file )
{
    global $fsmComponent;

    fwrite( $file, "    class FsmEvent\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        FsmEvent( EventType eventType ) :\n");
    fwrite( $file, "            mEventType(eventType) {}\n");
    fwrite( $file, "        virtual ~FsmEvent(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        EventType mEventType;\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");

    foreach( $fsmComponent as $type => $component )
    {
        if($component == "type")
        {
            $className = "FsmEvent_" . stringToToken($type);
            
		    fwrite( $file, "    class " . $className . " : public FsmEvent\n");
		    fwrite( $file, "    {\n");
		    fwrite( $file, "    public:\n");
		    fwrite( $file, "        " . $className . "( " . $type . " event ) :\n");
		    fwrite( $file, "            FsmEvent(FSM_EVENT_TYPE_" . stringToToken($type) . "),\n");
		    fwrite( $file, "            mEvent(event) {}\n");
		    fwrite( $file, "        ~" . $className . "() {}\n");
	    	fwrite( $file, "    	" . $type . " mEvent;\n");
    		fwrite( $file, "    };\n");
		    fwrite( $file, "\n");
        }
    }
}


function writeHppStateHistoryType( $file )
{
    fwrite( $file, "    class State;\n");
    fwrite( $file, "    typedef std::deque< State * > StateHistory;\n\n");
}

function writeHppStateBaseClass( $file )
{
    global $fsmComponent, $fsmEventTypes;

    fwrite( $file, "    class State\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        State(" . fsmClass() . " & fsm, const char * name ) :\n");
    fwrite( $file, "            mFsm(fsm),\n");
    fwrite( $file, "            mName(name){}\n");
    fwrite( $file, "        virtual ~State(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        virtual void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData ) { RSYS_ASSERT_PRINTF(false,\"Cannot inject in state %s.\", mName.c_str()); }\n");
    fwrite( $file, "        virtual bool RunToCompletion() { RSYS_ASSERT_PRINTF(false,\"RunToCompletion failure in state %s.\", mName.c_str()); return false; };\n");
    fwrite( $file, "        virtual bool DeferEvent( EventId ) const { RSYS_ASSERT_PRINTF(false,\"Cannot defer in state %s.\", mName.c_str()); return false; }\n");
    fwrite( $file, "\n");
    fwrite( $file, "        virtual void Entry()\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            RSYS_ASSERT( mFsm.mState == GetSuperstate() );\n");
    fwrite( $file, "\n");
    fwrite( $file, "            UpdateHistoryUponEntry();\n");
    fwrite( $file, "\n");
    fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (entry) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    fwrite( $file, "            InterfaceEntryMethod();\n");
    fwrite( $file, "\n");
    fwrite( $file, "            mFsm.mState = this;\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "\n");
    fwrite( $file, "        virtual void Exit()\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            RSYS_ASSERT( mFsm.mState == this);\n");
    fwrite( $file, "\n");
    fwrite( $file, "            UpdateHistoryUponExit();\n");
    fwrite( $file, "\n");
    fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (exit) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    fwrite( $file, "            InterfaceExitMethod();\n");
    fwrite( $file, "\n");
    fwrite( $file, "            mFsm.mState =  GetSuperstate();\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "\n");
    fwrite( $file, "        " . fsmClass() . "& mFsm;\n");
    fwrite( $file, "        std::string mName;\n");
    fwrite( $file, "        virtual State * GetSuperstate() const { return NULL; }\n");
    fwrite( $file, "        virtual void  InterfaceEntryMethod() {}\n");
    fwrite( $file, "        virtual void  InterfaceExitMethod() {}\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponExit() { mFsm.mCurrentStateTransitionExitsList.push_front( mFsm.mState ); }\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponEntry() { mFsm.mCurrentStateTransitionExitsList.clear(); }\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}

function writeHppSimpleStateBaseClass( $file )
{
    global $fsmComponent, $fsmEventTypes;

    fwrite( $file, "    class SimpleState : public State\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        SimpleState(" . fsmClass() . " & fsm, const char * name) :\n");
    fwrite( $file, "            State(fsm, name){}\n");
    fwrite( $file, "        virtual ~SimpleState(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        void Inject( EventId eventId, shared_ptr<FsmEvent> fsmData );\n");
    fwrite( $file, "        virtual bool RunToCompletion() { return true; }\n");
    fwrite( $file, "\n");
    fwrite( $file, "        virtual bool DeferEvent( EventId ) const { return false; }\n");
    foreach( $fsmComponent as $event => $type )
    {
        if($type == "event")
        {
     	 	$eventType = $fsmEventTypes[$event];
            fwrite( $file, "        virtual void Inject" . $event . "( " . $eventType . " eventData) { EventConsumed(FSM_EVENT_" . $event . "); }\n");
        }
    }
    fwrite( $file, "\n");
    fwrite( $file, "    private:\n");
    fwrite( $file, "        void EventConsumed( EventId queuedEventId )\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s consumed %s\", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str(), mEventName[queuedEventId] ); }\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}

function writeHppSuperstateBaseClasses( $file )
{
    global $fsmComponent, $fsmEventTypes, $fsmSuperstates;

    fwrite( $file, "    class Superstate : public State\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        Superstate(" . fsmClass() . " & fsm, const char * name) :\n");
    fwrite( $file, "            State(fsm, name)\n");
    fwrite( $file, "        { }\n");
    fwrite( $file, "        virtual ~Superstate()\n");
    fwrite( $file, "        { }\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
    
    $superstateWithInitialState   = false;
    $superstateWithHistory        = false;
    $superstateWithShallowHistory = false;
    $superstateWithDeepHistory    = false;

    foreach( $fsmSuperstates as $stateName => $superStatename )
    {
    	$state = GetStateFromName( $superStatename );

        if($state->_eventList["initial_state"])
        {
        	$superstateWithInitialState = true;
        }
        
        if($state->_featureList["history"] == "deep")
        {
        	$superstateWithHistory     = true;
        	$superstateWithDeepHistory = true;
        }

        if($state->_featureList["history"] == "shallow")
        {
        	$superstateWithHistory        = true;
        	$superstateWithShallowHistory = true;
        }
    }
    
	fwrite( $file, "    class SuperstateWithInitialState : public Superstate\n");
	fwrite( $file, "    {\n");
	fwrite( $file, "    public:\n");
	fwrite( $file, "        SuperstateWithInitialState(" . fsmClass() . " & fsm, const char * name) :\n");
	fwrite( $file, "            Superstate(fsm, name) {}\n");
	fwrite( $file, "        virtual ~SuperstateWithInitialState() {}\n");
	fwrite( $file, "\n");
	fwrite( $file, "        virtual bool RunToCompletion() = 0;\n");
	fwrite( $file, "    };\n");
	fwrite( $file, "\n");
	
	if($superstateWithHistory)
	{
		fwrite( $file, "    class SuperstateWithHistory : public SuperstateWithInitialState\n");
		fwrite( $file, "    {\n");
		fwrite( $file, "    public:\n");
		fwrite( $file, "        SuperstateWithHistory(" . fsmClass() . " & fsm, const char * name) :\n");
		fwrite( $file, "            SuperstateWithInitialState(fsm, name) {}\n");
		fwrite( $file, "        virtual ~SuperstateWithHistory()\n");
		fwrite( $file, "        {\n");
		fwrite( $file, "            mHistory.clear();\n");
		fwrite( $file, "        }\n");
		fwrite( $file, "\n");
		fwrite( $file, "        virtual bool RunToCompletion()\n");
		fwrite( $file, "        {\n");
		fwrite( $file, "            RSYS_ASSERT(!mHistory.empty());\n");
		fwrite( $file, "\n");
		fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s RunToCompletion...\", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
		fwrite( $file, "\n");
		fwrite( $file, "            StateHistory::iterator historicState = mHistory.begin();\n");
		fwrite( $file, "\n");
		fwrite( $file, "            while(historicState != mHistory.end())\n");
		fwrite( $file, "            {\n");
		fwrite( $file, "                State    * subState = *historicState;\n");
		fwrite( $file, "\n");
		fwrite( $file, "                RSYS_ASSERT(subState);\n");
		fwrite( $file, "\n");
		fwrite( $file, "                subState->Entry();\n");
		fwrite( $file, "\n");
		fwrite( $file, "                ++historicState;\n");
		fwrite( $file, "            }\n");
		fwrite( $file, "\n");
		fwrite( $file, "            return false;\n");
		fwrite( $file, "        }\n");
		fwrite( $file, "\n");
		fwrite( $file, "        virtual void Exit()\n");
		fwrite( $file, "        {\n");
		fwrite( $file, "            RSYS_ASSERT(!mHistory.empty());\n");
		fwrite( $file, "\n");
		fwrite( $file, "            SuperstateWithInitialState::Exit();\n");
		fwrite( $file, "        }\n");
		fwrite( $file, "\n");
		fwrite( $file, "        StateHistory mHistory;\n");
	 	fwrite( $file, "    };\n");
		fwrite( $file, "\n");
	}
		
	if($superstateWithDeepHistory)
	{
		fwrite( $file, "    class SuperstateWithDeepHistory : public SuperstateWithHistory\n");
		fwrite( $file, "    {\n");
		fwrite( $file, "    public:\n");
		fwrite( $file, "        SuperstateWithDeepHistory(" . fsmClass() . " & fsm, const char * name) :\n");
		fwrite( $file, "            SuperstateWithHistory(fsm, name)\n");
		fwrite( $file, "        { }\n");
		fwrite( $file, "        virtual ~SuperstateWithDeepHistory()\n");
		fwrite( $file, "        { }\n");
		fwrite( $file, "\n");
		fwrite( $file, "        virtual void Exit()\n");
		fwrite( $file, "        {\n");
		fwrite( $file, "            RSYS_ASSERT( mFsm.mState == this);\n");
		fwrite( $file, "            RSYS_ASSERT( mFsm.mCurrentStateTransitionExitsList.size() > 0);\n");
		fwrite( $file, "\n");
		fwrite( $file, "            // Deep History\n");
		fwrite( $file, "            mHistory.clear();\n");
		fwrite( $file, "\n");
		fwrite( $file, "            std::string stateList;\n");
		fwrite( $file, "\n");
		fwrite( $file, "            for(StateHistory::reverse_iterator historicState = mFsm.mCurrentStateTransitionExitsList.rbegin();\n");
		fwrite( $file, "                historicState != mFsm.mCurrentStateTransitionExitsList.rend();\n");
		fwrite( $file, "                historicState++)\n");
		fwrite( $file, "            {\n");
		fwrite( $file, "                State * subState = *historicState;\n");
		fwrite( $file, "                RSYS_ASSERT(subState);\n");
		fwrite( $file, "\n");
		fwrite( $file, "                stateList += subState->mName;\n");
		fwrite( $file, "                stateList += \";\";\n");
		fwrite( $file, "                mHistory.push_front(subState);\n");
		fwrite( $file, "            }\n");
		fwrite( $file, "\n");
		fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: H^%zu=%s\", mFsm.mName.c_str(), mFsm.mEventCounter, mHistory.size(), stateList.c_str()  ); }\n");
		fwrite( $file, "\n");
		fwrite( $file, "            SuperstateWithHistory::Exit();\n");
		fwrite( $file, "        }\n");
	 	fwrite( $file, "    };\n");
		fwrite( $file, "\n");
	}

	if($superstateWithShallowHistory)
	{
		fwrite( $file, "    class SuperstateWithShallowHistory : public SuperstateWithHistory\n");
		fwrite( $file, "    {\n");
		fwrite( $file, "    public:\n");
		fwrite( $file, "        SuperstateWithShallowHistory(" . fsmClass() . " & fsm, const char * name) :\n");
		fwrite( $file, "            SuperstateWithHistory(fsm, name)\n");
		fwrite( $file, "        { }\n");
		fwrite( $file, "        virtual ~SuperstateWithShallowHistory()\n");
		fwrite( $file, "        { }\n");
		fwrite( $file, "\n");
		fwrite( $file, "        virtual void Exit()\n");
		fwrite( $file, "        {\n");
		fwrite( $file, "            RSYS_ASSERT( mFsm.mState == this);\n");
		fwrite( $file, "\n");
		fwrite( $file, "            StateHistory::iterator historicState = mFsm.mCurrentStateTransitionExitsList.begin();\n");
		fwrite( $file, "            RSYS_ASSERT(historicState != mFsm.mCurrentStateTransitionExitsList.end());\n");
		fwrite( $file, "            State * subState = *historicState;\n");
		fwrite( $file, "            RSYS_ASSERT(subState);\n");
        fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: H=%s\", mFsm.mName.c_str(), mFsm.mEventCounter,subState->mName.c_str() ); }\n");
		fwrite( $file, "\n");
		fwrite( $file, "            // Shallow History\n");
        fwrite( $file, "            mHistory.clear();\n");
        fwrite( $file, "            mHistory.push_front( subState );\n");
		fwrite( $file, "\n");
		fwrite( $file, "            SuperstateWithHistory::Exit();\n");
		fwrite( $file, "        }\n");
		fwrite( $file, "    };\n");
		fwrite( $file, "\n");
	}
}

function writeHppJunctionBaseClass( $file )
{
    global $fsmSuperstates, $fsmEventTypes;

    fwrite( $file, "    class Junction : public State\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        Junction(" . fsmClass() . " & fsm, const char * name) :\n");
    fwrite( $file, "            State(fsm, name) {}\n");
    fwrite( $file, "        virtual ~Junction(){}\n");
    fwrite( $file, "        virtual void Entry() = 0;\n");
    fwrite( $file, "        virtual void Exit()\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            RSYS_ASSERT( mFsm.mState == this);\n");
    fwrite( $file, "\n");
    fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (exit) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    fwrite( $file, "            InterfaceExitMethod();\n");
    fwrite( $file, "\n");
    fwrite( $file, "            mFsm.mState =  GetSuperstate();\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponExit() {}\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponEntry() {}\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");

}

function WriteHppExitPointBaseClass( $file )
{
    global $fsmSuperstates, $fsmEventTypes;

    fwrite( $file, "    class ExitPoint : public State\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        ExitPoint(" . fsmClass() . " & fsm, const char * name) :\n");
    fwrite( $file, "            State(fsm, name) {}\n");
    fwrite( $file, "        virtual ~ExitPoint(){}\n");
    fwrite( $file, "        virtual void Entry() = 0;\n");
    fwrite( $file, "        virtual void Exit()\n");
    fwrite( $file, "        {\n");
    fwrite( $file, "            RSYS_ASSERT( mFsm.mState == this);\n");
    fwrite( $file, "\n");
    fwrite( $file, "            if(mFsm.mFsmTraceEnabled) { TRACE_PRINTF(\"%s.%u: %s (exit) \", mFsm.mName.c_str(), mFsm.mEventCounter, mName.c_str() ); }\n");
    fwrite( $file, "\n");
    fwrite( $file, "            mFsm.mState =  GetSuperstate();\n");
    fwrite( $file, "        }\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponExit() {}\n");
    fwrite( $file, "        virtual void  UpdateHistoryUponEntry() {}\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
	}

function writeHppStateClass( $file, &$state )
{
    global $fsmComponent, $fsmEventTypes, $fsmSuperstates;

    fwrite( $file, "    class " . $state->_name . " : public SimpleState\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        " . $state->_name . "(" . fsmClass() . " & fsm) :\n");
    fwrite( $file, "            SimpleState(fsm, \"" . $state->_name . "\") {}\n");
    fwrite( $file, "        virtual ~" . $state->_name . "(){}\n");
    fwrite( $file, "\n");

    if( $state->_featureList["entry"] )
    {
        fwrite( $file, "        void InterfaceEntryMethod( void ) { mFsm.mInterface." . $state->_name . "Entry();}\n");
    }

    if( $state->_featureList["exit"] )
    {
        fwrite( $file, "        void InterfaceExitMethod( void ) {  mFsm.mInterface." . $state->_name . "Exit();}\n");
    }

	if( stateDefersOneOrMoreEvents($state) )
	{
	    fwrite( $file, "        bool DeferEvent( EventId ) const ;\n");
	}
    
	if($fsmSuperstates[$state->_name])
	{
		fwrite( $file, "        State * GetSuperstate() const { return &mFsm.m" . $fsmSuperstates[$state->_name] . "; }\n");
	}

    foreach( $fsmComponent as $eventName => $type )
    {
        if($type == "event")
        {
			$handlerState = getStateThatHandlesEvent( $state, $eventName );
			
			if($handlerState->_name)
			{
			    if( !stateDefersThisEvent($state, $eventName) )
			    {
		     	 	$eventType = $fsmEventTypes[$eventName];
    		        fwrite( $file, "        virtual void Inject" . $eventName . "( " . $eventType . " eventData);\n");
    		    }
    	    }
        }
    }
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}


function  writeInitialStateGuardConditions( $file, &$state )
{
	$eventName = "initial_state";
    writePseudoStateGuardConditions( $file, $state, $eventName, "            " );
	
	if(!$state->_eventList[$eventName]->_unConditionalParsed)
	{
		error( "EOF", "Initial_state ill formed for " . $state->_name );
	}
}


function writeHppSuperstateClass( $file, &$state )
{
    global $fsmComponent, $fsmSuperstates;
    
    $baseClass;
    
    if($state->_featureList["history"] == "deep")
    {
    	$baseClass = "SuperstateWithDeepHistory";
    }
    else if($state->_featureList["history"] == "shallow")
    {
    	$baseClass = "SuperstateWithShallowHistory";
    }
    else if($state->_eventList["initial_state"])
    {
    	$baseClass = "SuperstateWithInitialState";
    }
    else
    {
    	$baseClass = "Superstate";
    }

    fwrite( $file, "    class " . $state->_name . " : public " . $baseClass . "\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        " . $state->_name . "(" . fsmClass() . " & fsm) :\n");
    fwrite( $file, "            " . $baseClass . "(fsm, \"" . $state->_name . "\") {}\n");
    fwrite( $file, "        virtual ~" . $state->_name . "(){}\n");
    fwrite( $file, "\n");
    if( $state->_featureList["entry"] )
    {
        fwrite( $file, "    void InterfaceEntryMethod( void ) { mFsm.mInterface." . $state->_name . "Entry();}\n");
    }

    if( $state->_featureList["exit"] )
    {
        fwrite( $file, "    void InterfaceExitMethod( void ) { mFsm.mInterface." . $state->_name . "Exit();}\n");
    }
    fwrite( $file, "\n");        
    fwrite( $file, "    private:\n");

	switch( $baseClass )
	{
		case "SuperstateWithInitialState":
	        fwrite( $file, "        bool RunToCompletion( void )\n");
	        fwrite( $file, "        {\n");
	        writeInitialStateGuardConditions( $file, $state );
	        fwrite( $file, "\n");
	        fwrite( $file, "            return false;\n");
	        fwrite( $file, "        }\n");
	        break;
	        
	    case "SuperstateWithShallowHistory":
	    case "SuperstateWithDeepHistory":
	        fwrite( $file, "        bool RunToCompletion( void )\n");
	        fwrite( $file, "        {\n");
	        fwrite( $file, "            if(mHistory.empty())\n");
	        fwrite( $file, "            {\n");
	        writeInitialStateGuardConditions( $file, $state );
	        fwrite( $file, "            }\n");
	        fwrite( $file, "            else\n");
	        fwrite( $file, "            {\n");
	        fwrite( $file, "                return " . $baseClass . "::RunToCompletion();\n");
	        fwrite( $file, "            }\n");
	        fwrite( $file, "\n");
	        fwrite( $file, "            return false;\n");
	        fwrite( $file, "        }\n");
	        break;

		default:
		    break;
	}

	if($fsmSuperstates[$state->_name])
	{
		fwrite( $file, "        State * GetSuperstate() const { return &mFsm.m" . $fsmSuperstates[$state->_name] . "; }\n");
	}

    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}

function writeHppJunctionClass( $file, &$state )
{
    global $fsmComponent, $fsmSuperstates;

    fwrite( $file, "    class " . $state->_name . " : public Junction\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        " . $state->_name . "(" . fsmClass() . " & fsm) :\n");
    fwrite( $file, "            Junction(fsm, \"" . $state->_name . "\") {}\n");
    fwrite( $file, "        virtual ~" . $state->_name . "(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        void Entry(); \n");
    fwrite( $file, "\n");        
    fwrite( $file, "    private:\n");

	if($fsmSuperstates[$state->_name])
	{
		fwrite( $file, "        State * GetSuperstate() const { return &mFsm.m" . $fsmSuperstates[$state->_name] . "; }\n");
	}

    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}

function writeHppExitPointClass( $file, &$state )
{
    global $fsmComponent, $fsmSuperstates;

    fwrite( $file, "    class " . $state->_name . " : public ExitPoint\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        " . $state->_name . "(" . fsmClass() . " & fsm) :\n");
    fwrite( $file, "            ExitPoint(fsm, \"" . $state->_name . "\") {}\n");
    fwrite( $file, "        virtual ~" . $state->_name . "(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        void Entry(); \n");
    fwrite( $file, "\n");        
    fwrite( $file, "    private:\n");

	if($fsmSuperstates[$state->_name])
	{
		fwrite( $file, "        State * GetSuperstate() const { return &mFsm.m" . $fsmSuperstates[$state->_name] . "; }\n");
	}

    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}


function writeHppStateClasses( $file )
{
    global $fsmComponent;

    writeHppStateHistoryType( $file );

    writeHppStateBaseClass( $file );

	writeHppSimpleStateBaseClass( $file );

    foreach( $fsmComponent as $stateName => $type )
    {
        if($type == "state")
        {
            $state = getStateFromName($stateName);

            writeHppStateClass( $file, $state );
        }
    }
}

function writeHppSuperstateClasses( $file )
{
    global $fsmComponent;

    writeHppSuperstateBaseClasses( $file );

    foreach( $fsmComponent as $superstateName => $type )
    {
        if($type == "superstate")
        {
            $state = getStateFromName($superstateName);

            writeHppSuperstateClass( $file, $state );
        }
    }
}
   
function writeHppJunctionClasses( $file )
{
    global $fsmComponent;

    $baseClassWritten = false;
    
    foreach( $fsmComponent as $superstateName => $type )
    {
        if($type == "junction")
        {
        	if( $baseClassWritten == false )
        	{
               writeHppJunctionBaseClass( $file );
               
               $baseClassWritten = true;
         	}
        	
            $state = getStateFromName($superstateName);

            writeHppJunctionClass( $file, $state );
        }
    }
}

function writeHppExitPointClasses( $file )
{
    global $fsmComponent;

    $baseClassWritten = false;
    
    foreach( $fsmComponent as $superstateName => $type )
    {
        if($type == "exit_point")
        {
        	if( $baseClassWritten == false )
        	{
               WriteHppExitPointBaseClass( $file );
               
               $baseClassWritten = true;
         	}
        	
        	$state = getStateFromName($superstateName);

            writeHppExitPointClass( $file, $state );
        }
    }
}


   
function writeHppQueuedClass( $file )
{
    fwrite( $file, "    class QueuedFsmEvent\n");
    fwrite( $file, "    {\n");
    fwrite( $file, "    public:\n");
    fwrite( $file, "        QueuedFsmEvent( EventId eventId, shared_ptr<FsmEvent> fsmEvent) :\n");
    fwrite( $file, "            mId(eventId),\n");
    fwrite( $file, "            mFsmEvent(fsmEvent){}\n");
    fwrite( $file, "        ~QueuedFsmEvent(){}\n");
    fwrite( $file, "\n");
    fwrite( $file, "        EventId mId;\n");
    fwrite( $file, "        shared_ptr<FsmEvent> mFsmEvent;\n");
    fwrite( $file, "    };\n");
    fwrite( $file, "\n");
}

function AddStateMember ( $file, &$statesList, $state )
{
	if($statesList[$state] != "done")
	{
		$statesList[$state] = "done";

		global $fsmSuperstates;
		
		$superstate = $fsmSuperstates[$state];
		
		if($superstate) 
		{
			AddStateMember ( $file, $statesList, $superstate );
		}
		
        fwrite( $file, "    " . $state . " m" . $state . ";\n");
	}
}

function writeStateMembers($file)
{
    global $fsmStates, $fsmSuperstates;

	$statesList = array();;

	foreach( $fsmStates as $key => $state )
	{
		if($key)
		{
			$statesList[$key] = $key;
		}
	}

  	$superstates = $fsmSuperstates;
  
	foreach( $statesList as $key => $state )
	{
		AddStateMember ( $file, $statesList, $state );
	}
}

function writeHppClassMembers( $file )
{
    global $fsmComponent;


    fwrite( $file, "    " . fsmInterfaceClass() . " & mInterface;\n");
    fwrite( $file, "    bool mFsmTraceEnabled;\n");
    fwrite( $file, "    std::string mName;\n");
    fwrite( $file, "    State * mState;\n");

	writeStateMembers( $file );

    fwrite( $file, "    std::list< shared_ptr<QueuedFsmEvent> > mfsmEventQueue;\n");
    fwrite( $file, "    bool mFsmInjectInProgress;\n");
    fwrite( $file, "    unsigned mEventCounter;\n");
    fwrite( $file, "    StateHistory mCurrentStateTransitionExitsList;\n");
    
    fwrite( $file, "    static const char * mEventName[NUMBER_OF_INJECTABLE_EVENTS];\n");
    fwrite( $file, "\n");
}
    

function writeHppClass( $file )
{
    writeDoNotEditWarning($file);

    fwrite( $file, "class " . fsmClass() . "\n");
    fwrite( $file, "{\n");
    fwrite( $file, "public:\n");
    fwrite( $file, "\n");
    
    fwrite( $file, "    " . fsmClass() . "(\n");
    fwrite( $file, "        " . fsmInterfaceClass() . " & interfaceClass,\n");
    fwrite( $file, "        bool traceEnabled = false,\n");
    fwrite( $file, "        const char * name = \"" . fsmClass() . "\"\n");
    fwrite( $file, "        );\n");
    fwrite( $file, "    virtual ~" . fsmClass() . "();\n");
    fwrite( $file, "\n");


    writeHppInjectMethods( $file );

    writeHppToStringMethod( $file );

    writeHppRenameMethod( $file );

    writeHppTraceEnable( $file );

    writeHppTraceMethod( $file );
    
    fwrite( $file, "private:\n");

    writeHppEventIdEnum( $file );

    writeHppEventTypeEnum( $file );

    writeHppFsmEventClasses( $file );

    writeHppEnqueueMethod( $file );
    
    writeHppStateClasses( $file );

	writeHppSuperstateClasses( $file );
	
	writeHppJunctionClasses( $file );
	
	writeHppExitPointClasses( $file );
	
    writeHppQueuedClass( $file );

    writeHppClassMembers( $file );

    fwrite( $file, "};\n");
    fwrite( $file, "\n");
}


function generateFsmHpp( $file )
{
    writeHppIntro( $file );

    writeHppClass( $file );

    writeHppFooter( $file );

}



function writeInterfaceIntro( $file )
{
  global $fsmFeatureList, $fsmComponent, $argv, $argv;

  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// " . interfaceDotH() ."\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// Autogenerated from " . $argv[1] . "\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// Fsm Interface Class\n");
  fwrite( $file, "//\n");
  fwrite( $file, "// Copyright Radisys Limited\n");
  fwrite( $file, "//\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");
  fwrite( $file, "#ifndef __" . $fsmFeatureList["basename"] . "_fsm_interface_h_\n");
  fwrite( $file, "#define __" . $fsmFeatureList["basename"] . "_fsm_interface_h_\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "// System Includes\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");
  fwrite( $file, "#include <system/ThreadWithQueue.h>\n");
  fwrite( $file, "\n");
  

  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "// Local Includes\n");
  fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
  fwrite( $file, "\n");

	foreach( $fsmComponent as $component => $type )
	{
		if("type_header" == $type)
		{
			fwrite( $file, "#include \"" . $component . "\"\n");
		}
	}
	fwrite( $file, "\n");
	
	fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
	fwrite( $file, "// Defines\n");
	fwrite( $file, "///////////////////////////////////////////////////////////////////////////////\n");
	fwrite( $file, "\n");
	fwrite( $file, "// Definition at end of file\n");
	fwrite( $file, "#undef " . $fsmFeatureList["basename"] . "InterfaceDefinition\n");


	fwrite( $file, "\n");
  writeNamespaceBegin($file);
}

function writeInterfaceFooter( $file )
{
	global $fsmFeatureList, $interfaceDefinition;

	writeNamespaceEnd($file);

	fwrite( $file, "// Auto-updating Interface Definition\n");
	fwrite( $file, "#define " . $fsmFeatureList["basename"] . "InterfaceDefinition() " . $interfaceDefinition . "\n");
	fwrite( $file, "\n");
	
	fwrite( $file, "#endif // __" . $fsmFeatureList["basename"] . "_fsm_interface_h_\n");
	fwrite( $file, "\n");
}


function AddToInterfaceDefinition( $method )
{
	global $interfaceDefinition;
	
	if( $interfaceDefinition ) $interfaceDefinition .= ";";
	$interfaceDefinition .= " \\\n    " . $method;
}

function writeActionClassReturningOutcome( $file, $action )
{
  	global $fsmActionResults, $fsmOverloadableMethods;

	$class = fsmClass() . "Action" . $action;

	writeDoNotEditWarning($file);

  	fwrite( $file, "class " . $class . "\n");
  	fwrite( $file, "{\n");
  	fwrite( $file, "public:\n");
  	fwrite( $file, "    " . $class . "() {}\n");
  	fwrite( $file, "    virtual ~" . $class . "() {}\n");
  	fwrite( $file, "\n");

  	fwrite( $file, "    typedef enum Outcome_tag\n");
  	fwrite( $file, "    {\n");
  	foreach( $fsmActionResults[$action] as $failure => $stateName )
  	{
    	fwrite( $file, "        FSM_ACTION_" . $failure . ",\n");
  	}
  	fwrite( $file, "    } Outcome;\n");
  	fwrite( $file, "\n");


	foreach( $fsmOverloadableMethods[$action]->_cTypeList as $c_type => $idx )
	{
		$prototype1 = "virtual " .            "Outcome " . $action . "(" . $idx . ")";
		$prototype2 = "virtual " . $class . "::Outcome " . $action . "(" . $idx . ")";
		
		fwrite( $file, "    " . $prototype1 . " = 0;\n");
		AddToInterfaceDefinition( $prototype2 );
	}

	fwrite( $file, "};\n");
	fwrite( $file, "\n");
}

function writeInterfaceActionMethodReturningVoid( $file, $action )
{
  	global $fsmOverloadableMethods;

  	foreach( $fsmOverloadableMethods[$action]->_cTypeList as $c_type => $idx )
  	{
		$prototype = "virtual void " . $action . "(" . $idx . ")";

		fwrite( $file, "    " . $prototype . " = 0;\n");
		AddToInterfaceDefinition( $prototype );
  	}
}

function writeActionClassesReturningOutcome( $file )
{
  global $fsmComponent;
  global $fsmActionResults;

  foreach( $fsmComponent as $action => $type )
  {
    if($type == "action")
    {
      if( count($fsmActionResults[$action]) > 1 )
      {
        writeActionClassReturningOutcome( $file, $action );
      }
    }
  }
}

function writeInterfaceActionMethodsReturningVoid( $file )
{
  global $fsmComponent;
  global $fsmActionResults;

  foreach( $fsmComponent as $action => $type )
  {
    if($type == "action")
    {
      if( count($fsmActionResults[$action]) == 1 )
      {
        writeInterfaceActionMethodReturningVoid( $file, $action );
      }
    }
  }
}

function writeInterfaceClassInherits( $file )
{
	global $fsmActionResults;

	$first = true;
  
	foreach( $fsmActionResults as $action => $type )
	{
 		if( count($fsmActionResults[$action]) > 1 )
		{
			if($first)
			{
				fwrite( $file, " :\n");
				$first = false;
			}
 			else
			{
				fwrite( $file, ",\n");
			}

			fwrite( $file, "    public " . fsmClass() . "Action" . $action);
		}
	}

	fwrite( $file, "\n");
}

function writeInterfaceClassStateMethods( $file )
{
    global $fsmStates;

    foreach( $fsmStates as $stateName => $state )
    {
        if( $state->_featureList["entry"] )
        {
			$prototype = "virtual void " . $stateName . "Entry()";

			fwrite( $file, "    " . $prototype . " = 0;\n");
			AddToInterfaceDefinition( $prototype );
        }
        if( $state->_featureList["exit"] )
        {
			$prototype = "virtual void " . $stateName . "Exit()";

			fwrite( $file, "    " . $prototype . " = 0;\n");
			AddToInterfaceDefinition( $prototype );
        }
    }
}


function writeInterfaceGuardConditionMethods( $file )
{
    global $fsmComponent, $fsmOverloadableMethods;

    foreach( $fsmComponent as $guard_condition => $type )
    {
        if($type == "guard_condition")
        {
		  	foreach( $fsmOverloadableMethods[$guard_condition]->_cTypeList as $c_type => $idx )
  			{
  				$prototype = "virtual bool " . $guard_condition . "(" . $idx . ")";
  				
	            fwrite( $file, "    " . $prototype . " = 0;\n");
				AddToInterfaceDefinition( $prototype );
  			}
        }
    }
}


function writeInterfaceClass( $file )
{
	writeDoNotEditWarning($file);

    fwrite( $file, "class " . fsmInterfaceClass() );
    writeInterfaceClassInherits( $file );
    fwrite( $file, "{\n");
    fwrite( $file, "public:\n");
    fwrite( $file, "    " . fsmInterfaceClass() . "() {}\n");
    fwrite( $file, "    virtual ~" . fsmInterfaceClass() . "() {}\n");
    fwrite( $file, "    \n");
    fwrite( $file, "    // Actions\n");
	writeInterfaceActionMethodsReturningVoid( $file );
    fwrite( $file, "    \n");
    fwrite( $file, "    // Entry/Exit\n");
	writeInterfaceClassStateMethods( $file );
    fwrite( $file, "    \n");
    fwrite( $file, "    // Guard Conditions\n");
	writeInterfaceGuardConditionMethods( $file );
    fwrite( $file, "    \n");
    fwrite( $file, "};\n");

}

function generateInterface( $file )
{
	writeInterfaceIntro( $file );

	writeActionClassesReturningOutcome( $file );

	writeInterfaceClass( $file );

	writeInterfaceFooter( $file );
}


function parseFileStatementFsm( &$statement, &$featureList )
{
  addParameterisedFeature( $statement, $featureList );

}

function parseFileStatementBasename( &$statement, &$featureList )
{
  addParameterisedFeature( $statement, $featureList );

  global $source, $header, $interface, $argv;

  if(! $source = fopen( fsmDotCpp(), 'w' ))
  {
    die( "Cannot create file " . fsmDotCpp() );
  }

  if(! $header = fopen( fsmDotH(), 'w' ))
  {
    die( "Cannot create file " . fsmDotH() );
  }

  if(! $interface = fopen( interfaceDotH(), 'w' ))
  {
    die( "Cannot create file " . interfaceDotH() );
  }



  global $fsmFeatureList;

}

function fsmDotCpp ( )
{
  global $fsmFeatureList;

  return $fsmFeatureList["basename"] . "_fsm.cpp";
}

function fsmDotH ( )
{
  global $fsmFeatureList;

  return $fsmFeatureList["basename"] . "_fsm.h";
}

function interfaceDotH ( )
{
  global $fsmFeatureList;

  return $fsmFeatureList["basename"] . "_fsm_interface.h";
}

function fsmName()
{
  global $fsmFeatureList;

  return $fsmFeatureList["fsm"];
}

function fsmClass()
{
  return fsmName() . "Fsm" ;
}

function fsmInterfaceClass()
{
  return fsmName() . "FsmInterface" ;
}

?>
