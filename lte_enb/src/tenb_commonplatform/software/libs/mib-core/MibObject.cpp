///////////////////////////////////////////////////////////////////////////////
//
// MibObject.cpp
//
// See header file for documentation.
//
// Copyright radisys Limited
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// System Includes
///////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <sstream>
#include <algorithm> // find
#include <vector>

#include <system/Trace.h>
#include <mib-common/MibObjectDescriptors.h>

// Autogenerated headers.
#include <MibAttributes.h>

///////////////////////////////////////////////////////////////////////////////
// Local Includes
///////////////////////////////////////////////////////////////////////////////

#include "MibObject.h"
#include "MibAttribute.h"

using namespace std;
using namespace boost;

#define MIB_GERAN_MAX_INSTANCE 16
#define MIB_GERAN_INIT_VAL 1

vector<string> freqBandInd;
/* initialising with some random value */
vector<string> cellPlmnList (MIB_GERAN_MAX_INSTANCE, "MIB_GERAN_INIT_VAL");
vector<string> cellNccList (MIB_GERAN_MAX_INSTANCE, "MIB_GERAN_INIT_VAL");
vector<u32>    freqArfcn (MIB_GERAN_MAX_INSTANCE, MIB_GERAN_INIT_VAL);
vector<u32>    cellArfcn (MIB_GERAN_MAX_INSTANCE, MIB_GERAN_INIT_VAL);
vector<u32>    freqSrcLst;
vector<u32>    cellSrcLst;
vector<u32>    lteInterFreqSrcLst;

ValidArfcnRange arfcnRange[] =
           { {"GSM850",  { 128,251 }},
             {"GSM900",  { 124,975 }},
             {"DCS1800", { 512,885 }},
             {"PCS1900", { 512,810 }}
           };
                                                        
///////////////////////////////////////////////////////////////////////////////
// Class Functions
///////////////////////////////////////////////////////////////////////////////

bool MibObject::ValidateGeranArfcn(string bandInd,u32 arfcn)
{
  int size = sizeof(arfcnRange)/sizeof(ValidArfcnRange) ;
  for(int i = 0;i < size; i++)
  {
     if(arfcnRange[i].bandInd == bandInd)
     {      
        if((arfcn >= arfcnRange[i].range.min)&&
                          (arfcn <= arfcnRange[i].range.max))
        {
           return true;
        }
        break;
     }
  }
  return false;
}

NvContainerDescriptor MibObject::GetNvContainerDescriptor(const MibDN& dn)
{
   NvContainerName name = dn.ToString();
   u32 instance = dn.back().GetMibObjectInstance();

   //
   // This is a bit cludgy owing to old code not including any kind of hierarchical information
   // in the NV container name.  So at time of writing, existing containers were called "FAP",
   // "FACTORY" and "COMMISSIONING".  We'll keep these names but for all others we just derive
   // the container name from the DN.
   //
   // E.g.
   //
   // FAP.0                     > "FAP"       [ this actually follows the generic pattern ]
   // FAP.0.FACTORY.0           > "FACTORY"
   // FAP.0.COMMISSIONING.0     > "COMMISSIONING"
   // FAP.0.NC.2                > "FAP.0.NC"
   //

   if (name == "FAP.0.FACTORY.0")
   {
      name = "FACTORY";
   }
   else if (name == "FAP.0.COMMISSIONING.0")
   {
      name = "COMMISSIONING";
   }
   else if (name == "FAP.0.FAP_LTE.0")
   {
      name = "FAP_LTE";
   }
   else if (name == "FAP.0.FACTORY_LTE.0")
   {
      name = "FACTORY_LTE";
   }
   else if (name == "FAP.0.COMMISSIONING_LTE.0")
   {
      name = "COMMISSIONING_LTE";
   }
   else if (name == "FAP.0.TR196_CURRENT_ALARM.0")
   {
      name = "TR196_CURRENT_ALARM";
   }
   else if (name == "FAP.0.TR196_SUPPORTED_ALARM.0")
   {
      name = "TR196_SUPPORTED_ALARM";
   }
   else if (name == "FAP.0.TR196_EXPEDITED_EVENT.0")
   {
      name = "TR196_EXPEDITED_EVENT";
   }
   else
   {
      // Remove trailing ".N"
      name.resize(name.find_last_of('.'));
   }

   NvContainerDescriptor desc(name, instance);

   return desc;
}

MibObject::MibObject(const MibRDN& rdn,
      NonVolatileStoreInterface& nvStore,
      MibChangedAttributesNotifyInterface* changedAttributesNotifyInterface) :
   m_nvStore(nvStore),
   m_changedAttributesNotifyInterface(changedAttributesNotifyInterface),
   m_rdn(rdn),
   m_parentObject(NULL),
   m_moInitialised(false),
   m_attributesValid(false)
{
   ENTER();

   m_moDescriptor = getManagedObjectDescriptor(rdn.GetMibObjectClass());
   RSYS_ASSERT(m_moDescriptor != NULL);

   EXIT();
}

MibObject::~MibObject()
{
   ENTER();

   EXIT();
}

struct IdAndStorage
{
   MibAttributeId id;
   MibAttributeStorageClass mibStorageClass;
};


MibAttrValidationFailures MibObject::InitialiseMO(const MibAttributeValues& suppliedAttrValues)
{
   ENTER();

   RSYS_ASSERT_PRINTF(!m_moInitialised, "%s", m_rdn.ToString().c_str());

   // Work out and store the NV container descriptor.
   m_nvContainerDescriptor = GetNvContainerDescriptor(GetDN());

   // We are going to build up a set of attribute values to apply to this
   // new MO.  In order of preference (highest first) for each attribute
   // we take passed in value, NV value or default value.
   // Once we have the set we validate them, knock out the invalid ones
   // and raise an alarm or sumfin then apply the rest.
   MibAttributeValues fullSetMibAttributeValues;

   // Build up all those failures...
   MibAttrValidationFailures mibAttrValidationFailures;

   m_moInitialised = true;

   // Assume attributes are valid until we discover otherwise.
   m_attributesValid = true;

   // Build up a list of MOC attributes for use at end of object creation to check we have all the ones we need.
   vector<MibAttributeId> mocAttrIds;

   // Collate the attributeIds that we'll be initialising
   // Keep track of passed in IDs, tick them off and see if we have any left after checking against allowed IDs.
   MibAttributeIds suppliedIds = suppliedAttrValues.GetAttributeIds();

   std::vector<IdAndStorage> allowedIds;
   for (u32 i = 0; i < m_moDescriptor->validAttributeIdsNum; ++i)
   {
      IdAndStorage objectDescriptor;

      objectDescriptor.id = m_moDescriptor->validAttributeIds[i].mibAttributeId;
      objectDescriptor.mibStorageClass = m_moDescriptor->validAttributeIds[i].storageClass;
      allowedIds.push_back(objectDescriptor);

      // Knock off the allowed IDs.
      suppliedIds.erase(objectDescriptor.id);
   }

   // Check for remaining passed in IDs.
   for(MibAttributeIds::const_iterator iter = suppliedIds.begin(); iter != suppliedIds.end(); ++iter)
   {
      MibAttrValidationFailure failure(*iter);
      string desc = "Attribute ";
      desc += getMibAttributeName(*iter);
      desc += " not allowed on MO ";
      desc += GetDN().ToString();
      failure.Set(ValidationFailureDescriptor::CAUSE_NOT_ALLOWED_ON_OBJECT, desc);
      mibAttrValidationFailures.push_back(failure);
   }

   // Let's just have a single validation failure descriptor and reuse it in the following sections.
   MibAttrValidationFailure mibAttrValidationFailure;

   // Rattle through the attributes allowed on this object and set up defaults
   // and values from NV as appropriate.
   for (std::vector<IdAndStorage>::iterator moAttrIter = allowedIds.begin(); moAttrIter != allowedIds.end(); ++moAttrIter)
   {
      MibAttributeId attributeId = moAttrIter->id;
      RSYS_ASSERT(attributeId < NUM_MIB_ATTR_IDS);

      //
      // Get common attribute descriptors and any default.
      //
      const MibAttributeCommonDescriptor * commonAttrDesc = getMibAttributeCommonDesc(attributeId);
      shared_ptr<MibAttributeValue> defaultValue = GetDefaultValue(attributeId);

      //
      // Take value from passed in attributes by preference.
      //
      shared_ptr<MibAttributeValue> mibAttributeValue;
      MibAttributeValues::MibAttributeValuesById::const_iterator iter = suppliedAttrValues.GetAttributeValues().find(attributeId);
      if(iter != suppliedAttrValues.GetAttributeValues().end())
      {
         RSYS_ASSERT_PRINTF(iter->second != NULL, "%s %s", GetRDN().ToString().c_str(), getMibAttributeName(attributeId));
         if(ValidateValue(attributeId, iter->second, mibAttrValidationFailure))
         {
            mibAttributeValue = iter->second;
            TRACE_PRINTF_LEV(TRACE_VERBOSE, "InitialiseMO: %s initialising %s with supplied value %s",
                  GetRDN().ToString().c_str(),
                  getMibAttributeName(attributeId),
                  mibAttributeValue->ToString().c_str());
         }
         else
         {
            TRACE_PRINTF_LEV(TRACE_CRITICAL, "InitialiseMO: %s attr failure (supplied value): %s",
                  GetRDN().ToString().c_str(),
                  mibAttrValidationFailure.ToString().c_str());
            mibAttrValidationFailures.push_back(mibAttrValidationFailure);
         }

         ++iter;
      }

      //
      // Now try from NV if we didn't get a value from the supplied attributes.
      //

      if((mibAttributeValue == NULL) && (moAttrIter->mibStorageClass == MIB_STORAGE_NON_VOLATILE))
      {
         // Try to get from NV store.
         NvAttributeDescriptor nvAttrDesc;
         nvAttrDesc.m_nvAttributeInstance = 0;
         nvAttrDesc.m_nvAttributeName = commonAttrDesc->mibAttributeName;

         NvAttributeValue nvAttrValue;
         NvAttributeResult nvGetAttrResult = m_nvStore.GetNvAttribute(m_nvContainerDescriptor, nvAttrDesc, nvAttrValue);
         if(nvGetAttrResult == NV_ATTRIBUTE_RESULT_OK)
         {
            shared_ptr<MibAttributeValue> nvValue = MibAttributeValue::Create(mibAttributeCommonDescriptors[attributeId].mibAttributeType, nvAttrValue.GetAsString());

            if(ValidateValue(attributeId, nvValue, mibAttrValidationFailure))
            {
               mibAttributeValue = nvValue;
               TRACE_PRINTF_LEV(TRACE_VERBOSE, "InitialiseMO: %s initialising %s with NV value %s",
                     GetRDN().ToString().c_str(),
                     getMibAttributeName(attributeId),
                     mibAttributeValue->ToString().c_str());
            }
            else
            {
               TRACE_PRINTF_LEV(TRACE_CRITICAL, "InitialiseMO: %s attr failure (NV value): %s",
                     GetRDN().ToString().c_str(),
                     mibAttrValidationFailure.ToString().c_str());
               // Note: We used to add this failure to the list of failures but we no longer consider this
               // a failure because a) we assert on these failures at higher level and this could be due
               // to a corrupt/hand-edited(!) .nv file which is not a coding bug, b) most attributes have
               // defaults and we will pick up and use that below, c) if no default, the code must be able
               // to cope with no value present anyway.
            }
         }
      }

      //
      // And finally try default value.
      //
      if((mibAttributeValue == NULL) && (defaultValue != NULL))
      {
         if(ValidateValue(attributeId, defaultValue, mibAttrValidationFailure))
         {
            mibAttributeValue = defaultValue;
            TRACE_PRINTF_LEV(TRACE_VERBOSE, "InitialiseMO: %s initialising %s with default value %s",
                  GetRDN().ToString().c_str(),
                  getMibAttributeName(attributeId),
                  mibAttributeValue->ToString().c_str());
         }
         else
         {
            TRACE_PRINTF_LEV(TRACE_CRITICAL, "InitialiseMO: %s attr failure (default value): %s",
                  GetRDN().ToString().c_str(),
                  mibAttrValidationFailure.ToString().c_str());
            mibAttrValidationFailures.push_back(mibAttrValidationFailure);
         }
      }

      //
      // Add attribute if we managed to create one.
      //
      if(mibAttributeValue != NULL)
      {
         fullSetMibAttributeValues.AddAttribute(attributeId, mibAttributeValue);
      }
      else
      {
         TRACE_PRINTF("Failed to find a value for attribute %s on %s",
               getMibAttributeName(attributeId), GetRDN().ToString().c_str());
      }

      //
      // Check for MOC attribute and add to list.
      //
      if(commonAttrDesc->mandatoryOnCreate)
      {
         mocAttrIds.push_back(attributeId);
      }
   }

   // Finally initialise the attributes.
   // TODO - when we get to passing in attributes these should probably be written to NV.
   InitialiseMibAttributes(fullSetMibAttributeValues);

   // Now check we have all our MOC attributes.
   for (u32 i = 0; i < mocAttrIds.size(); ++i)
   {
      MibAttributeId mocId = mocAttrIds[i];

      if(m_attributes.find(mocId) == m_attributes.end())
      {
         // Oh dear.  This attribute is MOC but we don't have a value.
         TRACE_PRINTF_LEV(TRACE_CRITICAL, "Attribute %s on MO %s is mandatory-on-create but no value available (NV or default)",
               getMibAttributeName(mocId),
               m_rdn.ToString().c_str());
         // TODO: Raise an alarm through our supplied alarm interface... oh, don't have one yet...
         m_attributesValid = false;
      }
   }

   //
   // Now look for any child objects in NV and add them...
   //
   MibDN thisObjectDN = GetDN();
   for(u32 childClassIndex = 0; childClassIndex < m_moDescriptor->validChildClassesNum; childClassIndex++)
   {
      MibObjectClass childClass = m_moDescriptor->validChildClasses[childClassIndex].validChildClass;

      MibDN childDn = thisObjectDN;
      MibRDN childRdn(childClass, 0 /* arbitrary instance */);
      childDn.push_back(childRdn);
      NvContainerDescriptor childContainerDescriptor = GetNvContainerDescriptor(childDn);
      vector<u32> childInstances = m_nvStore.GetNvContainerInstances(childContainerDescriptor.m_nvContainerName);

      TRACE_PRINTF("MIB: %s: Found %"PRIu32" children of class %s (container %s) in NV",
            thisObjectDN.ToString().c_str(), (u32)childInstances.size(), MibObjectClassToString(childClass), childContainerDescriptor.m_nvContainerName.c_str());

      for(u32 i = 0; i < childInstances.size(); i++)
      {
         // Create the new child object.
         MibRDN childRdn(childClass, childInstances[i]);

         if(FindChildObject(childRdn) == NULL)
         {
            TRACE_PRINTF("MIB: Detected object in NV, adding new child object %s to %s", childRdn.ToString().c_str(), thisObjectDN.ToString().c_str());
            shared_ptr<MibObject> childObject(new MibObject(childRdn, m_nvStore, m_changedAttributesNotifyInterface));

            // Add it as a child to this object.
            AddChildObject(childObject);

            // Initialise the new MO.
            MibAttributeValues emptyAttrValues;
            if(NULL != childObject)
            {
               MibAttrValidationFailures mibAttrValidationFailures = childObject->InitialiseMO(emptyAttrValues);
               RSYS_ASSERT_PRINTF(mibAttrValidationFailures.size() == 0,
                     "Validation failures while creating %s on %s: %s",
                     childRdn.ToString().c_str(), ToString().c_str(),
                     mibAttrValidationFailures.ToString().c_str());
            }
         }
         else
         {
            TRACE_PRINTF("MIB: Detected object in NV but already exists as child %s of %s so no need to add again", childRdn.ToString().c_str(), thisObjectDN.ToString().c_str());
         }
      }
   }

   RETURN(mibAttrValidationFailures);
}

MibDN MibObject::GetDN() const
{
   ENTER();

   MibDN dn;

   // Recurse up the object tree to build up our DN.
   if(m_parentObject != NULL)
   {
      dn = m_parentObject->GetDN();
   }

   dn.push_back(m_rdn);

   RETURN(dn);
}

bool MibObject::HasChildren() const
{
   ENTER();

   RETURN(m_childObjects.size() != 0);
}

boost::shared_ptr<MibObject>  MibObject::FindChildObject(MibRDN rdn)
{
   shared_ptr<MibObject> child;

   ENTER();

   // Check MIB object exists in our list of children.
   MibObjectsByRdn::const_iterator existsIter = m_childObjects.find(rdn);
   if(existsIter != m_childObjects.end())
   {
      child = existsIter->second;
   }
   else
   {
      TRACE_PRINTF("FindChildObject(%s) - failed to find.", rdn.ToString().c_str());
   }

   RETURN(child);
}

void MibObject::GetChildObjects(MibObjectClass objectClass, set< boost::shared_ptr<MibObject> > & childObjects) const
{
   for( MibObjectsByRdn::const_iterator iter = m_childObjects.begin();
         iter != m_childObjects.end();
         iter++)
   {
      const MibRDN & childRdn = iter->first;

      if(childRdn.GetMibObjectClass() == objectClass)
      {
         childObjects.insert(iter->second);
      }
   }
}

void MibObject::AddChildObject(shared_ptr<MibObject> childObject)
{
   ENTER();

   // Preconditions.
   // Pointer must be valid.
   RSYS_ASSERT(childObject != NULL);
   // Check MIB object doesn't already exist in our list of children.
   MibObjectsByRdn::const_iterator existsIter = m_childObjects.find(childObject->GetRDN());
   RSYS_ASSERT_PRINTF(existsIter == m_childObjects.end(), "AddChildObject(%s.%s) failure.", childObject->GetRDN().ToString().c_str(), childObject->ToString().c_str());

   // Check that it is a valid child
   bool childObjectValidRdn = false;
   for( u32 idx = 0; idx < m_moDescriptor->validChildClassesNum; idx++)
   {
      if(    (m_moDescriptor->validChildClasses[idx].validChildClass == childObject->GetRDN().GetMibObjectClass())
            && (m_moDescriptor->validChildClasses[idx].maxInstances     > childObject->GetRDN().GetMibObjectInstance())
        )
      {
         childObjectValidRdn = true;
         break;
      }
   }
   RSYS_ASSERT_PRINTF(
         childObjectValidRdn,
         "Attempt to add invalid child object %s to parent %s",
         childObject->GetRDN().ToString().c_str(),
         m_rdn.ToString().c_str());

   // Insert object into our list of child objects.
   m_childObjects[childObject->GetRDN()] = childObject;

   childObject->SetParentObject(this);

   EXIT();
}

void MibObject::DeleteChildObject(const MibRDN& rdnToDelete)
{
   ENTER();

   MibObjectsByRdn::iterator childObjectIter = m_childObjects.find(rdnToDelete);

   // Check exists.
   RSYS_ASSERT(childObjectIter != m_childObjects.end());

   // Check has no children.
   // coverity[deref_iterator]
   RSYS_ASSERT(!(childObjectIter->second->HasChildren()));

   // Delete it.
   m_childObjects.erase(childObjectIter);

   EXIT();
}

bool ObjectDescriptorLessThan(const MibObjectAttributeDescriptor & lhs,
      const MibObjectAttributeDescriptor & rhs)
{
   return (lhs.mibAttributeId < rhs.mibAttributeId);
}

MibAttrValidationFailures MibObject::ValidateAttributes(const MibAttributeValues& attributeValues, bool checkAccessClass)
{
   ENTER();

   RSYS_ASSERT_PRINTF(m_moInitialised, "%s", ToString().c_str());

   MibAttrValidationFailure failureDescriptor; // Don't need to create a new one each time, just reuse this one.
   MibAttrValidationFailures failureDescriptors;

   // Check if this attribute is allowed on this object.
   const MibAttributeValues::MibAttributeValuesById& values = attributeValues.GetAttributeValues();
   MibAttributeValues::MibAttributeValuesById::const_iterator iter = values.begin();

   while(iter != values.end())
   {
      MibAttributeId id = iter->first;
      MibAttributeAccessClass mibAttributeAccessClass;
      shared_ptr<MibAttributeValue> mibAttributeValue = iter->second;

      bool attributeFound = false;

      for (u32 index = 0; index < m_moDescriptor->validAttributeIdsNum; ++index)
      {
         if (m_moDescriptor->validAttributeIds[index].mibAttributeId == id)
         {
            mibAttributeAccessClass =  m_moDescriptor->validAttributeIds[index].accessClass;
            attributeFound = true;
            break;
         }
      }

      if(attributeFound)
      {
         // Check it is writable.
         if(checkAccessClass && (mibAttributeAccessClass == MIB_ACCESS_READ_ONLY))
         {
            MibAttrValidationFailure failure(id);
            string desc = "Attribute ";
            desc += getMibAttributeName(id);
            desc += " is READ ONLY on MO ";
            desc += GetDN().ToString();
            failure.Set(ValidationFailureDescriptor::CAUSE_READ_ONLY, desc);
            failure.SetMibAttributeId(id);
            failureDescriptors.push_back(failure);
         }
         else if(!ValidateValue(id, mibAttributeValue, failureDescriptor))
         {
            failureDescriptors.push_back(failureDescriptor);
         }
      }
      else
      {
         MibAttrValidationFailure failure(id);
         string desc = "Attribute ";
         desc += getMibAttributeName(id);
         desc += " not allowed on MO ";
         desc += GetDN().ToString();
         failure.Set(ValidationFailureDescriptor::CAUSE_NOT_ALLOWED_ON_OBJECT, desc);
         failure.SetMibAttributeId(id);
         failureDescriptors.push_back(failure);
      }
      ++iter;
   } // end while

   RETURN(failureDescriptors);
}

void MibObject::InitialiseMibAttributes(const MibAttributeValues& attributeValues )
{
   ENTER();

   // Preconditions.
   RSYS_ASSERT_PRINTF(m_moInitialised, "%s", ToString().c_str());

   // Pointer must be valid.
   RSYS_ASSERT_PRINTF(m_moDescriptor != NULL, "%s", ToString().c_str());

   // Ensure that this object allows attributes to be attached.
   //RSYS_ASSERT_PRINTF(m_moDescriptor->validAttributeIdsNum > 0, "%s", ToString().c_str());

   // Validate the attributes.
   MibAttrValidationFailures validationFailures = ValidateAttributes(attributeValues, false );
   RSYS_ASSERT_PRINTF(validationFailures.empty(), "%s", validationFailures.ToString().c_str());

   // Attributes that are new or have changed value.
   MibAttributeIds changedAttributeIds;

   // Loop through attributes, create attribute object for each and put in / replace in map.
   const MibAttributeValues::MibAttributeValuesById& values = attributeValues.GetAttributeValues();
   MibAttributeValues::MibAttributeValuesById::const_iterator iter = values.begin();

   while(iter != values.end())
   {
      MibAttributeId id = iter->first;
      MibAttributeStorageClass mibAttributeStorageClass = MIB_STORAGE_NON_VOLATILE;

      shared_ptr<MibAttributeValue> mibAttributeValue = iter->second;

      // Find the attribute specific data on the mo
      const MibObjectAttributeDescriptor* descriptorIter = getMibObjectAttributeDescriptor(m_moDescriptor->mibObjectClass, id);
      RSYS_ASSERT(descriptorIter != NULL);
      if(NULL != descriptorIter)
      {
         mibAttributeStorageClass = descriptorIter->storageClass;
      }

      // Create the attribute.
      shared_ptr<MibAttribute> mibAttribute(new MibAttribute(id, mibAttributeValue));

      TRACE_PRINTF("%s: Setting attribute %s mibAttributeStorageClass %d", GetRDN().ToString().c_str(), mibAttribute->ToString().c_str(), mibAttributeStorageClass);

      // See if we already have it.
      bool present = false, different = false;
      MibAttributesById::iterator checkAttrExistsIter = m_attributes.find(id);
      if(checkAttrExistsIter != m_attributes.end())
      {
         present = true;
         RSYS_ASSERT(checkAttrExistsIter->second != NULL);
         if(!checkAttrExistsIter->second->IsValueEqual(*mibAttribute))
         {
            different = true;
         }
      }

      // See if the value is new or changed.
      if(!present || different)
      {
         changedAttributeIds.insert(id);
      }

      // Now actually add it to our attributes.
      m_attributes[id] = mibAttribute;

      ++iter;
   } // for each attribute

   // Notify of changed attributes.
   if(m_changedAttributesNotifyInterface)
   {
      m_changedAttributesNotifyInterface->HandleChangedAttributes(GetDN(), changedAttributeIds);
   }

   EXIT();
}

void MibObject::SetMibAttributes(const MibAttributeValues& attributeValues, bool checkAccessClass)
{
   ENTER();

   // Preconditions.
   RSYS_ASSERT_PRINTF(m_moInitialised, "%s", ToString().c_str());

   // Pointer must be valid.
   RSYS_ASSERT_PRINTF(m_moDescriptor != NULL, "%s", ToString().c_str());

   // Ensure that this object allows attributes to be attached.
   RSYS_ASSERT_PRINTF(m_moDescriptor->validAttributeIdsNum > 0, "%s", ToString().c_str());

   // Validate the attributes.
   MibAttrValidationFailures validationFailures = ValidateAttributes(attributeValues, checkAccessClass);

   // Attributes to later write to NV.
   vector<NvAttribute> nvAttributes;

   // Attributes that are new or have changed value.
   MibAttributeIds changedAttributeIds;

   // Loop through attributes, create attribute object for each and put in / replace in map.
   const MibAttributeValues::MibAttributeValuesById& values = attributeValues.GetAttributeValues();
   MibAttributeValues::MibAttributeValuesById::const_iterator iter = values.begin();

   while(iter != values.end())
   {
      MibAttributeId id = iter->first;
      shared_ptr<MibAttributeValue> mibAttributeValue = iter->second;

      // Get common descriptor.
      const MibAttributeCommonDescriptor* commonDesc = getMibAttributeCommonDesc(id);
      TRACE_PRINTF("SetMibAttributes:schema version is %d",commonDesc->schema);
      // Overwrite the common descriptor with anything set in the object

      // Create the attribute.
      shared_ptr<MibAttribute> mibAttribute(new MibAttribute(id, mibAttributeValue));

      TRACE_PRINTF("%s: Setting attribute %s", GetRDN().ToString().c_str(), mibAttribute->ToString().c_str());
      // See if we already have it.
      bool present = false, different = false;
      MibAttributesById::iterator checkAttrExistsIter = m_attributes.find(id);
      if(checkAttrExistsIter != m_attributes.end())
      {
         present = true;
         RSYS_ASSERT(checkAttrExistsIter->second != NULL);
         if(!checkAttrExistsIter->second->IsValueEqual(*mibAttribute))
         {
            different = true;
         }
      }

      // See if the value is new or changed.
      if(not(present) || different)
      {
         changedAttributeIds.insert(id);
      }

      // Now actually add it to our attributes.
      m_attributes[id] = mibAttribute;

      // Find the attribute specific data on the mo
      const MibObjectAttributeDescriptor* descriptorIter = getMibObjectAttributeDescriptor(m_moDescriptor->mibObjectClass, id);
      RSYS_ASSERT(descriptorIter != NULL);

      if(NULL != descriptorIter)
      {
         // See if should be written to NV.
         if (descriptorIter->storageClass == MIB_STORAGE_NON_VOLATILE)
         {
            // Sparse multi-instance not support so instance is currently always zero.
            NvAttributeDescriptor nvAttributeDescriptor(commonDesc->mibAttributeName, 0);
            NvAttribute nvAttribute(nvAttributeDescriptor,
                  mibAttribute->GetValue()->GetValueAsString(),
                  commonDesc->schema);

            // Add to the list to write later.
            nvAttributes.push_back(nvAttribute);
         }
      }

      ++iter;
   } // for each attribute


   // Set the attributes in NV.  Doing in one step so no need for a transaction (and MibManager may want
   // to run a transaction in order to achieve atomic commits across MOs).
   if(not(nvAttributes.empty())) // Avoid benign warning if store is read-only but we have nothing to write to it.
   {
      m_nvStore.SetNvAttributes(m_nvContainerDescriptor, nvAttributes);
   }

   // Notify of changed attributes.
   if(m_changedAttributesNotifyInterface)
   {
      m_changedAttributesNotifyInterface->HandleChangedAttributes(GetDN(), changedAttributeIds);
   }

   EXIT();
}

void MibObject::GetMibAttributes(const MibAttributeIds& attributeIds,
      MibAttributeValues& mibAttributeValues) const
{
   ENTER();

   // Preconditions.
   RSYS_ASSERT(m_moInitialised);
   // Start with an empty container.
   RSYS_ASSERT_PRINTF(mibAttributeValues.GetAttributeCount() == 0, "%s", m_rdn.ToString().c_str());

   TRACE_PRINTF("GetMibAttributes: %s: Getting %"PRIu32" attributes", m_rdn.ToString().c_str(), (u32)attributeIds.size());

   MibAttributeIds::const_iterator iter = attributeIds.begin();
   while(iter != attributeIds.end())
   {
      MibAttributeId id = *iter;
      MibAttributesById::const_iterator findIter = m_attributes.find(id);
      if(findIter != m_attributes.end())
      {
         // Check attribute object is actually there.
         RSYS_ASSERT_PRINTF(findIter->second != NULL, "%s", m_rdn.ToString().c_str());
         // Check IDs match!
         RSYS_ASSERT_PRINTF(findIter->second->GetMibAttributeId() == id,
               "id=%"PRIu32"(%s) != id=%"PRIu32"(%s)",
               findIter->second->GetMibAttributeId(), getMibAttributeName(findIter->second->GetMibAttributeId()),
               id, getMibAttributeName(id));

         // Add ID and value pair to our collection of attribute values.
         findIter->second->PopulateWithValue(mibAttributeValues);
      }
      else
      {
         TRACE_PRINTF("  Attribute %s not present", getMibAttributeName(*iter));
      }

      ++iter;
   }

   EXIT();
}

void MibObject::GetMibAttributes(MibAttributeValues& mibAttributeValues) const
{
   // Preconditions.
   RSYS_ASSERT(m_moInitialised);

   // Start with an empty container.
   RSYS_ASSERT_PRINTF(mibAttributeValues.GetAttributeCount() == 0, "%s", m_rdn.ToString().c_str());

   TRACE_PRINTF("GetMibAttributes: %s: Getting all attributes", m_rdn.ToString().c_str());

   MibAttributesById::const_iterator iter = m_attributes.begin();
   while(iter != m_attributes.end())
   {
      // Add ID and value pair to our collection of attribute values.
      iter->second->PopulateWithValue(mibAttributeValues);

      ++iter;
   }
}

void MibObject::DeleteMibAttributes(const MibAttributeIds& attributeIds)
{
   ENTER();

   // Preconditions.
   RSYS_ASSERT(m_moInitialised);

   TRACE_PRINTF("DeleteMibAttributes: %s: Deleting %"PRIu32" attributes", m_rdn.ToString().c_str(), (u32)attributeIds.size());

   // Collect the ones to be deleted from NV.
   vector<NvAttributeDescriptor> nvAttrDescs;

   // Collect the IDs for attributes that we actually delete from the MIB.
   MibAttributeIds actuallyDeletedAttributeIds;

   MibAttributeIds::const_iterator iter = attributeIds.begin();
   while(iter != attributeIds.end())
   {
      MibAttributeId id = *iter;
      MibAttributesById::iterator findIter = m_attributes.find(id);
      if(findIter != m_attributes.end())
      {
         // Check attribute object is actually there.
         RSYS_ASSERT_PRINTF(findIter->second != NULL, "%s", m_rdn.ToString().c_str());
         // Check IDs match!
         RSYS_ASSERT_PRINTF(findIter->second->GetMibAttributeId() == id,
               "id=%"PRIu32"(%s) != id=%"PRIu32"(%s)",
               findIter->second->GetMibAttributeId(), getMibAttributeName(findIter->second->GetMibAttributeId()),
               id, getMibAttributeName(id));

         // Check volatility.
         const MibObjectAttributeDescriptor* descriptorIter = getMibObjectAttributeDescriptor(m_moDescriptor->mibObjectClass, id);
         RSYS_ASSERT(descriptorIter != NULL);

         if(NULL != descriptorIter)
         {
            // If NV, take note for later deletion from NV.
            if(descriptorIter->storageClass == MIB_STORAGE_NON_VOLATILE)
            {
               // Get common descriptor.
               const MibAttributeCommonDescriptor* commonDesc = getMibAttributeCommonDesc(id);
               NvAttributeDescriptor nvAttrDesc(commonDesc->mibAttributeName, 0); // TODO: Managing attribute instances comes later...
               nvAttrDescs.push_back(nvAttrDesc);
            }
         }

         // Delete it from RAM.
         m_attributes.erase(findIter);

         actuallyDeletedAttributeIds.insert(id);
      }
      else
      {
         TRACE_PRINTF("  Attribute %s not present", getMibAttributeName(id));
      }

      ++iter;
   }

   // Delete the attributes from NV.  Doing in one step so no need for a transaction (and
   // MibManager may want to run a transaction in order to achieve atomic commits across MOs).
   if(not(nvAttrDescs.empty()))
   {
      m_nvStore.DeleteNvAttributes(m_nvContainerDescriptor, nvAttrDescs);
   }

   // Notify of changed attributes.
   if(m_changedAttributesNotifyInterface)
   {
      m_changedAttributesNotifyInterface->HandleDeletedAttributes(GetDN(), actuallyDeletedAttributeIds);
   }

   EXIT();
}


void MibObject::DeleteMibObject()
{
   m_nvStore.DeleteNvContainer(m_nvContainerDescriptor);
}

void MibObject::GetMibAttributesDiffFromDefaults(MibAttributeValues& diffFromDefaultValues)
{
   ENTER();

   for (MibAttributesById::const_iterator iter = m_attributes.begin();
         iter != m_attributes.end();
         ++iter)
   {
      RSYS_ASSERT(iter->second != NULL);

      shared_ptr<MibAttributeValue> defaultValue = GetDefaultValue(iter->first);
      if( ((defaultValue != NULL) && (not(iter->second->GetValue()->IsValueEqual(*defaultValue))))
            ||
            (defaultValue == NULL)
        )
      {
         // Either this attribute has a default and the current value is different from it
         // or it doesn't have a default, it which case the fact it now has a value is also
         // a difference-from-default... of sorts.
         diffFromDefaultValues.AddAttribute(iter->second->GetMibAttributeId(), iter->second->GetValue());
      }
   }

   // TODO: perhaps should also look for attributes that have a default but have subsequently
   // been deleted?

   EXIT();
}

void MibObject::GetMibAttributesSetInNv(MibAttributeValues& setInNvValues)
{
   ENTER();

   RSYS_ASSERT(m_moInitialised);

   for (MibAttributesById::const_iterator iter = m_attributes.begin();
         iter != m_attributes.end();
         ++iter)
   {
      RSYS_ASSERT(iter->second != NULL);

      // Easiest to just ask the NV store rather than track this information independently.
      // Need to just double check this attribute is of storage class NV as we may have some
      // values in the NV store that are ignored (volatile) in this build.

      const MibObjectAttributeDescriptor* descriptorIter = getMibObjectAttributeDescriptor(m_moDescriptor->mibObjectClass, iter->first);

      RSYS_ASSERT(descriptorIter != NULL);
      if(NULL != descriptorIter)
      {
         if(descriptorIter->storageClass == MIB_STORAGE_NON_VOLATILE)
         {
            NvAttributeDescriptor nvAttrDesc;
            nvAttrDesc.m_nvAttributeInstance = 0;
            nvAttrDesc.m_nvAttributeName = getMibAttributeName(iter->first);

            NvAttributeValue nvAttrValue;
            NvAttributeResult nvGetAttrResult = m_nvStore.GetNvAttribute(m_nvContainerDescriptor, nvAttrDesc, nvAttrValue);
            if(nvGetAttrResult == NV_ATTRIBUTE_RESULT_OK)
            {
               setInNvValues.AddAttribute(iter->second->GetMibAttributeId(), iter->second->GetValue());
            }
         }
      }
   }

   EXIT();
}

string MibObject::ToString() const
{
   ENTER();

   ostringstream stream;

   stream << *this;

   RETURN(stream.str());
}

std::ostream& operator<< (std::ostream& os, const MibObject& s)
{
   ENTER();

   os << s.GetDN() << ':';

   // Show the attributes
   if(not(s.m_attributes.empty()))
   {
      os << endl << " Attributes: ";

      for (MibAttributesById::const_iterator iter = s.m_attributes.begin();
            iter != s.m_attributes.end();
            ++iter)
      {
         RSYS_ASSERT(iter->second != NULL);
         os << iter->second->ToString() << ' ';
      }
   }
   else
   {
      os << endl << " No Attributes";
   }

   // Show the childobjects
   if(not(s.m_childObjects.empty()))
   {
      os << endl << " Children: ";

      for(MibObjectsByRdn::const_iterator childIter = s.m_childObjects.begin();
            childIter != s.m_childObjects.end();
            ++childIter)
      {
         RSYS_ASSERT(childIter->second != NULL);
         os << childIter->second->GetRDN() << ' ';
      }
   }
   else
   {
      os << endl << " No Children";
   }

   RETURN(os);
}

void MibObject::SetParentObject(MibObject *parentObject)
{
   ENTER();

   m_parentObject = parentObject;

   EXIT();
}

bool MibObject::ValidateValue(MibAttributeId attributeId, boost::shared_ptr<MibAttributeValue> mibAttributeValue, MibAttrValidationFailure& mibAttrValidationFailure)
{
   ENTER();

   shared_ptr<MibAttribute> mibAttribute(new MibAttribute(attributeId, mibAttributeValue));

   RSYS_ASSERT_PRINTF(attributeId < NUM_MIB_ATTR_IDS, "%s", GetRDN().ToString().c_str());

   if(MibAttribute::ValidateValue(GetDN(), attributeId, mibAttributeValue, mibAttrValidationFailure))
   {
      if(strstr(mibAttribute->ToString().c_str(),"LTE_GERAN_FREQ_SRC"))
      {
         freqSrcLst = mibAttributeValue->GetValueU32Array();
      }
      else if(strstr(mibAttribute->ToString().c_str(),"LTE_GERAN_CELL_SRC"))
      {
         cellSrcLst = mibAttributeValue->GetValueU32Array();
      }
      else if(strstr(mibAttribute->ToString().c_str(),"LTE_X_RADISYS_NEIGH_FREQ_SRC"))
      {
         lteInterFreqSrcLst = mibAttributeValue->GetValueU32Array();
         return(true);
      }
      if(strstr(GetRDN().ToString().c_str(), "LTE_INTER_RAT_GERAN"))
      {
         if(strstr(GetRDN().ToString().c_str(), "FREQ"))
         {    
            RETURN(MibObject::ValidateGeranFreqParam(attributeId, mibAttributeValue, mibAttrValidationFailure));
         }
         else
         {
            RETURN(MibObject::ValidateGeranCellParam(attributeId, mibAttributeValue, mibAttrValidationFailure));
         }
      }
      return(true);
   }
   else
   {
      return(false);
   }
}

shared_ptr<MibAttributeValue> MibObject::GetDefaultValue(MibAttributeId id)
{
   ENTER();

   shared_ptr<MibAttributeValue> defaultValue;
   const MibAttributeCommonDescriptor * commonAttrDesc = getMibAttributeCommonDesc(id);

   switch(commonAttrDesc->mibAttributeType)
   {
      case MIB_ATTRIBUTE_TYPE_U32:
      case MIB_ATTRIBUTE_TYPE_ENUM:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueU32(getMibAttributeU32Descriptor(id)->defaultValue));
         }
         break;
      case MIB_ATTRIBUTE_TYPE_S32:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueS32(getMibAttributeS32Descriptor(id)->defaultValue));
         }
         break;
      case MIB_ATTRIBUTE_TYPE_STRING:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueString(getMibAttributeStringDescriptor(id)->defaultValue));
         }
         break;
      case MIB_ATTRIBUTE_TYPE_U32ARRAY:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueU32Array(getMibAttributeU32ArrayDescriptor(id)->defaultValue));
         }
         break;
      case MIB_ATTRIBUTE_TYPE_S32ARRAY:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueS32Array(getMibAttributeS32ArrayDescriptor(id)->defaultValue));
         }
         break;  
      case MIB_ATTRIBUTE_TYPE_STRINGARRAY:
         if(commonAttrDesc->hasDefault)
         {
            defaultValue.reset(new MibAttributeValueStringArray(getMibAttributeStringArrayDescriptor(id)->defaultValue));
         }
         break;
      case MIB_ATTRIBUTE_TYPE_ENUMARRAY:
         // Do nothing, this attribute type has no default with this implementation
         // TODO: Implement default values for array types
         break;
   }

   RETURN(defaultValue);
}

const MibObjectAttributeDescriptor* getMibObjectAttributeDescriptor(MibObjectClass moId, MibAttributeId attrId)
{
   ENTER();

   const MibObjectAttributeDescriptor *result = NULL;
   const MibManagedObjectDescriptor * moDescriptor = getManagedObjectDescriptor(moId);

   if(moDescriptor != NULL)
   {
      for (result = moDescriptor->validAttributeIds;
            (result < (moDescriptor->validAttributeIds + moDescriptor->validAttributeIdsNum)
             && (result->mibAttributeId != attrId));
            ++result) { }

      if (result == (moDescriptor->validAttributeIds + moDescriptor->validAttributeIdsNum))
      {
         result = NULL;
      }
   }

   RETURN(result);
}

/*
 * *  Function to return the instance number of the Object if it is
 * *  a Multi Instance Object
 * */
char * MibObject::GetMibObjectInstanceNum(string dn) const
{
   TRACE_PRINTF("%s:Entry",__FUNCTION__);
   char* dnchar = const_cast<char*>(dn.c_str());
   char * token = strtok(dnchar,".");
   char * lasttoken = NULL;
   while(token != NULL)
   {
      lasttoken = token;
      token = strtok(NULL,".");
   }

   TRACE_PRINTF("Object instance token int =%s",lasttoken);
   return lasttoken;
}

bool MibObject::ValidateGeranFreqParam(MibAttributeId id, shared_ptr<MibAttributeValue> mibAttributeValue, MibAttrValidationFailure& failureDescriptor)
{
   shared_ptr<MibAttribute> mibAttribute(new MibAttribute(id, mibAttributeValue));
   vector<u32>::iterator itr;

   TRACE_PRINTF("%s",__FUNCTION__);
   // if(MIB_ATTRIBUTE_TYPE_STRING == mibAttributeValue->GetType())

   //{
   if(strstr(mibAttribute->ToString().c_str(),"FREQ_ENABLE"))
   {

      char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
      if(index == NULL)
      {
         //We should not get here
         return false;
      }
      u32 instance = atoi(index);
      u32 freqEnableVal = mibAttributeValue->GetValueU32();

      if( freqEnableVal == 1 )
      {     
         string moStr ;
         if(!freqBandInd.empty())
         {
            moStr = freqBandInd.at(instance);
           u32 freqValue = freqArfcn.at(instance);
           if(!ValidateGeranArfcn(moStr,freqValue))
           {
               string desc = "NotValidValue:";
               desc += "BCCHARFCN value not allowed for BandIndicator:";
               desc += moStr;
               failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
               failureDescriptor.SetMibAttributeId(id);
               return(false);
          }

            if(0 == strcmp(moStr.c_str(),"DCS1800"))
            {
               if(freqBandInd.end() != find(freqBandInd.begin(), freqBandInd.end(), "PCS1900"))
               {
                  string desc = "Attribute ";
                  desc += "FREQ_BAND_INDICATOR";
                  desc += " not allowed value ";
                  desc += GetDN().ToString();
                  failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                  failureDescriptor.SetMibAttributeId(id);
                  return(false);
               }
            }  
            else if(0 == strcmp(moStr.c_str(),"PCS1900"))
            {
               if(freqBandInd.end() != find(freqBandInd.begin(), freqBandInd.end(), "DCS1800"))
               {
                  string desc = "Attribute ";
                  desc += "FREQ_BAND_INDICATOR";
                  desc += " not allowed value ";
                  desc += GetDN().ToString();
                  failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                  failureDescriptor.SetMibAttributeId(id);
                  return(false);
               }
            }

         } 
      }
   }
   else if((strstr(mibAttribute->ToString().c_str(),"FREQ_BAND_INDICATOR")))
   {
      char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
      if(index != NULL)
      {
         u32 instance = atoi(index);
         string moStr = mibAttributeValue->GetValueString();
         freqBandInd.insert(freqBandInd.begin() + instance ,moStr.c_str());
         TRACE_PRINTF("%s: Setting attribute %s", GetRDN().ToString().c_str(), mibAttribute->ToString().c_str());
      }
   }
   else
   {
      if(strstr(mibAttribute->ToString().c_str(),"FREQ_BCCH_ARFCN"))
      {
         char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
         if(index != NULL)
         {
            u32 instance = atoi(index);
            u32 freqArfcnVal = mibAttributeValue->GetValueU32();
            freqArfcn.at(instance) = freqArfcnVal;
            TRACE_PRINTF("%s: Setting attribute %s", GetRDN().ToString().c_str(), mibAttribute->ToString().c_str());
         }
      }
   }
   return(true);
}

bool MibObject::ValidateGeranCellParam(MibAttributeId id, shared_ptr<MibAttributeValue> mibAttributeValue, MibAttrValidationFailure& failureDescriptor)
{
   shared_ptr<MibAttribute> mibAttribute(new MibAttribute(id, mibAttributeValue));
   vector<u32>::iterator itr;

   if(strstr(mibAttribute->ToString().c_str(),"CELL_ENABLE"))
   {
      char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
      if(index == NULL)
      {
         //we should not reach here
         return false;
      }
      u32 instance = atoi(index);
      u32 cellEnableVal = mibAttributeValue->GetValueU32();
      if(cellEnableVal == 1)
      {
         string moStr = cellNccList.at(instance);
         for (u32 idx = 0; idx < cellNccList.size(); idx++)
         {
            if((idx != instance) && (0 == strcmp(cellPlmnList.at(instance).c_str(), cellPlmnList.at(idx).c_str())))
            {
               if(0 != strcmp(moStr.c_str(), cellNccList.at(idx).c_str()))
               {
                  string desc = "Attribute ";
                  desc += "LTE_GERAN_X_RSYS_CELL_NCC_PERMIT";
                  desc += " for same PLMN NCC permitted should be same ";
                  desc += GetDN().ToString();
                  failureDescriptor.SetMibAttributeId(id);
                  failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                  return(false);
               }
            }
         }

         moStr = cellPlmnList.at(instance);

         for (u32 idx = 0; idx < cellPlmnList.size(); idx++)
         {
            if((idx != instance) && (0 == strcmp(moStr.c_str(), cellPlmnList.at(idx).c_str())))
            {
               if(0 != strcmp(cellNccList.at(instance).c_str(),cellNccList.at(idx).c_str()))
               {
                  string desc = "Attribute ";
                  desc += "LTE_GERAN_CELL_PLMNID";
                  desc += " for same PLMN NCC permitted should be same";
                  desc += GetDN().ToString();
                  failureDescriptor.SetMibAttributeId(id);
                  failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                  return(false);
               }
               if(cellArfcn.at(idx) == cellArfcn.at(instance))
               {
                  string desc = "Attribute ";
                  desc += "LTE_GERAN_CELL_PLMNID";
                  desc += " for same PLMN ARFCN should not be same ";
                  desc += GetDN().ToString();
                  failureDescriptor.SetMibAttributeId(id);
                  failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                  return(false);
               }
            }
         }

         u32 freqPres = false;
         u32 cellArfcnVal = cellArfcn.at(instance);

         for (u32 idx=0; idx < freqArfcn.size(); idx++)
         {
            if(cellArfcnVal == freqArfcn.at(idx))
            {
               freqPres = true;
               for (u32 index = 0; index < cellArfcn.size(); index++)
               {
                  if((index != instance) && (cellArfcn.at(index) == cellArfcnVal) && (0 == strcmp(cellPlmnList.at(index).c_str(), cellPlmnList.at(instance).c_str())))
                  {
                     string desc = "Attribute ";
                     desc += "CELL_BCCH_ARFCN";
                     desc += " cell ARFCN and plmn combination can not be duplicate ";
                     desc += GetDN().ToString();
                     failureDescriptor.SetMibAttributeId(id);
                     failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
                     return(false);
                  }
               }
               break;
            }  
         }
         if(false == freqPres)
         {
            string desc = "Attribute ";
            desc += "CELL_BCCH_ARFCN";
            desc += " cell ARFCN should be present in Freq configuration ";
            desc += GetDN().ToString();
            failureDescriptor.SetMibAttributeId(id);
            failureDescriptor.Set(ValidationFailureDescriptor::CAUSE_NOT_VALID_VALUE, desc);
            return(false);
         }

      }
   }
   else if(strstr(mibAttribute->ToString().c_str(),"LTE_GERAN_X_RSYS_CELL_NCC_PERMIT"))
   {
      char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
      if(index != NULL)
      {
         u32 instance = atoi(index);
         string moStr = mibAttributeValue->GetValueString();
         cellNccList.at(instance) = moStr.c_str();
      }
   }
   else if((strstr(mibAttribute->ToString().c_str(),"LTE_GERAN_CELL_PLMNID")) || (strstr(mibAttribute->ToString().c_str(),"LTE_GERAN_X_RSYS_CELL_PLMNID")))
   {
      char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
      if(index != NULL)
      {
         u32 instance = atoi(index);
         string moStr = mibAttributeValue->GetValueString();
         cellPlmnList.at(instance) = moStr.c_str();
      }
   }
   else
   {
      if(strstr(mibAttribute->ToString().c_str(),"CELL_BCCH_ARFCN"))
      {
         char * index = GetMibObjectInstanceNum(GetRDN().ToString().c_str());
         if(index != NULL)
         {
            u32 instance = atoi(index);
            // u32 freqPres = false;
            u32 cellArfcnVal = mibAttributeValue->GetValueU32();
            cellArfcn.at(instance) = cellArfcnVal;
            TRACE_PRINTF("%s: Setting attribute %s", GetRDN().ToString().c_str(), mibAttribute->ToString().c_str());
         }

      }
   }

   return(true);
}
